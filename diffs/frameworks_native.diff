diff --git a/frameworks/native/cmds/dumpstate/dumpstate.c b/gb/12055-master/driveronly_mp_rom/frameworks/native/cmds/dumpstate/dumpstate.c
index f3fcca0..af67617 100644
--- a/frameworks/native/cmds/dumpstate/dumpstate.c
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/cmds/dumpstate/dumpstate.c
@@ -43,8 +43,48 @@ static const char *dump_traces_path = NULL;
 
 static char screenshot_path[PATH_MAX] = "";
 
+#ifdef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 modify
+#define NORMAL_TYPE_STRING "normal"
+#define ASSERT_TYPE_STRING "assert"
+#define FEEDBACK_TYPE_STRING "feedback"
+#define ALL_TYPE_STRING "all"
+
+#define NORMAL_TYPE 0
+#define ASSERT_TYPE 1
+#define FEEDBACK_TYPE 2
+#define ALL_TYPE 3
+
+#define _parse_type(str, type) \
+            ({ \
+                strcmp(str, type##_STRING) == 0 ? type : NORMAL_TYPE; \
+            })
+
+static int parse_type(char *type, int length)
+{
+    if (type == NULL)
+        return NORMAL_TYPE;
+    switch(length) {
+        case 3:
+            return _parse_type(type, ALL_TYPE);
+        case 6:
+            return _parse_type(type, ASSERT_TYPE);
+        case 8:
+            return _parse_type(type, FEEDBACK_TYPE);
+        default:
+            return NORMAL_TYPE;
+    }
+}
+#endif /* VENDOR_EDIT */
+
 /* dumps the current system state to stdout */
+#ifndef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 modifiy
+// android code
 static void dumpstate() {
+#else
+static void dumpstate(const int type) {
+#endif /* VENDOR_EDIT */
     time_t now = time(NULL);
     char build[PROPERTY_VALUE_MAX], fingerprint[PROPERTY_VALUE_MAX];
     char radio[PROPERTY_VALUE_MAX], bootloader[PROPERTY_VALUE_MAX];
@@ -75,6 +115,9 @@ static void dumpstate() {
     printf("Command line: %s\n", strtok(cmdline_buf, "\n"));
     printf("\n");
 
+#ifndef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 modifiy
+    // android code
     run_command("UPTIME", 10, "uptime", NULL);
     dump_file("MEMORY INFO", "/proc/meminfo");
     run_command("CPU INFO", 10, "top", "-n", "1", "-d", "1", "-m", "30", "-t", NULL);
@@ -89,9 +132,7 @@ static void dumpstate() {
 
 
     dump_file("KERNEL WAKELOCKS", "/proc/wakelocks");
-    dump_file("KERNEL WAKE SOURCES", "/d/wakeup_sources");
     dump_file("KERNEL CPUFREQ", "/sys/devices/system/cpu/cpu0/cpufreq/stats/time_in_state");
-    dump_file("KERNEL SYNC", "/d/sync");
 
     run_command("PROCESSES", 10, "ps", "-P", NULL);
     run_command("PROCESSES AND THREADS", 10, "ps", "-t", "-p", "-P", NULL);
@@ -104,6 +145,65 @@ static void dumpstate() {
     for_each_pid(do_showmap, "SMAPS OF ALL PROCESSES");
     for_each_pid(show_wchan, "BLOCKED PROCESS WAIT-CHANNELS");
 
+#else
+    switch (type) {
+        case ASSERT_TYPE: {
+            dump_file("MEMORY INFO", "/proc/meminfo");
+            run_command("CPU INFO", 10, "top", "-n", "1", "-d", "1", NULL);
+            dump_file("VMALLOC INFO", "/proc/vmallocinfo");
+			
+            run_command("PROCESSES", 10, "ps", "-P", NULL);
+            run_command("PROCESSES AND THREADS", 10, "ps", "-t", "-p", "-P", NULL);
+			
+            run_command("LIST OF OPEN FILES", 10, SU_PATH, "root", "lsof", NULL);
+        }
+        break;
+        case FEEDBACK_TYPE: {
+            dump_file("MEMORY INFO", "/proc/meminfo");
+            run_command("CPU INFO", 10, "top", "-n", "1", "-d", "1", "-m", "30", "-t", NULL);
+			
+            dump_file("VIRTUAL MEMORY STATS", "/proc/vmstat");
+            dump_file("VMALLOC INFO", "/proc/vmallocinfo");
+			
+            dump_file("KERNEL WAKELOCKS", "/proc/wakelocks");
+            dump_file("KERNEL CPUFREQ", "/sys/devices/system/cpu/cpu0/cpufreq/stats/time_in_state");
+			
+            run_command("PROCESSES", 10, "ps", "-P", NULL);
+            run_command("PROCESSES AND THREADS", 10, "ps", "-t", "-p", "-P", NULL);
+			
+            do_dmesg();
+        }
+        break;
+        default: {
+            run_command("UPTIME", 10, "uptime", NULL);
+            dump_file("MEMORY INFO", "/proc/meminfo");
+            run_command("CPU INFO", 10, "top", "-n", "1", "-d", "1", "-m", "30", "-t", NULL);
+            run_command("PROCRANK", 20, "procrank", NULL);
+            dump_file("VIRTUAL MEMORY STATS", "/proc/vmstat");
+            dump_file("VMALLOC INFO", "/proc/vmallocinfo");
+            dump_file("SLAB INFO", "/proc/slabinfo");
+            dump_file("ZONEINFO", "/proc/zoneinfo");
+            dump_file("PAGETYPEINFO", "/proc/pagetypeinfo");
+            dump_file("BUDDYINFO", "/proc/buddyinfo");
+
+            dump_file("KERNEL WAKELOCKS", "/proc/wakelocks");
+            dump_file("KERNEL CPUFREQ", "/sys/devices/system/cpu/cpu0/cpufreq/stats/time_in_state");
+
+            run_command("PROCESSES", 10, "ps", "-P", NULL);
+            run_command("PROCESSES AND THREADS", 10, "ps", "-t", "-p", "-P", NULL);
+            run_command("LIBRANK", 10, "librank", NULL);
+
+            do_dmesg();
+
+            run_command("LIST OF OPEN FILES", 10, SU_PATH, "root", "lsof", NULL);
+
+            for_each_pid(do_showmap, "SMAPS OF ALL PROCESSES");
+            for_each_pid(show_wchan, "BLOCKED PROCESS WAIT-CHANNELS");
+        }
+        break;
+    }
+#endif /* VENDOR_EDIT */
+
     // dump_file("EVENT LOG TAGS", "/etc/event-log-tags");
     run_command("SYSTEM LOG", 20, "logcat", "-v", "threadtime", "-d", "*:v", NULL);
     run_command("EVENT LOG", 20, "logcat", "-b", "events", "-v", "threadtime", "-d", "*:v", NULL);
@@ -145,6 +245,10 @@ static void dumpstate() {
         }
     }
 
+#ifdef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 modifiy
+    if (type == ALL_TYPE || type == NORMAL_TYPE) {
+#endif /* VENDOR_EDIT */
     dump_file("NETWORK DEV INFO", "/proc/net/dev");
     dump_file("QTAGUID NETWORK INTERFACES INFO", "/proc/net/xt_qtaguid/iface_stat_all");
     dump_file("QTAGUID NETWORK INTERFACES INFO (xt)", "/proc/net/xt_qtaguid/iface_stat_fmt");
@@ -197,6 +301,10 @@ static void dumpstate() {
     property_get("dhcp.wlan0.dns2", network, "");
     if (network[0])
         run_command("PING DNS2", 10, SU_PATH, "root", "ping", "-c", "3", "-i", ".5", network, NULL);
+#ifdef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 modifiy
+    }
+#endif /* VENDOR_EDIT */
 #ifdef FWDUMP_bcm4329
     run_command("DUMP WIFI STATUS", 20,
             SU_PATH, "root", "dhdutil", "-i", "wlan0", "dump", NULL);
@@ -204,6 +312,9 @@ static void dumpstate() {
             SU_PATH, "root", "wlutil", "counters", NULL);
 #endif
 
+#ifndef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 modifiy
+    // android code
     print_properties();
 
     run_command("VOLD DUMP", 10, "vdc", "dump", NULL);
@@ -260,7 +371,94 @@ static void dumpstate() {
                     SU_PATH, "root", "vril-dump", NULL);
         }
     }
+#else
+    switch (type) {
+        case ASSERT_TYPE: {
+            run_command("FILESYSTEMS & FREE SPACE", 10, "su", "root", "df", NULL);
+        }
+        break;
+        case FEEDBACK_TYPE: {
+            print_properties();
+
+            run_command("VOLD DUMP", 10, "vdc", "dump", NULL);
+            
+            dump_file("PACKAGE SETTINGS", "/data/system/packages.xml");
+            dump_file("PACKAGE UID ERRORS", "/data/system/uiderrors.txt");
+            #ifdef BOARD_HAS_DUMPSTATE
+                printf("========================================================\n");
+                printf("== Board\n");
+                printf("========================================================\n");
+
+                dumpstate_board();
+                printf("\n");
+            #endif
+        }
+        break;
+        default: {
+            print_properties();
+
+            run_command("VOLD DUMP", 10, "vdc", "dump", NULL);
+            run_command("SECURE CONTAINERS", 10, "vdc", "asec", "list", NULL);
+
+            run_command("FILESYSTEMS & FREE SPACE", 10, SU_PATH, "root", "df", NULL);
+
+            run_command("PACKAGE SETTINGS", 20, SU_PATH, "root", "cat", "/data/system/packages.xml", NULL);
+            dump_file("PACKAGE UID ERRORS", "/data/system/uiderrors.txt");
+
+            run_command("LAST RADIO LOG", 10, "parse_radio_log", "/proc/last_radio_log", NULL);
+
+            printf("------ BACKLIGHTS ------\n");
+            printf("LCD brightness=");
+            dump_file(NULL, "/sys/class/leds/lcd-backlight/brightness");
+            printf("Button brightness=");
+            dump_file(NULL, "/sys/class/leds/button-backlight/brightness");
+            printf("Keyboard brightness=");
+            dump_file(NULL, "/sys/class/leds/keyboard-backlight/brightness");
+            printf("ALS mode=");
+            dump_file(NULL, "/sys/class/leds/lcd-backlight/als");
+            printf("LCD driver registers:\n");
+            dump_file(NULL, "/sys/class/leds/lcd-backlight/registers");
+            printf("\n");
+
+            /* Binder state is expensive to look at as it uses a lot of memory. */
+            dump_file("BINDER FAILED TRANSACTION LOG", "/sys/kernel/debug/binder/failed_transaction_log");
+            dump_file("BINDER TRANSACTION LOG", "/sys/kernel/debug/binder/transaction_log");
+            dump_file("BINDER TRANSACTIONS", "/sys/kernel/debug/binder/transactions");
+            dump_file("BINDER STATS", "/sys/kernel/debug/binder/stats");
+            dump_file("BINDER STATE", "/sys/kernel/debug/binder/state");
+			#ifdef BOARD_HAS_DUMPSTATE
+                printf("========================================================\n");
+                printf("== Board\n");
+                printf("========================================================\n");
+
+                dumpstate_board();
+                printf("\n");
+            #endif
+
+            /* Migrate the ril_dumpstate to a dumpstate_board()? */
+            char ril_dumpstate_timeout[PROPERTY_VALUE_MAX] = {0};
+            property_get("ril.dumpstate.timeout", ril_dumpstate_timeout, "30");
+            if (strnlen(ril_dumpstate_timeout, PROPERTY_VALUE_MAX - 1) > 0) {
+                if (0 == strncmp(build_type, "user", PROPERTY_VALUE_MAX - 1)) {
+                    // su does not exist on user builds, so try running without it.
+                    // This way any implementations of vril-dump that do not require
+                    // root can run on user builds.
+                    run_command("DUMP VENDOR RIL LOGS", atoi(ril_dumpstate_timeout),
+                            "vril-dump", NULL);
+                } else {
+                    run_command("DUMP VENDOR RIL LOGS", atoi(ril_dumpstate_timeout),
+                            SU_PATH, "root", "vril-dump", NULL);
+                }
+            }
+        }
+        break;
+    }
+#endif /* VENDOR_EDIT */
 
+#ifdef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 modifiy
+    if (type != FEEDBACK_TYPE) {
+#endif /* VENDOR_EDIT */
     printf("========================================================\n");
     printf("== Android Framework Services\n");
     printf("========================================================\n");
@@ -269,6 +467,10 @@ static void dumpstate() {
        to increase its timeout.  we really need to do the timeouts in
        dumpsys itself... */
     run_command("DUMPSYS", 60, "dumpsys", NULL);
+#ifdef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 modifiy
+    }
+#endif /* VENDOR_EDIT */
 
     printf("========================================================\n");
     printf("== Running Application Activities\n");
@@ -281,6 +483,72 @@ static void dumpstate() {
     printf("========================================================\n");
 
     run_command("APP SERVICES", 30, "dumpsys", "activity", "service", "all", NULL);
+#ifdef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 modifiy
+    if (type == FEEDBACK_TYPE) {
+        printf("========================================================\n");
+        printf("== Running usb Services\n");
+        printf("========================================================\n");
+    
+        run_command("USB SERVICES", 30, "dumpsys", "usb", NULL);
+    
+        printf("========================================================\n");
+        printf("== Running mount Services\n");
+        printf("========================================================\n");
+    
+        run_command("MOUNT SERVICES", 30, "dumpsys", "mount", NULL);
+    
+        printf("========================================================\n");
+        printf("== Running throttle Services\n");
+        printf("========================================================\n");
+    
+        run_command("THROTTLE SERVICES", 30, "dumpsys", "throttle", NULL);
+    
+        printf("========================================================\n");
+        printf("== Running connectivity Services\n");
+        printf("========================================================\n");
+    
+        run_command("CONNECTIVITY SERVICES", 30, "dumpsys", "connectivity", NULL);
+        
+        printf("========================================================\n");
+        printf("== Running wifi Services\n");
+        printf("========================================================\n");
+    
+        run_command("WIFI SERVICES", 30, "dumpsys", "wifi", NULL);
+    
+    
+        printf("========================================================\n");
+        printf("== Running statusbar Services\n");
+        printf("========================================================\n");
+    
+        run_command("SATUSBAR SERVICES", 30, "dumpsys", "statusbar", NULL);
+    
+    
+        printf("========================================================\n");
+        printf("== Running window Services\n");
+        printf("========================================================\n");
+    
+        run_command("WINDOW SERVICES", 30, "dumpsys", "window", NULL);
+    
+        printf("========================================================\n");
+        printf("== Running alarm Services\n");
+        printf("========================================================\n");
+    
+        run_command("ALARM SERVICES", 30, "dumpsys", "alarm", NULL);
+        
+        printf("========================================================\n");
+        printf("== Running power Services\n");
+        printf("========================================================\n");
+    
+        run_command("POWER SERVICES", 30, "dumpsys", "power", NULL);
+    
+        printf("========================================================\n");
+        printf("== Running SurfaceFlinger Services\n");
+        printf("========================================================\n");
+    
+        run_command("SURFACEFLINGER SERVICES", 30, "dumpsys", "SurfaceFlinger", NULL);
+    }
+#endif /* VENDOR_EDIT */
 
     printf("========================================================\n");
     printf("== Running Application Providers\n");
@@ -295,7 +563,10 @@ static void dumpstate() {
 }
 
 static void usage() {
-    fprintf(stderr, "usage: dumpstate [-b soundfile] [-e soundfile] [-o file [-d] [-p] [-z]] [-s] [-q]\n"
+#ifndef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 modify
+    // android code
+    fprintf(stderr, "usage: dumpstate [-b soundfile] [-e soundfile] [-o file [-d] [-p] [-z]] [-s]\n"
             "  -o: write to file (instead of stdout)\n"
             "  -d: append date to filename (requires -o)\n"
             "  -z: gzip output (requires -o)\n"
@@ -303,8 +574,19 @@ static void usage() {
             "  -s: write output to control socket (for init)\n"
             "  -b: play sound file instead of vibrate, at beginning of job\n"
             "  -e: play sound file instead of vibrate, at end of job\n"
-            "  -q: disable vibrate\n"
 		);
+#else
+    fprintf(stderr, "usage: dumpstate [-b soundfile] [-e soundfile] [-o file [-d] [-p] [-z]] [-s] [-t type]\n"
+            "  -o: write to file (instead of stdout)\n"
+            "  -d: append date to filename (requires -o)\n"
+            "  -z: gzip output (requires -o)\n"
+            "  -p: capture screenshot to filename.png (requires -o)\n"
+            "  -s: write output to control socket (for init)\n"
+            "  -b: play sound file instead of vibrate, at beginning of job\n"
+            "  -e: play sound file instead of vibrate, at end of job\n"
+            "  -t: type given to choose what & how to dump\n"
+        );
+#endif /* VENDOR_EDIT */
 }
 
 int main(int argc, char *argv[]) {
@@ -316,7 +598,10 @@ int main(int argc, char *argv[]) {
     char* end_sound = 0;
     int use_socket = 0;
     int do_fb = 0;
-
+#ifdef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 add
+    int dump_type = NORMAL_TYPE;
+#endif /* VENDOR_EDIT */
     if (getuid() != 0) {
         // Old versions of the adb client would call the
         // dumpstate command directly. Newer clients
@@ -341,7 +626,13 @@ int main(int argc, char *argv[]) {
     dump_traces_path = dump_traces();
 
     int c;
-    while ((c = getopt(argc, argv, "b:de:ho:svqzp")) != -1) {
+#ifndef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 modifiy for providing type
+    // android code
+    while ((c = getopt(argc, argv, "b:de:ho:svzp")) != -1) {
+#else
+    while ((c = getopt(argc, argv, "b:de:ho:svzpt:")) != -1) {
+#endif /* VENDOR_EDIT */
         switch (c) {
             case 'b': begin_sound = optarg;  break;
             case 'd': do_add_date = 1;       break;
@@ -352,6 +643,10 @@ int main(int argc, char *argv[]) {
             case 'q': do_vibrate = 0;        break;
             case 'z': do_compress = 6;       break;
             case 'p': do_fb = 1;             break;
+#ifdef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 add
+            case 't': dump_type = parse_type(optarg, strlen(optarg));         break;
+#endif /* VENDOR_EDIT */
             case '?': printf("\n");
             case 'h':
                 usage();
@@ -414,7 +709,13 @@ int main(int argc, char *argv[]) {
     char path[PATH_MAX], tmp_path[PATH_MAX];
     pid_t gzip_pid = -1;
 
+#ifndef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 modifiy
+    // android code
     if (use_socket) {
+#else
+    if (use_socket || (dump_type == FEEDBACK_TYPE)) {
+#endif /* VENDOR_EDIT */
         redirect_to_socket(stdout, "dumpstate");
     } else if (use_outfile) {
         strlcpy(path, use_outfile, sizeof(path));
@@ -442,7 +743,14 @@ int main(int argc, char *argv[]) {
         fflush(vibrator);
     }
 
+#ifndef VENDOR_EDIT
+//licx@OnLineRD.framework, 2012-08-13 modifiy
+    // android code
     dumpstate();
+#else
+    dumpstate(dump_type);
+#endif /* VENDOR_EDIT */
+
 
     if (end_sound) {
         play_sound(end_sound);
diff --git a/frameworks/native/cmds/surfaceflinger/main_surfaceflinger.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/cmds/surfaceflinger/main_surfaceflinger.cpp
index 28e58e4..649d2fd 100644
--- a/frameworks/native/cmds/surfaceflinger/main_surfaceflinger.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/cmds/surfaceflinger/main_surfaceflinger.cpp
@@ -17,9 +17,51 @@
 #include <binder/BinderService.h>
 #include <SurfaceFlinger.h>
 
+// [MTK] {{{
+#include <private/android_filesystem_config.h>
+#include <linux/rtpm_prio.h>
+#include <sys/prctl.h>
+#include <cutils/xlog.h>
+// [MTK] }}}
+
 using namespace android;
 
 int main(int argc, char** argv) {
+    // [MTK] {{{
+    if (AID_ROOT == getuid()) {
+        XLOGI("[%s] set surfaceflinger is in root user, adjust caps for its thread", __func__);
+        if (-1 == prctl(PR_SET_KEEPCAPS, 1, 0, 0)) {
+            XLOGW("    prctl failed: %s", strerror(errno));
+        } else {
+            __user_cap_header_struct hdr;
+            __user_cap_data_struct data;
+
+            hdr.version = _LINUX_CAPABILITY_VERSION;    // set caps
+            hdr.pid = 0;
+            data.effective = ((1 << CAP_SYS_NICE) | (1 << CAP_SETUID) | (1 << CAP_SETGID));
+            data.permitted = ((1 << CAP_SYS_NICE) | (1 << CAP_SETUID) | (1 << CAP_SETGID));
+            data.inheritable = 0xffffffff;
+            if (-1 == capset(&hdr, &data)) {
+                XLOGW("    cap setting failed, %s", strerror(errno));
+            }
+
+            setgid(AID_SYSTEM);
+            setuid(AID_SYSTEM);         // change user to system
+
+            hdr.version = _LINUX_CAPABILITY_VERSION;    // set caps again
+            hdr.pid = 0;
+            data.effective = (1 << CAP_SYS_NICE);
+	        data.permitted = (1 << CAP_SYS_NICE);
+            data.inheritable = 0xffffffff;
+            if (-1 == capset(&hdr, &data)) {
+                XLOGW("    cap re-setting failed, %s", strerror(errno));
+            }
+        }
+    } else {
+        XLOGI("[%s] surfaceflinger is not in root user", __func__);
+    }
+    // [MTK] }}}
+
     SurfaceFlinger::publishAndJoinThreadPool(true);
     // When SF is launched in its own process, limit the number of
     // binder threads to 4.
diff --git a/gb/12055-master/driveronly_mp_rom/frameworks/native/include/binder/CheckPermission.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/binder/CheckPermission.h
new file mode 100755
index 0000000..6209281
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/binder/CheckPermission.h
@@ -0,0 +1,27 @@
+/************************************************************************************
+** File: - CheckPermission.h
+** VENDOR_EDIT
+** Copyright (C), 2008-2012, OPPO Mobile Comm Corp., Ltd
+** 
+** Description: permission check, add for permission intercept.
+** 
+** Version: 1.0
+** Date created: 04/25/2013
+** Author: Wanglan@Plf.Framework
+** Add for: permission intercept
+** --------------------------- Revision History: --------------------------------
+** 	<author>	                    <data>					<desc>
+** 	Wanglan@Plf.Framework  	04/25/2013	     			 Init
+************************************************************************************/
+
+#ifndef _Included_CheckPermission_H
+#define _Included_CheckPermission_H
+
+namespace android {
+	int CheckPermission(uint32_t code, const Parcel& data, int uid, int pid);
+	int parseAuthority(const char16_t* mString, ssize_t length, ssize_t index);
+	bool get_taskname(int pid);	
+	char *basename(const char *path);
+}
+#endif
+
diff --git a/frameworks/native/include/gui/BufferQueue.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/BufferQueue.h
index 9e265ba..e6ff67e 100644
--- a/frameworks/native/include/gui/BufferQueue.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/BufferQueue.h
@@ -30,6 +30,11 @@
 #include <utils/Vector.h>
 #include <utils/threads.h>
 
+// [MTK] {{{
+#include <gui/FpsCounter.h>
+#define LOCK_FOR_SW (GRALLOC_USAGE_SW_READ_RARELY | GRALLOC_USAGE_SW_WRITE_RARELY | GRALLOC_USAGE_HW_TEXTURE)
+// [MTK] }}}
+
 namespace android {
 // ----------------------------------------------------------------------------
 
@@ -537,6 +542,36 @@ private:
 
     // mTransformHint is used to optimize for screen rotations
     uint32_t mTransformHint;
+
+    // [MTK] {{{
+private:
+    // track for producer buffer return
+    FpsCounter mQueueFps;
+
+    // track for consumer buffer return
+    FpsCounter mReleaseFps;
+
+    // if debug line enabled
+    bool mLine;
+
+    // debug line count
+    uint32_t mLineCnt;
+
+public:
+    // for real type check
+    enum { TYPE_BufferQueue = 0, TYPE_SurfaceTextureLayer };
+    virtual int32_t getType() const { return TYPE_BufferQueue; }
+
+    // get connected api type for hwc usage
+    int32_t getConnectedApi() const { return mConnectedApi; }
+
+    // get name for more info
+    String8 getConsumerName() const { return mConsumerName; }
+
+    // add debug line to given GraphicBuffer
+    // cnt will auto mod to 32
+    static status_t DrawDebugLineToGraphicBuffer(sp<GraphicBuffer> gb, uint32_t cnt, uint8_t val = 0xff);
+    // [MTK] }}}
 };
 
 // ----------------------------------------------------------------------------
diff --git a/frameworks/native/include/gui/ConsumerBase.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/ConsumerBase.h
index ee5cb29..ff099a2 100644
--- a/frameworks/native/include/gui/ConsumerBase.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/ConsumerBase.h
@@ -212,6 +212,11 @@ protected:
     //
     // This mutex is intended to be locked by derived classes.
     mutable Mutex mMutex;
+
+    // [MTK] {{{
+public:
+    virtual status_t forceAuxConversionLocked() { return NO_ERROR; }
+    // [MTK] }}}
 };
 
 // ----------------------------------------------------------------------------
diff --git a/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/FpsCounter.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/FpsCounter.h
new file mode 100644
index 0000000..29bf03f
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/FpsCounter.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_GUI_FPSCOUNTER_H
+#define ANDROID_GUI_FPSCOUNTER_H
+
+namespace android {
+// ----------------------------------------------------------------------------
+
+// tool class for FPS statistics, provide AVG, MAX, MIN message
+// * AVG for FPS in a given duration
+// * MAX and MIN for stability reference
+class FpsCounter {
+private:
+    // for AVG
+    float       mFps;
+
+    // for MAX, MIN
+    nsecs_t     mMaxDuration;
+    nsecs_t     mMinDuration;
+    nsecs_t     mMaxDurationCounting;
+    nsecs_t     mMinDurationCounting;
+
+    // per interval result
+    uint32_t    mFrames;
+    nsecs_t     mLastLogTime;
+    nsecs_t     mLastLogDuration;
+
+    // per update result
+    nsecs_t     mLastTime;
+    nsecs_t     mLastDuration;
+
+public:
+    // the given counting interval, read system property by default
+    nsecs_t     mCountInterval;
+
+    FpsCounter() { reset(); }
+    ~FpsCounter() {}
+
+    // main control
+    bool reset();
+    bool update(nsecs_t time);
+    bool update();
+
+    // get result
+    inline float   getFps()             { return mFps;             }
+    inline nsecs_t getMaxDuration()     { return mMaxDuration;     }
+    inline nsecs_t getMinDuration()     { return mMinDuration;     }
+    inline nsecs_t getLastLogDuration() { return mLastLogDuration; }
+    inline nsecs_t getLastDuration()    { return mLastDuration;    }
+};
+
+// ----------------------------------------------------------------------------
+}; // namespace android
+
+#endif // ANDROID_GUI_FPSCOUNTER_H
diff --git a/frameworks/native/include/gui/Surface.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/Surface.h
index 2288fe7..a3e737c 100644
--- a/frameworks/native/include/gui/Surface.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/Surface.h
@@ -62,7 +62,8 @@ public:
     
     status_t    setLayerStack(int32_t layerStack);
     status_t    setLayer(int32_t layer);
-    status_t    setPosition(int32_t x, int32_t y);
+    //status_t    setPosition(int32_t x, int32_t y);
+    status_t    setPosition(float x, float y);
     status_t    setSize(uint32_t w, uint32_t h);
     status_t    hide();
     status_t    show();
@@ -102,6 +103,12 @@ private:
     mutable Mutex               mLock;
     
     mutable sp<Surface>         mSurfaceData;
+
+    // [MTK] {{{
+public:
+    // For setting extra surface flags
+    status_t    setFlagsEx(uint32_t flags, uint32_t mask);
+    // [MTK] }}}
 };
     
 // ---------------------------------------------------------------------------
diff --git a/frameworks/native/include/gui/SurfaceComposerClient.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/SurfaceComposerClient.h
index ae5d69a..0769265 100644
--- a/frameworks/native/include/gui/SurfaceComposerClient.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/SurfaceComposerClient.h
@@ -149,6 +149,12 @@ private:
                 status_t                    mStatus;
                 sp<ISurfaceComposerClient>  mClient;
                 Composer&                   mComposer;
+
+    // [MTK] {{{
+public:
+    // For setting extra surface flags
+    status_t    setFlagsEx(SurfaceID id, uint32_t flags, uint32_t mask);
+    // [MTK] }}}
 };
 
 // ---------------------------------------------------------------------------
diff --git a/frameworks/native/include/gui/SurfaceTexture.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/SurfaceTexture.h
index 7c519ae..8a39fd4 100644
--- a/frameworks/native/include/gui/SurfaceTexture.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/SurfaceTexture.h
@@ -394,6 +394,81 @@ private:
     // It is set to false by detachFromContext, and then set to true again by
     // attachToContext.
     bool mAttached;
+
+    // [MTK] {{{
+
+private:
+    // this condition is set to
+    // 1) TRUE when SurfaceTexture::updateTexImage() or
+    //    Layer::onDraw() is called
+    // 2) FALSE after buffer format conversion or
+    //    if the current texture is INVALID_BUFFER_SLOT
+    bool mAuxSlotConvert;
+
+    // this condition is set to
+    // 1) TRUE after the texture is converted to the appropriate color format
+    // 2) FALSE after the converted textured is already bound to the aux buffer slot
+    bool mAuxSlotDirty;
+
+    // aux buffer slot for format convert
+    // for video or camera data input not match texture format required by G3D
+    struct AuxSlot {
+        AuxSlot()
+        : mMva(0) {
+        }
+        // graphic buffer
+        Slot    slot;
+        // EGL information
+        EGLSlot eglSlot;
+        // m4u usage
+        void *mMva;
+    } mAuxSlot[2];
+    AuxSlot *mBackAuxSlot;
+    AuxSlot *mFrontAuxSlot;
+
+    // for drawing debug line
+    bool mLine;
+
+    // debug line count
+    uint32_t mLineCnt;
+
+    // clear enternal aux buffer data
+    status_t freeAuxSlotLocked(AuxSlot &src);
+
+    // dump internal aux buffer if exists
+    // currently, all aux buffer is in RGBA format
+    status_t dumpAux() const;
+
+public:
+    // get connected api type, for buffer data conversion condition (aux and hwc)
+    int getConnectedApi() const { return (mBufferQueue != NULL) ? mBufferQueue->getConnectedApi() : -1; }
+
+    // for check if conversion still required
+    bool isAuxSlotNeedConvert() const { return mAuxSlotConvert; }
+
+    // check if need to bind new converted buffer data
+    bool isAuxSlotDirty() const { return mAuxSlotDirty; }
+
+    // bind texture to the aux buffer slot
+    status_t bindToAuxSlotLocked();
+
+    // convert current using buffer slot to aux slot
+    status_t convertToAuxSlotLocked(bool isForce);
+
+    // (for where not locked yet, add lock and call real function)
+    status_t bindToAuxSlot();
+    status_t convertToAuxSlot(bool isForce);
+
+    // force convert buffer before released
+    status_t forceAuxConversionLocked();
+
+    // check if color pixel format is supported by HW
+    status_t checkPixelFormatSupported() const;
+
+    // need to use destructor for its own buffer release
+    ~SurfaceTexture() { abandon(); };
+
+    // [MTK] }}}
 };
 
 // ----------------------------------------------------------------------------
diff --git a/frameworks/native/include/gui/SurfaceTextureClient.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/SurfaceTextureClient.h
index 50fd1ba..13eeb12 100644
--- a/frameworks/native/include/gui/SurfaceTextureClient.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/gui/SurfaceTextureClient.h
@@ -216,6 +216,15 @@ private:
 
     // must be accessed from lock/unlock thread only
     Region mDirtyRegion;
+
+    // [MTK] {{{
+private:
+    // to track current client connection type
+    int mConnectedApi;
+
+    // to track queueBuffer() FPS
+    FpsCounter mQueueFps;
+    // [MTK] }}}
 };
 
 }; // namespace android
diff --git a/frameworks/native/include/private/gui/LayerState.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/private/gui/LayerState.h
index a7eb48c..54b9c92 100644
--- a/frameworks/native/include/private/gui/LayerState.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/private/gui/LayerState.h
@@ -50,6 +50,42 @@ struct layer_state_t {
         eCropChanged                = 0x00000100,
     };
 
+    // [MTK] {{{
+    // setFlagsEx for extra layer control
+    enum {
+        eExInvalid           = 0x80000000,   // as need to update
+
+        // BYTE#3 LOW4 for PQ control
+        eExPQ_Mask           = 0x01000000,   // for PQ on/off
+        eExPQ_On             = 0x01000000,
+
+        eExPQ_Reserved_Mask  = 0x0E000000,   // reserved
+        eExPQ_Reserved_bit0  = 0x02000000,
+        eExPQ_Reserved_bit1  = 0x04000000,
+        eExPQ_Reserved_bit2  = 0x08000000,
+
+        // BYTE#2 for S3D layer control
+        eExS3D_Mask          = 0x00FF0000,
+
+        eExS3D_Layout_Mask   = 0x00F00000,   // for content layout
+        eExS3D_Unknown       = 0x00100000,
+        eExS3D_SideBySide    = 0x00200000,
+        eExS3D_TopAndBottom  = 0x00400000,
+        eExS3D_LRSwapped     = 0x00800000,
+
+        eExS3D_Display_Mask  = 0x00080000,   // for display mode
+        eExS3D_2D            = 0x00000000,
+        eExS3D_3D            = 0x00080000,
+
+        eExS3D_Reserved_Mask = 0x00070000,   // reserved
+        eExS3D_Reserved_bit0 = 0x00010000,
+        eExS3D_Reserved_bit1 = 0x00020000,
+        eExS3D_Reserved_bit2 = 0x00040000,
+
+        eExInitValue         = eExS3D_Unknown, // for layer init
+    };
+    // [MTK] }}}
+
     layer_state_t()
         :   surface(0), what(0),
             x(0), y(0), z(0), w(0), h(0), layerStack(0),
@@ -59,6 +95,12 @@ struct layer_state_t {
         matrix.dsdx = matrix.dtdy = 1.0f;
         matrix.dsdy = matrix.dtdx = 0.0f;
         crop.makeInvalid();
+
+        // [MTK] {{{
+        // For setting extra surface flags
+        flagsEx = 0x00000000;
+        maskEx = 0x00000000;
+        // [MTK] }}}
     }
 
     status_t    write(Parcel& output) const;
@@ -84,6 +126,13 @@ struct layer_state_t {
             uint8_t         reserved;
             matrix22_t      matrix;
             Rect            crop;
+
+            // [MTK] {{{
+            // For setting extra surface flags
+            uint32_t        flagsEx;
+            uint32_t        maskEx;
+            // [MTK] }}}
+
             // non POD must be last. see write/read
             Region          transparentRegion;
 };
diff --git a/frameworks/native/include/ui/GraphicBuffer.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/ui/GraphicBuffer.h
index f318cd8..7a5a410 100644
--- a/frameworks/native/include/ui/GraphicBuffer.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/ui/GraphicBuffer.h
@@ -151,6 +151,21 @@ private:
     // If we're wrapping another buffer then this reference will make sure it
     // doesn't get freed.
     sp<ANativeWindowBuffer> mWrappedBuffer;
+
+    // [MTK] {{{
+
+public:
+    status_t getIonFd(int *idx, int *num);
+    unsigned int getMva() { return mva; }
+    void setMva(unsigned int _mva);
+
+private:
+    status_t mapBuffer();
+    status_t unmapBuffer();
+    unsigned int mva;
+    unsigned int msize;
+
+    // [MTK] }}}
 };
 
 }; // namespace android
diff --git a/frameworks/native/include/ui/GraphicBufferAllocator.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/ui/GraphicBufferAllocator.h
index dffa788..cb48b37 100644
--- a/frameworks/native/include/ui/GraphicBufferAllocator.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/ui/GraphicBufferAllocator.h
@@ -31,6 +31,9 @@
 
 #include <hardware/gralloc.h>
 
+// [MTK] {{{
+#include "mmumapper.h"
+// [MTK] }}}
 
 namespace android {
 // ---------------------------------------------------------------------------
@@ -78,6 +81,9 @@ private:
         PixelFormat format;
         uint32_t usage;
         size_t size;
+        // [MTK] {{{
+        uint32_t pid;
+        // [MTK] }}}
     };
     
     static Mutex sLock;
@@ -88,6 +94,17 @@ private:
     ~GraphicBufferAllocator();
     
     alloc_device_t  *mAllocDev;
+
+    // [MTK] {{{
+    mmu_mapper_device_t *mMapperDev;
+    void initMapper();
+    void uninitMapper();
+
+public:
+    status_t map(unsigned int addr, unsigned int width, unsigned int height, unsigned int size, unsigned int format, unsigned int *mva);
+    status_t unmap(unsigned int addr, unsigned int size, unsigned int format, unsigned int mva);
+    status_t query(unsigned int addr, unsigned int size, unsigned int format, unsigned int *mva);
+    // [MTK] }}}
 };
 
 // ---------------------------------------------------------------------------
diff --git a/frameworks/native/include/ui/GraphicBufferMapper.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/ui/GraphicBufferMapper.h
index 697a02a..db3d010 100644
--- a/frameworks/native/include/ui/GraphicBufferMapper.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/ui/GraphicBufferMapper.h
@@ -54,6 +54,17 @@ private:
     friend class Singleton<GraphicBufferMapper>;
     GraphicBufferMapper();
     gralloc_module_t const *mAllocMod;
+
+    // [MTK] {{{
+
+public:
+    status_t getIonFd(buffer_handle_t handle, int *idx, int *num);
+
+private:
+    ~GraphicBufferMapper();
+    extra_device_t *mExtraDev;
+
+    // [MTK] }}}
 };
 
 // ---------------------------------------------------------------------------
diff --git a/frameworks/native/include/utils/Errors.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/utils/Errors.h
index 0b75b19..3d7f8b3 100644
--- a/frameworks/native/include/utils/Errors.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/include/utils/Errors.h
@@ -73,6 +73,9 @@ enum {
     UNKNOWN_TRANSACTION = 0x80000006,
 #endif    
     FDS_NOT_ALLOWED     = 0x80000007,
+#ifndef ANDROID_DEFAULT_CODE
+    NO_AUDIO_EFFECT =0x800000FF,
+#endif
 };
 
 // Restore define; enumeration is in "android" namespace, so the value defined
diff --git a/frameworks/native/libs/binder/Android.mk b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/Android.mk
index d449298..8ea67f1 100644
--- a/frameworks/native/libs/binder/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/Android.mk
@@ -27,11 +27,24 @@ sources := \
     Parcel.cpp \
     PermissionCache.cpp \
     ProcessState.cpp \
-    Static.cpp
+    Static.cpp \
+    CheckPermission.cpp
 
 LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
+ifeq ($(TARGET_BUILD_VARIANT),eng)
+ifeq ($(filter banyan_addon banyan_addon_x86,$(TARGET_PRODUCT)),)
+ifeq ($(MTK_INTERNAL),yes)
+# mtk80143: enable FP and ARM build for debug15 memory debugging
+LOCAL_CFLAGS += \
+		-fno-omit-frame-pointer \
+		-mapcs \
+		-D_MTK_ENG_
+LOCAL_ARM_MODE := arm
+endif
+endif
+endif
 LOCAL_LDLIBS += -lpthread
 LOCAL_MODULE := libbinder
 LOCAL_SHARED_LIBRARIES := liblog libcutils libutils
@@ -39,6 +52,17 @@ LOCAL_SRC_FILES := $(sources)
 include $(BUILD_SHARED_LIBRARY)
 
 include $(CLEAR_VARS)
+ifeq ($(TARGET_BUILD_VARIANT),eng)
+ifeq ($(filter banyan_addon banyan_addon_x86,$(TARGET_PRODUCT)),)
+ifeq ($(MTK_INTERNAL),yes)
+# mtk80143: enable FP and ARM build for debug15 memory debugging
+LOCAL_CFLAGS += \
+		-fno-omit-frame-pointer \
+		-mapcs
+LOCAL_ARM_MODE := arm
+endif
+endif
+endif
 LOCAL_LDLIBS += -lpthread
 LOCAL_MODULE := libbinder
 LOCAL_SRC_FILES := $(sources)
diff --git a/frameworks/native/libs/binder/BpBinder.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/BpBinder.cpp
index 47a62db..2ad5cad 100644
--- a/frameworks/native/libs/binder/BpBinder.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/BpBinder.cpp
@@ -24,6 +24,8 @@
 
 #include <stdio.h>
 
+#include <binder/CheckPermission.h>
+
 //#undef ALOGV
 //#define ALOGV(...) fprintf(stderr, __VA_ARGS__)
 
@@ -85,6 +87,15 @@ void BpBinder::ObjectManager::kill()
 }
 
 // ---------------------------------------------------------------------------
+//#ifdef VENDOR_EDIT
+//OppoHook
+//property=android.annotation.OppoHook.OppoRomType.OPPO
+//WangLan@Plf.Framework, modify for permission intercept
+static bool mInit = false;
+static bool mCTS = false;
+static int32_t mNum = 0;
+//#endif /* VENDOR_EDIT */
+
 
 BpBinder::BpBinder(int32_t handle)
     : mHandle(handle)
@@ -160,10 +171,30 @@ status_t BpBinder::transact(
     uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
 {
     // Once a binder has died, it will never come back to life.
+	//#ifdef VENDOR_EDIT
+	//OppoHook
+	//property=android.annotation.OppoHook.OppoRomType.OPPO
+	//WangLan@Plf.Framework, modify for permission intercept
+	if (!mInit) {
+		mNum++;
+		mCTS = get_taskname(getpid());
+		if ((mCTS) || (mNum > 8)) {
+			mInit = true;
+		}
+	}
+	
+	if ((getuid() >= 10000) && !mCTS) {
+		if (PERMISSION_DENIED == CheckPermission(code, data, getpid(), getuid())) {
+			return OK;
+		}
+	}
+	//#endif /* VENDOR_EDIT */
+	
     if (mAlive) {
         status_t status = IPCThreadState::self()->transact(
             mHandle, code, data, reply, flags);
-        if (status == DEAD_OBJECT) mAlive = 0;
+        // give serviceManager more chances...
+        if (status == DEAD_OBJECT && mHandle != 0) mAlive = 0;
         return status;
     }
 
diff --git a/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/CheckPermission.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/CheckPermission.cpp
new file mode 100755
index 0000000..52a1276
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/CheckPermission.cpp
@@ -0,0 +1,338 @@
+/************************************************************************************
+** File: - CheckPermission.cpp
+** VENDOR_EDIT
+** Copyright (C), 2008-2012, OPPO Mobile Comm Corp., Ltd
+** 
+** Description: permission check, add for permission intercept.
+** 
+** Version: 1.0
+** Date created: 04/25/2013
+** Author: Wanglan@Plf.Framework
+** Add for: permission intercept
+** --------------------------- Revision History: --------------------------------
+** 	<author>	                    <data>					<desc>
+** 	Wanglan@Plf.Framework  	04/25/2013	     			 Init
+************************************************************************************/
+#define LOG_TAG "CheckPermission"
+#define MAX_BUF_SIZE 256
+ 
+#include <cutils/log.h>
+#include <binder/IServiceManager.h>
+#include <binder/Parcel.h>
+#include <utils/String8.h>
+#include <utils/String16.h>
+#include <binder/CheckPermission.h>
+
+namespace android {
+
+// ---------------------------------------------------------------------------
+
+static String16 _call("android.app.IActivityManager");
+static String16 _sendsms("com.android.internal.telephony.ISms");
+static String16 _data_network("android.net.IConnectivityManager");
+static String16 _wifi("android.net.wifi.IWifiManager");
+static String16 _bluetooth("android.bluetooth.IBluetooth");
+static String16 _contentprovider("android.content.IContentProvider");
+static String16 _location("android.location.ILocationManager");
+static String16 _telephony("com.android.internal.telephony.ITelephony");
+static String16 _camera("android.hardware.ICameraService");
+static String16 _audio_record("android.media.IMediaRecorder");
+static String16 _nfc("android.nfc.INfcAdapter");
+
+static String16 URI_CONTACT("com.android.contacts");
+static String16 URI_SMS("sms");
+static String16 URI_MMS("mms");
+static String16 URI_MMS_SMS("mms-sms");
+static String16 URI_CALLLOG("call_log");
+
+static String16 ACTION_CALL("android.intent.action.CALL");
+
+bool parseAuthorityCallLog(const char16_t* mString, ssize_t length, ssize_t index) {
+	if (length > index + 2
+			&& *(mString+index+1) == '/'
+			&& *(mString+index+2) == '/') {
+	    const char16_t* p = mString + index + 3;
+		String16 authority = String16(p, 8);
+	    return (URI_CALLLOG == authority);
+	}
+	return false;
+}
+
+bool parseAuthoritySMS(const char16_t* mString, ssize_t length, ssize_t index) {
+	if (length > index + 2
+			&& *(mString+index+1) == '/'
+			&& *(mString+index+2) == '/') {
+	    const char16_t* p = mString + index + 3;
+		String16 authority = String16(p, 3);
+	    if ((URI_SMS == authority) || (URI_MMS == authority)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+bool parseAuthorityContact(const char16_t* mString, ssize_t length, ssize_t index) {
+	if (length > index + 2
+			&& *(mString+index+1) == '/'
+			&& *(mString+index+2) == '/') {
+	    const char16_t* p = mString + index + 3;
+		String16 authority = String16(p, 20);
+	    return (URI_CONTACT == authority);
+	}
+	return false;
+}
+
+
+int CheckPermission(uint32_t code, const Parcel& data, int pid, int uid) {	
+
+	//getInterfaceDescriptor
+	data.setDataPosition(0);
+	data.readInt32();
+	const String16 InterfaceDescriptor(data.readString16());
+	
+	if (InterfaceDescriptor.size() != 0) {
+		if (InterfaceDescriptor == _call) {
+			if (code == 3) {
+				size_t len;
+				data.readStrongBinder();
+				const char16_t* intent = data.readString16Inplace(&len);
+				const String16 action(String16(intent, len));
+				if (action) {
+					if (action == ACTION_CALL) {
+						if (!checkPermission(String16("android.permission.CALL_PHONE"), pid, uid)) {
+							ALOGE("Permission Denial: "
+							"can't call out pid=%d, uid=%d", pid, uid);
+							return PERMISSION_DENIED;
+						}
+					}
+				}
+			}
+		}
+
+		if (InterfaceDescriptor == _telephony) {
+			//ITelephony call("10086"), endCall()
+			if ((code == 2) || (code == 5)) {
+				if (!checkPermission(String16("android.permission.CALL_PHONE"), pid, uid)) {
+					ALOGE("Permission Denial: "
+					"can't call out pid=%d, uid=%d", pid, uid);
+					return PERMISSION_DENIED;
+				}
+			}
+		}	
+
+		if (InterfaceDescriptor == _sendsms) {
+			//ISms sendText, sendData, sendMultipartText
+			if ((code == 4) || (code == 5) || (code == 6)) {
+				if (!checkPermission(String16("android.permission.SEND_SMS"), pid, uid)) {
+					ALOGE("Permission Denial: "
+					"can't send sms pid=%d, uid=%d", pid, uid);
+					return PERMISSION_DENIED;
+				}
+			}
+		}
+		
+		if (InterfaceDescriptor == _wifi) {
+			if (code == 13) {
+				if (!checkPermission(String16("android.permission.CHANGE_WIFI_STATE"), pid, uid)) {
+						ALOGE("Permission Denial: "
+						"can't change wifi state pid=%d, uid=%d", pid, uid);
+						return PERMISSION_DENIED;
+				}
+			}
+		}
+
+		if (InterfaceDescriptor == _bluetooth) {
+			ALOGE("_bluetooth code = %d", code);
+			if (code == 5) {
+				if (!checkPermission(String16("android.permission.BLUETOOTH_ADMIN"), pid, uid)) {
+					ALOGE("Permission Denial: "
+					"can't change bluetooth state pid=%d, uid=%d", pid, uid);
+					return PERMISSION_DENIED;
+				}
+			}
+		}
+		
+		if (InterfaceDescriptor == _contentprovider) {
+			//query, insert, delete, update
+			if (code == 1) {
+				size_t len;
+				int type = data.readInt32();
+
+				//scheme
+				const char16_t* string = data.readString16Inplace(&len);
+				const String16 scheme(String16(string, len));
+				if (scheme) {
+					if (type == 1)
+					{
+						ssize_t index = -1;
+						index = scheme.findFirst(':');
+						if (index != -1) {
+							if (parseAuthorityCallLog(string, scheme.size(), index)) {
+								if (!checkPermission(String16("android.permission.READ_CALL_LOG"), pid, uid)) {
+									ALOGE("Permission Denial: "
+									"can't read call log pid=%d, uid=%d", pid, uid);
+									return PERMISSION_DENIED;
+								}
+							}
+							if (parseAuthoritySMS(string, scheme.size(), index)) {
+								if (!checkPermission(String16("android.permission.READ_SMS"), pid, uid)) {
+									ALOGE("Permission Denial: "
+									"can't read sms pid=%d, uid=%d", pid, uid);
+									return PERMISSION_DENIED;
+								}
+							}
+							if (parseAuthorityContact(string, scheme.size(), index)) {
+								if (!checkPermission(String16("android.permission.READ_CONTACTS"), pid, uid)) {
+									ALOGE("Permission Denial: "
+									"can't read contacts pid=%d, uid=%d", pid, uid);
+									return PERMISSION_DENIED;
+								}
+							}
+						}							
+					}
+					if (type == 3) {
+						//authority
+						int representation = data.readInt32();
+						string = data.readString16Inplace(&len);
+						const String16 encoded(String16(string, len));
+						string = data.readString16Inplace(&len);
+						const String16 decoded(String16(string, len));
+						if (decoded) {
+							if (decoded == URI_CONTACT) {
+								if (!checkPermission(String16("android.permission.READ_CONTACTS"), pid, uid)) {
+									ALOGE("Permission Denial: "
+									"can't read contacts pid=%d, uid=%d", pid, uid);
+									return PERMISSION_DENIED;
+								}
+							}
+							if ((decoded == URI_SMS) || (decoded == URI_MMS) || (decoded == URI_MMS_SMS)) {
+								if (!checkPermission(String16("android.permission.READ_SMS"), pid, uid)) {
+									ALOGE("Permission Denial: "
+									"can't read sms pid=%d, uid=%d", pid, uid);
+									return PERMISSION_DENIED;
+								}
+							}
+							if (decoded == URI_CALLLOG) {
+								if (!checkPermission(String16("android.permission.READ_CALL_LOG"), pid, uid)) {
+									ALOGE("Permission Denial: "
+									"can't read contacts pid=%d, uid=%d", pid, uid);
+									return PERMISSION_DENIED;
+								}
+							}							
+						}
+					}
+				}
+			}
+		}
+	
+		if (InterfaceDescriptor == _location) {
+			if (code == 1) {
+				if (!checkPermission(String16("android.permission.ACCESS_FINE_LOCATION"), pid, uid)) {
+					ALOGE("Permission Denial: "
+					"can't access location pid=%d, uid=%d", pid, uid);
+					return PERMISSION_DENIED;
+				}
+			}
+		}
+
+		if (InterfaceDescriptor == _data_network) {
+			//setMobileDataEnabled
+			if (code == 20) {
+				if (!checkPermission(String16("android.permission.CHANGE_NETWORK_STATE"), pid, uid)) {
+					ALOGE("Permission Denial: "
+					"can't access location pid=%d, uid=%d", pid, uid);
+					return PERMISSION_DENIED;
+				}
+			}
+		}
+
+
+		if (InterfaceDescriptor == _data_network) {
+			//send mms, startUsingNetworkFeature
+			if (code == 15) {
+				ALOGE("_data_network code = %d", code);
+				if (!checkPermission(String16("android.permission.SEND_SMS"), pid, uid)) {
+					ALOGE("Permission Denial: "
+					"can't access location pid=%d, uid=%d", pid, uid);
+					return PERMISSION_DENIED;
+				}
+			}
+		}		
+
+		if (InterfaceDescriptor == _camera) {
+			if (code == 3) {
+				if (!checkPermission(String16("android.permission.CAMERA"), pid, uid)) {
+					ALOGE("Permission Denial: "
+					"can't use camera pid=%d, uid=%d", pid, uid);
+					return PERMISSION_DENIED;
+				}
+			}
+		}
+	
+		if (InterfaceDescriptor == _audio_record) {
+			if (code == 2) {
+				if (!checkPermission(String16("android.permission.RECORD_AUDIO"), pid, uid)) {
+					ALOGE("Permission Denial: "
+						"can't record pid=%d, uid=%d", pid, uid);
+					return PERMISSION_DENIED;
+				}
+			}
+		}
+		
+		if (InterfaceDescriptor == _nfc) {
+			if ((code == 4)) {
+				if (!checkPermission(String16("android.permission.NFC"), pid, uid)) {
+					ALOGE("Permission Denial: "
+						"can't record pid=%d, uid=%d", pid, uid);
+					return PERMISSION_DENIED;
+				}
+			}
+		}		
+
+	}
+	return OK;
+}
+
+bool get_taskname(int pid) {
+	char *base_pname = NULL;
+	FILE *fp;
+	char path[MAX_BUF_SIZE];
+	char cmdline[MAX_BUF_SIZE];
+
+	sprintf(path, "/proc/%d/cmdline", pid);
+	fp = fopen(path, "r");
+	if(fp == NULL) {
+		return false;
+	}
+	
+	memset(cmdline, 0, sizeof(cmdline));
+	if(fread(cmdline, MAX_BUF_SIZE - 1, 1, fp) < 0){
+	   fclose(fp);
+	   return false;
+	}
+	fclose(fp);
+	
+	base_pname = basename(cmdline);
+	if (strstr(base_pname, "com.android.cts.")) {
+		ALOGE("CTS test is running , %s! ", base_pname);
+		return true;
+	}
+    return false;
+}
+
+char *basename(const char *path) {
+	register const char *s;
+	register const char *p;
+	
+	p = s = path;
+	while (*s) {
+		if (*s++ == '/') {
+			p = s;
+		}
+	}
+	return (char *) p;
+}
+
+
+}
+
diff --git a/frameworks/native/libs/binder/IPCThreadState.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/IPCThreadState.cpp
index 6e83faa..1ed3586 100644
--- a/frameworks/native/libs/binder/IPCThreadState.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/IPCThreadState.cpp
@@ -305,7 +305,7 @@ restart:
         return new IPCThreadState;
     }
     
-    if (gShutdown) return NULL;
+    //if (gShutdown) return NULL;
     
     pthread_mutex_lock(&gTLSMutex);
     if (!gHaveTLS) {
@@ -335,12 +335,12 @@ void IPCThreadState::shutdown()
     
     if (gHaveTLS) {
         // XXX Need to wait for all thread pool threads to exit!
-        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(gTLS);
-        if (st) {
-            delete st;
-            pthread_setspecific(gTLS, NULL);
-        }
-        gHaveTLS = false;
+        //IPCThreadState* st = (IPCThreadState*)pthread_getspecific(gTLS);
+        //if (st) {
+        //    delete st;
+        //    pthread_setspecific(gTLS, NULL);
+        //}
+        //gHaveTLS = false;
     }
 }
 
@@ -1062,6 +1062,7 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
     case BR_DEAD_BINDER:
         {
             BpBinder *proxy = (BpBinder*)mIn.readInt32();
+	    ALOGD("[DN #5] BR_DEAD_BINDER cookie %p", proxy);
             proxy->sendObituary();
             mOut.writeInt32(BC_DEAD_BINDER_DONE);
             mOut.writeInt32((int32_t)proxy);
@@ -1070,6 +1071,7 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
     case BR_CLEAR_DEATH_NOTIFICATION_DONE:
         {
             BpBinder *proxy = (BpBinder*)mIn.readInt32();
+	    ALOGD("[DN #5] BR_CLEAR_DEATH_NOTIFICATION_DONE cookie %p", proxy);
             proxy->getWeakRefs()->decWeak(proxy);
         } break;
         
diff --git a/frameworks/native/libs/binder/IServiceManager.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/IServiceManager.cpp
index 1750640..caea727 100644
--- a/frameworks/native/libs/binder/IServiceManager.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/IServiceManager.cpp
@@ -155,11 +155,22 @@ public:
             bool allowIsolated)
     {
         Parcel data, reply;
+	unsigned n;
+        status_t err;
         data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());
         data.writeString16(name);
         data.writeStrongBinder(service);
         data.writeInt32(allowIsolated ? 1 : 0);
-        status_t err = remote()->transact(ADD_SERVICE_TRANSACTION, data, &reply);
+        for (n = 1; n <= 5; n++) {
+            err = remote()->transact(ADD_SERVICE_TRANSACTION, data, &reply);
+            if (err == -EPIPE) {
+                ALOGI("%s is waiting for serviceManager... (retry %d)\n",
+                    String8(name).string(), n);
+                sleep(1);
+            } else {
+                break;
+            }
+        }
         return err == NO_ERROR ? reply.readExceptionCode() : err;
     }
 
diff --git a/frameworks/native/libs/binder/Parcel.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/Parcel.cpp
index 4c15913..931a488 100644
--- a/frameworks/native/libs/binder/Parcel.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/Parcel.cpp
@@ -39,6 +39,10 @@
 #include <stdint.h>
 #include <sys/mman.h>
 
+#ifdef _MTK_ENG_
+extern void (*fdleak_record_backtrace)(int);
+#endif
+
 #ifndef INT32_MAX
 #define INT32_MAX ((int32_t)(2147483647))
 #endif
@@ -724,10 +728,12 @@ status_t Parcel::writeDupFileDescriptor(int fd)
 {
     int dupFd = dup(fd);
     if (dupFd < 0) {
+        ALOGE("writeDupFileDescriptor: error %d dup fd %d\n", errno, fd);
         return -errno;
     }
     status_t err = writeFileDescriptor(dupFd, true /*takeOwnership*/);
     if (err) {
+        ALOGE("writeDupFileDescriptor: error %d write fd %d\n", err, dupFd);
         close(dupFd);
     }
     return err;
@@ -1055,11 +1061,15 @@ int32_t Parcel::readExceptionCode() const
 {
   int32_t exception_code = readAligned<int32_t>();
   if (exception_code == EX_HAS_REPLY_HEADER) {
-    int32_t header_start = dataPosition();
+    // Google bug. We need to keep this position,
+    // since the remaining data includes "header" and "payload"
+    const int header_pos = dataPosition(); 
     int32_t header_size = readAligned<int32_t>();
     // Skip over fat responses headers.  Not used (or propagated) in
     // native code
-    setDataPosition(header_start + header_size);
+    // skip data including "header" (length = sizeof(int32_t)) and
+    // "payload" (length = header_size)
+    setDataPosition(header_pos + header_size);
     // And fat response headers are currently only used when there are no
     // exceptions, so return no error:
     return 0;
@@ -1176,7 +1186,14 @@ const flat_binder_object* Parcel::readObject(bool nullMetaData) const
             ALOGV("readObject Setting data pos of %p to %d\n", this, mDataPos);
             return obj;
         }
-        
+#ifdef _MTK_ENG_
+        if (BINDER_TYPE_FD == obj->type) {
+            if(fdleak_record_backtrace) {
+                ALOGV("record pid %d get FD:%d from driver\n", getpid(), obj->handle);
+                fdleak_record_backtrace(obj->handle); //record FD backtrace
+            }
+        }
+#endif
         // Ensure that this object is valid...
         size_t* const OBJS = mObjects;
         const size_t N = mObjectsSize;
@@ -1429,6 +1446,12 @@ status_t Parcel::continueWrite(size_t desired)
         if (objectsSize) {
             objects = (size_t*)malloc(objectsSize*sizeof(size_t));
             if (!objects) {
+                //#ifdef VENDOR_EDIT
+                //@OppoHook
+                //yaolang@Plt.Framework Transplant from Android 4.3
+                free(data);
+                //#endif /* VENDOR_EDIT */
+
                 mError = NO_MEMORY;
                 return NO_MEMORY;
             }
diff --git a/frameworks/native/libs/binder/ProcessState.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/ProcessState.cpp
index d95fd6f..81f5db3 100644
--- a/frameworks/native/libs/binder/ProcessState.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/binder/ProcessState.cpp
@@ -41,7 +41,7 @@
 #include <sys/mman.h>
 #include <sys/stat.h>
 
-#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))
+#define BINDER_VM_SIZE ((2*1024*1024) - (4096 *2))
 
 
 // ---------------------------------------------------------------------------
diff --git a/frameworks/native/libs/gui/Android.mk b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/Android.mk
index d970a33..0c4fde5 100644
--- a/frameworks/native/libs/gui/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/Android.mk
@@ -36,6 +36,49 @@ LOCAL_SHARED_LIBRARIES := \
 	libui \
 	libutils \
 
+# --- MediaTek -------------------------------------------------------------------------------------
+LOCAL_SRC_FILES += \
+	mediatek/Surface.cpp \
+	mediatek/BufferQueue.cpp \
+	mediatek/FpsCounter.cpp
+
+ifeq ($(MTK_EMULATOR_SUPPORT), yes)
+	LOCAL_CFLAGS += -DEMULATOR_SUPPORT
+	LOCAL_SRC_FILES += mediatek/SurfaceTexture_emulator.cpp
+else
+	LOCAL_CFLAGS := -DLOG_TAG=\"SurfaceTexture\"
+	LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES
+	LOCAL_SRC_FILES += mediatek/SurfaceTexture.cpp
+
+	ifeq ($(MTK_DP_FRAMEWORK), yes)
+        LOCAL_CFLAGS += -DUSE_DP
+		LOCAL_SHARED_LIBRARIES += libdpframework
+		LOCAL_SRC_FILES += mediatek/SurfaceTexture_dpHal.cpp
+		LOCAL_C_INCLUDES += $(TOP)/$(MTK_ROOT)/hardware/dpframework/inc
+	else
+		LOCAL_CFLAGS += -DUSE_MDP
+		LOCAL_SRC_FILES += mediatek/SurfaceTexture_mHal.cpp
+		LOCAL_C_INCLUDES += $(TOP)/$(MTK_ROOT)/external/mhal/inc
+		LOCAL_SHARED_LIBRARIES += libdl
+	endif # MTK_DP_FRAMEWORK
+endif # MTK_EMULATOR_SUPPORT
+
+ifeq ($(MTK_FENCE_SUPPORT), yes)
+	#LOCAL_CFLAGS += -DUSE_FENCE_SYNC
+endif
+
+ifeq ($(MTK_NATIVE_FENCE_SUPPORT), yes)
+	#LOCAL_CFLAGS += -DUSE_NATIVE_FENCE_SYNC
+endif
+
+ifeq ($(MTK_PQ_SUPPORT), yes)
+	LOCAL_CFLAGS += -DMTK_PQ_SUPPORT
+endif
+
+ifeq ($(MTK_75DISPLAY_ENHANCEMENT_SUPPORT), yes)
+	LOCAL_CFLAGS += -DMTK_75DISPLAY_ENHANCEMENT_SUPPORT
+endif
+# --------------------------------------------------------------------------------------------------:
 
 LOCAL_MODULE:= libgui
 
diff --git a/frameworks/native/libs/gui/BufferQueue.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/BufferQueue.cpp
index 590946a..8ecef03 100644
--- a/frameworks/native/libs/gui/BufferQueue.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/BufferQueue.cpp
@@ -32,12 +32,17 @@
 #include <gui/SurfaceTexture.h>
 #include <utils/Trace.h>
 
+// [MTK] {{{
+#include <cutils/xlog.h>
+#include <cutils/properties.h>
+
 // Macros for including the BufferQueue name in log messages
-#define ST_LOGV(x, ...) ALOGV("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
-#define ST_LOGD(x, ...) ALOGD("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
-#define ST_LOGI(x, ...) ALOGI("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
-#define ST_LOGW(x, ...) ALOGW("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
-#define ST_LOGE(x, ...) ALOGE("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
+#define ST_LOGV(x, ...) XLOGV("[%s](this:%p,api:%d) "x, mConsumerName.string(), this, mConnectedApi, ##__VA_ARGS__)
+#define ST_LOGD(x, ...) XLOGD("[%s](this:%p,api:%d) "x, mConsumerName.string(), this, mConnectedApi, ##__VA_ARGS__)
+#define ST_LOGI(x, ...) XLOGI("[%s](this:%p,api:%d) "x, mConsumerName.string(), this, mConnectedApi, ##__VA_ARGS__)
+#define ST_LOGW(x, ...) XLOGW("[%s](this:%p,api:%d) "x, mConsumerName.string(), this, mConnectedApi, ##__VA_ARGS__)
+#define ST_LOGE(x, ...) XLOGE("[%s](this:%p,api:%d) "x, mConsumerName.string(), this, mConnectedApi, ##__VA_ARGS__)
+// [MTK] }}}
 
 #define ATRACE_BUFFER_INDEX(index)                                            \
     if (ATRACE_ENABLED()) {                                                   \
@@ -84,7 +89,7 @@ BufferQueue::BufferQueue(bool allowSynchronousMode,
     // Choose a name using the PID and a process-unique ID.
     mConsumerName = String8::format("unnamed-%d-%d", getpid(), createProcessUniqueId());
 
-    ST_LOGV("BufferQueue");
+    ST_LOGI("BufferQueue");
     if (allocator == NULL) {
         sp<ISurfaceComposer> composer(ComposerService::getComposerService());
         mGraphicBufferAlloc = composer->createGraphicBufferAlloc();
@@ -94,10 +99,22 @@ BufferQueue::BufferQueue(bool allowSynchronousMode,
     } else {
         mGraphicBufferAlloc = allocator;
     }
+
+    // [MTK] {{{
+    // check property for drawing debug line
+    char value[PROPERTY_VALUE_MAX];
+    property_get("debug.bq.line", value, "GOD'S IN HIS HEAVEN, ALL'S RIGHT WITH THE WORLD.");
+    mLine = (-1 != mConsumerName.find(value));
+    mLineCnt = 0;
+
+    if (true == mLine) {
+        ST_LOGI("switch on debug line");
+    }
+    // [MTK] }}}
 }
 
 BufferQueue::~BufferQueue() {
-    ST_LOGV("~BufferQueue");
+    ST_LOGI("~BufferQueue");
 }
 
 status_t BufferQueue::setDefaultMaxBufferCountLocked(int count) {
@@ -118,6 +135,19 @@ bool BufferQueue::isSynchronousMode() const {
 void BufferQueue::setConsumerName(const String8& name) {
     Mutex::Autolock lock(mMutex);
     mConsumerName = name;
+
+    // [MTK] {{{
+    // check property for drawing debug line
+    ST_LOGI("setConsumerName: %s", mConsumerName.string());
+    char value[PROPERTY_VALUE_MAX];
+    property_get("debug.bq.line", value, "GOD'S IN HIS HEAVEN, ALL'S RIGHT WITH THE WORLD.");
+    mLine = (-1 != mConsumerName.find(value));
+    mLineCnt = 0;
+
+    if (true == mLine) {
+        ST_LOGI("switch on debug line");
+    }
+    // [MTK] }}}
 }
 
 status_t BufferQueue::setDefaultBufferFormat(uint32_t defaultFormat) {
@@ -140,7 +170,7 @@ status_t BufferQueue::setTransformHint(uint32_t hint) {
 }
 
 status_t BufferQueue::setBufferCount(int bufferCount) {
-    ST_LOGV("setBufferCount: count=%d", bufferCount);
+    ST_LOGI("setBufferCount: count=%d", bufferCount);
 
     sp<ConsumerListener> listener;
     {
@@ -260,6 +290,13 @@ status_t BufferQueue::dequeueBuffer(int *outBuf, sp<Fence>& outFence,
     ATRACE_CALL();
     ST_LOGV("dequeueBuffer: w=%d h=%d fmt=%#x usage=%#x", w, h, format, usage);
 
+    // [MTK] {{{
+    // give a warning if dequeueBuffer() in a disconnected state
+    if (NO_CONNECTED_API == mConnectedApi) {
+        ST_LOGW("dequeueBuffer() in a disconnected state");
+    }
+    // [MTK] }}}
+
     if ((w && !h) || (!w && h)) {
         ST_LOGE("dequeueBuffer: invalid size: w=%u, h=%u", w, h);
         return BAD_VALUE;
@@ -314,11 +351,15 @@ status_t BufferQueue::dequeueBuffer(int *outBuf, sp<Fence>& outFence,
                      * the consumer may still have pending reads of the
                      * buffers in flight.
                      */
-                    bool isOlder = mSlots[i].mFrameNumber <
-                            mSlots[found].mFrameNumber;
-                    if (found < 0 || isOlder) {
+                    // [MTK] {{{
+                    // 20120814: fix google stupid bug since found is -1 at first time
+                    if (found < 0) {
+                        found = i;
+                    } else if (mSlots[i].mFrameNumber <
+                               mSlots[found].mFrameNumber) {
                         found = i;
                     }
+                    // [MTK] }}}
                 }
             }
 
@@ -385,6 +426,18 @@ status_t BufferQueue::dequeueBuffer(int *outBuf, sp<Fence>& outFence,
             (uint32_t(buffer->format) != format) ||
             ((uint32_t(buffer->usage) & usage) != usage))
         {
+            // [MTK] {{{
+            // GraphicBuffer in buffer slot need to be re-alloc
+            // print old buffer info before replaced
+            ST_LOGI("new GraphicBuffer needed");
+            if (buffer != NULL) {
+                XLOGD("    [OLD] gb=%p, handle=%p, w=%d, h=%d, f=%d",
+                    buffer.get(), buffer->handle, buffer->width, buffer->height, buffer->format);
+            } else {
+                XLOGD("    [OLD] gb:NULL");
+            }
+            // [MTK] }}}
+
             mSlots[buf].mAcquireCalled = false;
             mSlots[buf].mGraphicBuffer = NULL;
             mSlots[buf].mRequestBufferCalled = false;
@@ -411,6 +464,14 @@ status_t BufferQueue::dequeueBuffer(int *outBuf, sp<Fence>& outFence,
             ST_LOGE("dequeueBuffer: SurfaceComposer::createGraphicBuffer "
                     "failed");
             return error;
+        } else {
+            // [MTK] {{{
+            // print new created GraphicBuffer info
+            XLOGI("    [NEW] gb=%p, handle=%p, w=%d, h=%d, s=%d, fmt=%d",
+                graphicBuffer.get(), graphicBuffer->handle,
+                graphicBuffer->width, graphicBuffer->height, graphicBuffer->stride,
+                graphicBuffer->format);
+            // [MTK] }}}
         }
 
         { // Scope for the lock
@@ -439,15 +500,19 @@ status_t BufferQueue::dequeueBuffer(int *outBuf, sp<Fence>& outFence,
         eglDestroySyncKHR(dpy, eglFence);
     }
 
-    ST_LOGV("dequeueBuffer: returning slot=%d buf=%p flags=%#x", *outBuf,
-            mSlots[*outBuf].mGraphicBuffer->handle, returnFlags);
+    // [MTK] {{{
+    // mark android original unsafe log here
+    // no lock protection, and not important info
+    //ST_LOGV("dequeueBuffer: returning slot=%d buf=%p flags=%#x", *outBuf,
+    //        mSlots[*outBuf].mGraphicBuffer->handle, returnFlags);
+    // [MTK] }}}
 
     return returnFlags;
 }
 
 status_t BufferQueue::setSynchronousMode(bool enabled) {
     ATRACE_CALL();
-    ST_LOGV("setSynchronousMode: enabled=%d", enabled);
+    ST_LOGI("setSynchronousMode: enabled=%d", enabled);
     Mutex::Autolock lock(mMutex);
 
     if (mAbandoned) {
@@ -482,6 +547,13 @@ status_t BufferQueue::queueBuffer(int buf,
     ATRACE_CALL();
     ATRACE_BUFFER_INDEX(buf);
 
+    // [MTK] {{{
+    // give a warning if queueBuffer() in a disconnected state
+    if (NO_CONNECTED_API == mConnectedApi) {
+        ST_LOGW("queueBuffer() in a disconnected state");
+    }
+    // [MTK] }}}
+
     Rect crop;
     uint32_t transform;
     int scalingMode;
@@ -528,6 +600,40 @@ status_t BufferQueue::queueBuffer(int buf,
             return -EINVAL;
         }
 
+        // [MTK] {{{
+        // if queue not empty, means consumer is slower than producer
+        // * in sync mode, may cause lag (but size 1 should be OK for triple buffer)
+        // * in async mode, frame drop
+        bool dump_fifo = false;
+        if (true == mSynchronousMode) {
+            // fifo depth 1 is ok for triple buffer, but 2 would cause lag
+            if (1 < mQueue.size()) {
+                ST_LOGI("[queue] queued:%d (lag)", mQueue.size());
+                dump_fifo = true;
+            }
+        } else {
+            // frame drop is fifo is not empty
+            if (0 < mQueue.size()) {
+                ST_LOGI("[queue] queued:%d (drop frame)", mQueue.size());
+                dump_fifo = true;
+            }
+        }
+
+        // dump current fifo data, and the new coming one
+        if (true == dump_fifo) {
+            const BufferSlot *slot = &(mSlots[buf]);
+            ST_LOGD("NEW [idx:%d] time:%lld, handle:%p",
+                buf, ns2ms(slot->mTimestamp), slot->mGraphicBuffer->handle);
+
+            Fifo::const_iterator i(mQueue.begin());
+            while (i != mQueue.end()) {
+                slot = &(mSlots[*i]);
+                ST_LOGD("    [idx:%d] time:%lld, handle:%p",
+                    *i++, ns2ms(slot->mTimestamp), slot->mGraphicBuffer->handle);
+            }
+        }
+        // [MTK] }}}
+
         if (mSynchronousMode) {
             // In synchronous mode we queue all buffers in a FIFO.
             mQueue.push_back(buf);
@@ -587,12 +693,23 @@ status_t BufferQueue::queueBuffer(int buf,
     if (listener != 0) {
         listener->onFrameAvailable();
     }
+
+    // [MTK] {{{
+    // count FPS after queueBuffer() success, for producer side
+    if (true == mQueueFps.update()) {
+        ST_LOGI("[queue] fps:%.2f, dur:%.2f, max:%.2f, min:%.2f",
+            mQueueFps.getFps(),
+            mQueueFps.getLastLogDuration() / 1e6,
+            mQueueFps.getMaxDuration() / 1e6,
+            mQueueFps.getMinDuration() / 1e6);
+    }
+    // [MTK] }}}
     return OK;
 }
 
 void BufferQueue::cancelBuffer(int buf, sp<Fence> fence) {
     ATRACE_CALL();
-    ST_LOGV("cancelBuffer: slot=%d", buf);
+    ST_LOGD("cancelBuffer: slot=%d", buf);
     Mutex::Autolock lock(mMutex);
 
     if (mAbandoned) {
@@ -618,7 +735,7 @@ void BufferQueue::cancelBuffer(int buf, sp<Fence> fence) {
 
 status_t BufferQueue::connect(int api, QueueBufferOutput* output) {
     ATRACE_CALL();
-    ST_LOGV("connect: api=%d", api);
+    ST_LOGI("connect: api=%d", api);
     Mutex::Autolock lock(mMutex);
 
     if (mAbandoned) {
@@ -640,7 +757,10 @@ status_t BufferQueue::connect(int api, QueueBufferOutput* output) {
             if (mConnectedApi != NO_CONNECTED_API) {
                 ST_LOGE("connect: already connected (cur=%d, req=%d)",
                         mConnectedApi, api);
-                err = -EINVAL;
+                // [MTK] {{{
+                // return a specific error code for nested connection
+                err = -EEXIST;
+                // [MTK] }}}
             } else {
                 mConnectedApi = api;
                 output->inflate(mDefaultWidth, mDefaultHeight, mTransformHint,
@@ -659,7 +779,7 @@ status_t BufferQueue::connect(int api, QueueBufferOutput* output) {
 
 status_t BufferQueue::disconnect(int api) {
     ATRACE_CALL();
-    ST_LOGV("disconnect: api=%d", api);
+    ST_LOGI("disconnect: api=%d", api);
 
     int err = NO_ERROR;
     sp<ConsumerListener> listener;
@@ -725,14 +845,17 @@ void BufferQueue::dump(String8& result, const char* prefix,
 
     int maxBufferCount = getMaxBufferCountLocked();
 
+    // [MTK] {{{
+    // add more message for debug
     snprintf(buffer, SIZE,
-            "%s-BufferQueue maxBufferCount=%d, mSynchronousMode=%d, default-size=[%dx%d], "
+            "%s-BufferQueue mConnectedApi=%d, maxBufferCount=%d, mSynchronousMode=%d, default-size=[%dx%d], "
             "default-format=%d, transform-hint=%02x, FIFO(%d)={%s}\n",
-            prefix, maxBufferCount, mSynchronousMode, mDefaultWidth,
+            prefix, mConnectedApi, maxBufferCount, mSynchronousMode, mDefaultWidth,
             mDefaultHeight, mDefaultBufferFormat, mTransformHint,
             fifoSize, fifo.string());
-    result.append(buffer);
+    // [MTK] }}}
 
+    result.append(buffer);
 
     struct {
         const char * operator()(int state) const {
@@ -851,6 +974,14 @@ status_t BufferQueue::acquireBuffer(BufferItem *buffer) {
         mDequeueCondition.broadcast();
 
         ATRACE_INT(mConsumerName.string(), mQueue.size());
+
+        // [MTK] {{{
+        // draw white debug line
+        if (true == mLine) {
+            DrawDebugLineToGraphicBuffer(mSlots[buf].mGraphicBuffer, mLineCnt);
+            mLineCnt += 1;
+        }
+        // [MTK] }}}
     } else {
         return NO_BUFFER_AVAILABLE;
     }
@@ -886,11 +1017,23 @@ status_t BufferQueue::releaseBuffer(int buf, EGLDisplay display,
     }
 
     mDequeueCondition.broadcast();
+
+    // [MTK] {{{
+    // count FPS after releaseBuffer() success, for consumer side
+    if (true == mReleaseFps.update()) {
+        ST_LOGI("[release] fps:%.2f, dur:%.2f, max:%.2f, min:%.2f",
+            mReleaseFps.getFps(),
+            mReleaseFps.getLastLogDuration() / 1e6,
+            mReleaseFps.getMaxDuration() / 1e6,
+            mReleaseFps.getMinDuration() / 1e6);
+    }
+    // [MTK] }}}
+
     return OK;
 }
 
 status_t BufferQueue::consumerConnect(const sp<ConsumerListener>& consumerListener) {
-    ST_LOGV("consumerConnect");
+    ST_LOGI("consumerConnect");
     Mutex::Autolock lock(mMutex);
 
     if (mAbandoned) {
@@ -904,7 +1047,7 @@ status_t BufferQueue::consumerConnect(const sp<ConsumerListener>& consumerListen
 }
 
 status_t BufferQueue::consumerDisconnect() {
-    ST_LOGV("consumerDisconnect");
+    ST_LOGI("consumerDisconnect");
     Mutex::Autolock lock(mMutex);
 
     if (mConsumerListener == NULL) {
@@ -937,13 +1080,13 @@ status_t BufferQueue::getReleasedBuffers(uint32_t* slotMask) {
     }
     *slotMask = mask;
 
-    ST_LOGV("getReleasedBuffers: returning mask %#x", mask);
+    ST_LOGI("getReleasedBuffers: returning mask %#x", mask);
     return NO_ERROR;
 }
 
 status_t BufferQueue::setDefaultBufferSize(uint32_t w, uint32_t h)
 {
-    ST_LOGV("setDefaultBufferSize: w=%d, h=%d", w, h);
+    ST_LOGI("setDefaultBufferSize: w=%d, h=%d", w, h);
     if (!w || !h) {
         ST_LOGE("setDefaultBufferSize: dimensions cannot be 0 (w=%d, h=%d)",
                 w, h);
diff --git a/frameworks/native/libs/gui/ConsumerBase.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/ConsumerBase.cpp
index 624d7e0..e44fcff 100644
--- a/frameworks/native/libs/gui/ConsumerBase.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/ConsumerBase.cpp
@@ -118,6 +118,11 @@ void ConsumerBase::onBuffersReleased() {
         return;
     }
 
+    // [MTK] {{{
+    // force conversion here for last buffer
+    forceAuxConversionLocked();
+    // [MTK] }}}
+
     uint32_t mask = 0;
     mBufferQueue->getReleasedBuffers(&mask);
     for (int i = 0; i < BufferQueue::NUM_BUFFER_SLOTS; i++) {
diff --git a/frameworks/native/libs/gui/Surface.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/Surface.cpp
index 1745061..4f0ce04 100644
--- a/frameworks/native/libs/gui/Surface.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/Surface.cpp
@@ -104,7 +104,8 @@ status_t SurfaceControl::setLayer(int32_t layer) {
     const sp<SurfaceComposerClient>& client(mClient);
     return client->setLayer(mToken, layer);
 }
-status_t SurfaceControl::setPosition(int32_t x, int32_t y) {
+//status_t SurfaceControl::setPosition(int32_t x, int32_t y) {
+status_t SurfaceControl::setPosition(float x, float y) {
     status_t err = validate();
     if (err < 0) return err;
     const sp<SurfaceComposerClient>& client(mClient);
diff --git a/frameworks/native/libs/gui/SurfaceComposerClient.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/SurfaceComposerClient.cpp
index 80dd6ee..2e05f57 100644
--- a/frameworks/native/libs/gui/SurfaceComposerClient.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/SurfaceComposerClient.cpp
@@ -39,6 +39,10 @@
 #include <private/gui/ComposerService.h>
 #include <private/gui/LayerState.h>
 
+// [MTK] {{{
+#include <cutils/properties.h>
+// [MTK] }}}
+
 namespace android {
 // ---------------------------------------------------------------------------
 
@@ -169,6 +173,11 @@ public:
     static void closeGlobalTransaction(bool synchronous) {
         Composer::getInstance().closeGlobalTransactionImpl(synchronous);
     }
+
+    // [MTK] {{{
+    status_t setFlagsEx(const sp<SurfaceComposerClient>& client, SurfaceID id,
+            uint32_t flags, uint32_t mask);
+    // [MTK] }}}
 };
 
 ANDROID_SINGLETON_STATIC_INSTANCE(Composer);
@@ -393,6 +402,22 @@ void Composer::setDisplayProjection(const sp<IBinder>& token,
     mForceSynchronous = true; // TODO: do we actually still need this?
 }
 
+// [MTK] {{{
+status_t Composer::setFlagsEx(const sp<SurfaceComposerClient>& client,
+        SurfaceID id, uint32_t flags,
+        uint32_t mask) {
+    Mutex::Autolock _l(mLock);
+    layer_state_t* s = getLayerStateLocked(client, id);
+    if (!s)
+        return BAD_INDEX;
+    s->what |= layer_state_t::eVisibilityChanged;
+    s->flagsEx &= ~mask;
+    s->flagsEx |= (flags & mask);
+    s->maskEx |= mask;
+    return NO_ERROR;
+}
+// [MTK] }}}
+
 // ---------------------------------------------------------------------------
 
 SurfaceComposerClient::SurfaceComposerClient()
@@ -563,10 +588,30 @@ void SurfaceComposerClient::setDisplayProjection(const sp<IBinder>& token,
         uint32_t orientation,
         const Rect& layerStackRect,
         const Rect& displayRect) {
+    // [MTK] {{{
+    char value[PROPERTY_VALUE_MAX];
+    property_get("service.shutanim.running", value, "-1");
+    int shutanim_running = atoi(value);
+    if (0 == shutanim_running) {
+        ALOGI("!!! shutdown animation is running, apply default orientation !!!");
+        Composer::getInstance().setDisplayProjection(
+                token, DisplayState::eOrientationDefault,
+                layerStackRect, displayRect);
+        return;
+    }
+    // [MTK] }}}
+
     Composer::getInstance().setDisplayProjection(token, orientation,
             layerStackRect, displayRect);
 }
 
+// [MTK] {{{
+status_t SurfaceComposerClient::setFlagsEx(SurfaceID id, uint32_t flags,
+        uint32_t mask) {
+    return getComposer().setFlagsEx(this, id, flags, mask);
+}
+// [MTK] }}}
+
 // ----------------------------------------------------------------------------
 
 status_t SurfaceComposerClient::getDisplayInfo(
@@ -624,6 +669,13 @@ void ScreenshotClient::release() {
 }
 
 void const* ScreenshotClient::getPixels() const {
+    // [MTK] {{{
+    // Error handling for null pointer access
+    if (mHeap == 0) {
+        ALOGE("[%s] memory heap is NULL", __func__);
+        return NULL;
+    }
+    // [MTK] }}}
     return mHeap->getBase();
 }
 
@@ -644,6 +696,13 @@ uint32_t ScreenshotClient::getStride() const {
 }
 
 size_t ScreenshotClient::getSize() const {
+    // [MTK] {{{
+    // Error handling for null pointer access
+    if (mHeap == 0) {
+        ALOGE("[%s] memory heap is NULL", __func__);
+        return NULL;
+    }
+    // [MTK] }}}
     return mHeap->getSize();
 }
 
diff --git a/frameworks/native/libs/gui/SurfaceTexture.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/SurfaceTexture.cpp
index b4dfb5e..32cfcce 100644
--- a/frameworks/native/libs/gui/SurfaceTexture.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/SurfaceTexture.cpp
@@ -39,6 +39,10 @@
 #include <utils/String8.h>
 #include <utils/Trace.h>
 
+// [MTK] {{{
+#include <cutils/properties.h>
+// [MTK] }}}
+
 // This compile option makes SurfaceTexture use the
 // EGL_ANDROID_native_fence_sync extension to create Android native fences to
 // signal when all GLES reads for a given buffer have completed.  It is not
@@ -63,12 +67,16 @@ static const bool useWaitSync = true;
 static const bool useWaitSync = false;
 #endif
 
+// [MTK] {{{
+// use xlog for flexible log control
 // Macros for including the SurfaceTexture name in log messages
-#define ST_LOGV(x, ...) ALOGV("[%s] "x, mName.string(), ##__VA_ARGS__)
-#define ST_LOGD(x, ...) ALOGD("[%s] "x, mName.string(), ##__VA_ARGS__)
-#define ST_LOGI(x, ...) ALOGI("[%s] "x, mName.string(), ##__VA_ARGS__)
-#define ST_LOGW(x, ...) ALOGW("[%s] "x, mName.string(), ##__VA_ARGS__)
-#define ST_LOGE(x, ...) ALOGE("[%s] "x, mName.string(), ##__VA_ARGS__)
+#include <cutils/xlog.h>
+#define ST_LOGV(x, ...) XLOGV("[%s](this:%p,api:%d) "x, mName.string(), this, getConnectedApi(), ##__VA_ARGS__)
+#define ST_LOGD(x, ...) XLOGD("[%s](this:%p,api:%d) "x, mName.string(), this, getConnectedApi(), ##__VA_ARGS__)
+#define ST_LOGI(x, ...) XLOGI("[%s](this:%p,api:%d) "x, mName.string(), this, getConnectedApi(), ##__VA_ARGS__)
+#define ST_LOGW(x, ...) XLOGW("[%s](this:%p,api:%d) "x, mName.string(), this, getConnectedApi(), ##__VA_ARGS__)
+#define ST_LOGE(x, ...) XLOGE("[%s](this:%p,api:%d) "x, mName.string(), this, getConnectedApi(), ##__VA_ARGS__)
+// [MTK] }}}
 
 namespace android {
 
@@ -131,12 +139,31 @@ SurfaceTexture::SurfaceTexture(GLuint tex, bool allowSynchronousMode,
     mCurrentTexture(BufferQueue::INVALID_BUFFER_SLOT),
     mAttached(true)
 {
-    ST_LOGV("SurfaceTexture");
+    ST_LOGI("SurfaceTexture");
 
     memcpy(mCurrentTransformMatrix, mtxIdentity,
             sizeof(mCurrentTransformMatrix));
 
     mBufferQueue->setConsumerUsageBits(DEFAULT_USAGE_FLAGS);
+
+    // [MTK] {{{
+
+    // init status for conversion
+    mAuxSlotConvert = false;
+    mAuxSlotDirty = false;
+    mBackAuxSlot = mAuxSlot;
+    mFrontAuxSlot = mAuxSlot + 1;
+
+    // drawing debug line
+    char value[PROPERTY_VALUE_MAX];
+    property_get("debug.st.line", value, "0");
+    mLine = (0 != atoi(value));
+    mLineCnt = 0;
+
+    if (true == mLine) {
+        ST_LOGI("switch on debug line");
+    }
+    // [MTK] }}}
 }
 
 status_t SurfaceTexture::setDefaultMaxBufferCount(int bufferCount) {
@@ -308,6 +335,22 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync)
             doGLFenceWaitLocked();
         }
         computeCurrentTransformMatrixLocked();
+
+        // [MTK] {{{
+        // buffer conversion
+        mAuxSlotConvert = (checkPixelFormatSupported() == OK);
+        if (true == mAuxSlotConvert) {
+            // try conversion here
+            convertToAuxSlotLocked(false);
+        } else {
+            mAuxSlotDirty = false;
+        }
+
+        if (true == mAuxSlotDirty) {
+            // if converted into aux buffer, use aux buffer as texture
+            bindToAuxSlotLocked();
+        }
+        // [MTK] }}}
     } else  {
         if (err < 0) {
             ST_LOGE("updateTexImage: acquire failed: %s (%d)",
@@ -335,7 +378,7 @@ void SurfaceTexture::setReleaseFence(int fenceFd) {
 
 status_t SurfaceTexture::detachFromContext() {
     ATRACE_CALL();
-    ST_LOGV("detachFromContext");
+    ST_LOGI("detachFromContext");
     Mutex::Autolock lock(mMutex);
 
     if (mAbandoned) {
@@ -383,6 +426,12 @@ status_t SurfaceTexture::detachFromContext() {
         }
     }
 
+    // [MTK] {{{
+    // also clear aux buffer
+    freeAuxSlotLocked(mAuxSlot[0]);
+    freeAuxSlotLocked(mAuxSlot[1]);
+    // [MTK] }}}
+
     mEglDisplay = EGL_NO_DISPLAY;
     mEglContext = EGL_NO_CONTEXT;
     mAttached = false;
@@ -392,7 +441,7 @@ status_t SurfaceTexture::detachFromContext() {
 
 status_t SurfaceTexture::attachToContext(GLuint tex) {
     ATRACE_CALL();
-    ST_LOGV("attachToContext");
+    ST_LOGI("attachToContext");
     Mutex::Autolock lock(mMutex);
 
     if (mAbandoned) {
@@ -689,6 +738,13 @@ EGLImageKHR SurfaceTexture::createImage(EGLDisplay dpy,
     if (image == EGL_NO_IMAGE_KHR) {
         EGLint error = eglGetError();
         ST_LOGE("error creating EGLImage: %#x", error);
+    } else {
+        // [MTK] {{{
+        // add log for eglImage created
+        ST_LOGI("[%s]", __func__);
+        XLOGD("    GraphicBuffer: gb=%p handle=%p", graphicBuffer.get(), graphicBuffer->handle);
+        XLOGD("    EGLImage: dpy=%p, img=%p", mEglDisplay, image);
+        // [MTK] }}}
     }
     return image;
 }
@@ -708,10 +764,10 @@ Rect SurfaceTexture::getCurrentCrop() const {
 
         if (newWidth * mDefaultHeight > newHeight * mDefaultWidth) {
             newWidth = newHeight * mDefaultWidth / mDefaultHeight;
-            ST_LOGV("too wide: newWidth = %d", newWidth);
+            ST_LOGW("too wide: newWidth = %d", newWidth);
         } else if (newWidth * mDefaultHeight < newHeight * mDefaultWidth) {
             newHeight = newWidth * mDefaultHeight / mDefaultWidth;
-            ST_LOGV("too tall: newHeight = %d", newHeight);
+            ST_LOGW("too tall: newHeight = %d", newHeight);
         }
 
         // The crop is too wide
@@ -826,7 +882,7 @@ void SurfaceTexture::freeBufferLocked(int slotIndex) {
     }
     EGLImageKHR img = mEglSlots[slotIndex].mEglImage;
     if (img != EGL_NO_IMAGE_KHR) {
-        ST_LOGV("destroying EGLImage dpy=%p img=%p", mEglDisplay, img);
+        ST_LOGI("destroying EGLImage dpy=%p img=%p", mEglDisplay, img);
         eglDestroyImageKHR(mEglDisplay, img);
     }
     mEglSlots[slotIndex].mEglImage = EGL_NO_IMAGE_KHR;
@@ -837,6 +893,12 @@ void SurfaceTexture::abandonLocked() {
     ST_LOGV("abandonLocked");
     mCurrentTextureBuf.clear();
     ConsumerBase::abandonLocked();
+
+    // [MTK] {{{
+    // clear aux buffer
+    freeAuxSlotLocked(mAuxSlot[0]);
+    freeAuxSlotLocked(mAuxSlot[1]);
+    // [MTK] }}}
 }
 
 void SurfaceTexture::setName(const String8& name) {
@@ -879,6 +941,24 @@ void SurfaceTexture::dumpLocked(String8& result, const char* prefix,
        mCurrentTransform);
     result.append(buffer);
 
+    // [MTK] {{{
+    // dump aux information
+    // currently 2 AUX, in RGBA format
+    uint32_t i;
+    sp<GraphicBuffer> gb;
+    for (i = 0; i < 2; i++) {
+        gb = mAuxSlot[i].slot.mGraphicBuffer;
+        if (gb != NULL) {
+            snprintf(buffer, size,
+                "%s%s[%02d] gb:%p, %p [%4ux%4u:%4u,%3X]\n",
+                prefix, (mFrontAuxSlot == &(mAuxSlot[i])) ? ">" : " ",
+                i, gb.get(),
+                gb->handle, gb->width, gb->height, gb->stride, gb->format);
+            result.append(buffer);
+        }
+    }
+    // [MTK] }}}
+
     ConsumerBase::dumpLocked(result, prefix, buffer, size);
 }
 
diff --git a/frameworks/native/libs/gui/SurfaceTextureClient.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/SurfaceTextureClient.cpp
index afdbf04..94abf3f 100644
--- a/frameworks/native/libs/gui/SurfaceTextureClient.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/gui/SurfaceTextureClient.cpp
@@ -32,6 +32,16 @@
 
 #include <private/gui/ComposerService.h>
 
+// [MTK] {{{
+// FPS profiling
+#include <utils/CallStack.h>
+#include <cutils/xlog.h>
+#include <gui/BufferQueue.h>
+
+// buffer count water level
+#define ALARM_BUFFER_COUNT 9
+// [MTK] }}}
+
 namespace android {
 
 SurfaceTextureClient::SurfaceTextureClient(
@@ -91,6 +101,10 @@ void SurfaceTextureClient::init() {
     mTransformHint = 0;
     mConsumerRunningBehind = false;
     mConnectedToCpu = false;
+
+    // [MTK] {{{
+    mConnectedApi = BufferQueue::NO_CONNECTED_API;
+    // [MTK] }}}
 }
 
 void SurfaceTextureClient::setISurfaceTexture(
@@ -133,7 +147,10 @@ int SurfaceTextureClient::hook_dequeueBuffer_DEPRECATED(ANativeWindow* window,
     int fenceFd = -1;
     int result = c->dequeueBuffer(&buf, &fenceFd);
     sp<Fence> fence(new Fence(fenceFd));
-    int waitResult = fence->waitForever(1000, "dequeueBuffer_DEPRECATED");
+    // [MTK] {{{
+    // adjust wait time from 1000 to 300 ms
+    int waitResult = fence->waitForever(300, "dequeueBuffer_DEPRECATED");
+    // [MTK] }}}
     if (waitResult != OK) {
         ALOGE("dequeueBuffer_DEPRECATED: Fence::wait returned an error: %d",
                 waitResult);
@@ -285,12 +302,51 @@ int SurfaceTextureClient::queueBuffer(android_native_buffer_t* buffer, int fence
     } else {
         timestamp = mTimestamp;
     }
+
+    // [MTK] {{{
+    // get systime for MTK FPS check
+    int64_t systime;
+    if (mTimestamp == NATIVE_WINDOW_TIMESTAMP_AUTO) {
+        systime = timestamp;
+    } else {
+        systime = systemTime(SYSTEM_TIME_MONOTONIC);
+    }
+
+    // FPS info, for client side
+    if (true == mQueueFps.update(systime)) {
+        XLOGI("[STC::queueBuffer] (this:%p) fps:%.2f, dur:%.2f, max:%.2f, min:%.2f",
+            this,
+            mQueueFps.getFps(),
+            mQueueFps.getLastLogDuration() / 1e6,
+            mQueueFps.getMaxDuration() / 1e6,
+            mQueueFps.getMinDuration() / 1e6);
+    }
+
+    // check durarion between client queue calling, warn if excceeds (too late or fast)
+    nsecs_t duration = mQueueFps.getLastDuration();
+    if (NATIVE_WINDOW_API_MEDIA == mConnectedApi) {
+        if ((duration > ms2ns(50)) || (duration < ms2ns(16))) {
+            XLOGW("[STC::queueBuffer(Media)] this:%p, api:%d, abnormal interval:%.2f",
+                this, mConnectedApi, duration / 1e6);
+        }
+    } else if (NATIVE_WINDOW_API_CAMERA == mConnectedApi) {
+        if ((duration > ms2ns(40)) || (duration < ms2ns(16))) {
+            XLOGW("[STC::queueBuffer(Camera)] this:%p, api:%d, abnormal interval:%.2f",
+                this, mConnectedApi, duration / 1e6);
+        }
+    } else {
+        if (duration > ms2ns(5000)) {
+            XLOGI("[STC::queueBuffer] this:%p, api:%d, last queue time elapsed:%.2f",
+                this, mConnectedApi, duration / 1e6);
+        }
+    }
+    // [MTK] }}}
+
     int i = getSlotFromBufferLocked(buffer);
     if (i < 0) {
         return i;
     }
 
-
     // Make sure the crop rectangle is entirely inside the buffer.
     Rect crop;
     mCrop.intersect(Rect(buffer->width, buffer->height), &crop);
@@ -303,6 +359,7 @@ int SurfaceTextureClient::queueBuffer(android_native_buffer_t* buffer, int fence
     if (err != OK)  {
         ALOGE("queueBuffer: error queuing buffer to SurfaceTexture, %d", err);
     }
+
     uint32_t numPendingBuffers = 0;
     output.deflate(&mDefaultWidth, &mDefaultHeight, &mTransformHint,
             &numPendingBuffers);
@@ -516,6 +573,19 @@ int SurfaceTextureClient::connect(int api) {
     if (!err && api == NATIVE_WINDOW_API_CPU) {
         mConnectedToCpu = true;
     }
+
+    // [MTK] {{{
+    // 1. keep connection api type for FPS profiling
+    // 2. dump call stack if connect fail
+    if (!err) {
+        mConnectedApi = api;
+    } else {
+        CallStack stack;
+        stack.update();
+        stack.dump("STC::connect");
+    }
+    // [MTK] }}}
+
     return err;
 }
 
@@ -573,6 +643,16 @@ int SurfaceTextureClient::setBufferCount(int bufferCount)
     ALOGV("SurfaceTextureClient::setBufferCount");
     Mutex::Autolock lock(mMutex);
 
+    // [MTK] {{{
+    // give warning message if set buffer count more than ALARM_BUFFER_COUNT
+    if (bufferCount > ALARM_BUFFER_COUNT) {
+        XLOGW("[STC::setBufferCount] set buffer count to %d", bufferCount);
+        CallStack stack;
+        stack.update();
+        stack.dump("[STC::setBufferCount]");
+    }
+    // [MTK] }}}
+
     status_t err = mSurfaceTexture->setBufferCount(bufferCount);
     ALOGE_IF(err, "ISurfaceTexture::setBufferCount(%d) returned %s",
             bufferCount, strerror(-err));
@@ -754,7 +834,10 @@ status_t SurfaceTextureClient::lock(
         sp<GraphicBuffer> backBuffer(GraphicBuffer::getSelf(out));
         sp<Fence> fence(new Fence(fenceFd));
 
-        err = fence->waitForever(1000, "SurfaceTextureClient::lock");
+        // [MTK] {{{
+        // adjust wait time from 1000 to 300 ms
+        err = fence->waitForever(300, "SurfaceTextureClient::lock");
+        // [MKT] }}}
         if (err != OK) {
             ALOGE("Fence::wait failed (%s)", strerror(-err));
             cancelBuffer(out, fenceFd);
diff --git a/frameworks/native/libs/ui/Android.mk b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/ui/Android.mk
index 0d2e44c..7d119ab 100644
--- a/frameworks/native/libs/ui/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/ui/Android.mk
@@ -32,6 +32,25 @@ LOCAL_SHARED_LIBRARIES := \
 	libsync \
 	libutils
 
+# --- MediaTek -------------------------------------------------------------
+LOCAL_SRC_FILES += \
+	mediatek/GraphicBuffer.cpp \
+	mediatek/GraphicBufferAllocator.cpp \
+	mediatek/GraphicBufferMapper.cpp
+
+LOCAL_C_INCLUDES += \
+	$(TOP)/$(MTK_ROOT)/hardware/mmumapper
+
+LOCAL_SHARED_LIBRARIES += \
+	libbinder
+
+ifeq ($(MTK_MMUMAP_SUPPORT), yes)
+LOCAL_CFLAGS += -DMTK_MMUMAP_SUPPORT
+MTK_HWC_CHIP = $(shell echo $(MTK_PLATFORM) | tr A-Z a-z )
+LOCAL_REQUIRED_MODULES += mmumapper.$(MTK_HWC_CHIP)
+endif
+# --------------------------------------------------------------------------
+
 ifneq ($(BOARD_FRAMEBUFFER_FORCE_FORMAT),)
 LOCAL_CFLAGS += -DFRAMEBUFFER_FORCE_FORMAT=$(BOARD_FRAMEBUFFER_FORCE_FORMAT)
 endif
diff --git a/frameworks/native/libs/ui/Fence.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/ui/Fence.cpp
index d214b97..5ec3109 100644
--- a/frameworks/native/libs/ui/Fence.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/ui/Fence.cpp
@@ -60,7 +60,11 @@ status_t Fence::waitForever(unsigned int warningTimeout, const char* logname) {
     if (err < 0 && errno == ETIME) {
         ALOGE("%s: fence %d didn't signal in %u ms", logname, mFenceFd,
                 warningTimeout);
-        err = sync_wait(mFenceFd, TIMEOUT_NEVER);
+        // [MTK] {{{
+        // temporarily remove to avoid infinite waiting
+        //err = sync_wait(mFenceFd, TIMEOUT_NEVER);
+        return status_t(NO_ERROR);
+        // [MTK] }}}
     }
     return err < 0 ? -errno : status_t(NO_ERROR);
 }
diff --git a/frameworks/native/libs/ui/GraphicBuffer.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/ui/GraphicBuffer.cpp
index b9cab85..f8b9c25 100644
--- a/frameworks/native/libs/ui/GraphicBuffer.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/ui/GraphicBuffer.cpp
@@ -28,6 +28,10 @@
 #include <ui/GraphicBufferMapper.h>
 #include <ui/PixelFormat.h>
 
+// [MTK] {{{
+#include <cutils/xlog.h>
+// [MTK] }}}
+
 namespace android {
 
 // ===========================================================================
@@ -44,6 +48,10 @@ GraphicBuffer::GraphicBuffer()
     format = 
     usage  = 0;
     handle = NULL;
+    // [MTK] {{{
+    mva    = 0;
+    msize  = 0;
+    // [MTK] }}}
 }
 
 GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h, 
@@ -57,6 +65,10 @@ GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h,
     format = 
     usage  = 0;
     handle = NULL;
+    // [MTK] {{{
+    mva    = 0;
+    msize  = 0;
+    // [MTK] }}}
     mInitCheck = initSize(w, h, reqFormat, reqUsage);
 }
 
@@ -73,6 +85,14 @@ GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h,
     format = inFormat;
     usage  = inUsage;
     handle = inHandle;
+
+    // [MTK] {{{
+    mva    = 0;
+    msize  = 0;
+
+    XLOGI("create GraphicBuffer by existing handle (w:%d h%d f:%d) owner(%d)",
+          stride, height, format, mOwner);
+    // [MTK] }}}
 }
 
 GraphicBuffer::GraphicBuffer(ANativeWindowBuffer* buffer, bool keepOwnership)
@@ -86,6 +106,14 @@ GraphicBuffer::GraphicBuffer(ANativeWindowBuffer* buffer, bool keepOwnership)
     format = buffer->format;
     usage  = buffer->usage;
     handle = buffer->handle;
+
+    // [MTK] {{{
+    mva    = 0;
+    msize  = 0;
+
+    XLOGI("create GraphicBuffer by existing native window buffer (w:%d h%d f:%d) owner(%d)",
+          stride, height, format, mOwner);
+    // [MTK] }}}
 }
 
 GraphicBuffer::~GraphicBuffer()
@@ -102,6 +130,12 @@ void GraphicBuffer::free_handle()
         native_handle_close(handle);
         native_handle_delete(const_cast<native_handle*>(handle));
     } else if (mOwner == ownData) {
+        // [MTK] {{{
+#ifdef MTK_MMUMAP_SUPPORT
+        unmapBuffer();
+#endif
+        // [MTK] }}}
+
         GraphicBufferAllocator& allocator(GraphicBufferAllocator::get());
         allocator.free(handle);
     }
@@ -133,6 +167,12 @@ status_t GraphicBuffer::reallocate(uint32_t w, uint32_t h, PixelFormat f,
         return NO_ERROR;
 
     if (handle) {
+        // [MTK] {{{
+#ifdef MTK_MMUMAP_SUPPORT
+        unmapBuffer();
+#endif
+        // [MTK] }}}
+
         GraphicBufferAllocator& allocator(GraphicBufferAllocator::get());
         allocator.free(handle);
         handle = 0;
@@ -145,11 +185,22 @@ status_t GraphicBuffer::initSize(uint32_t w, uint32_t h, PixelFormat format,
 {
     GraphicBufferAllocator& allocator = GraphicBufferAllocator::get();
     status_t err = allocator.alloc(w, h, format, reqUsage, &handle, &stride);
+    
+    // [MTK] {{{
+    XLOGI("allocate buffer (w:%d h:%d f:%d) err(%d)", stride, h, format, err);
+    // [MTK] }}}
+
     if (err == NO_ERROR) {
         this->width  = w;
         this->height = h;
         this->format = format;
         this->usage  = reqUsage;
+
+        // [MTK] {{{
+#ifdef MTK_MMUMAP_SUPPORT
+        mapBuffer();
+#endif
+        // [MTK] }}}
     }
     return err;
 }
@@ -241,6 +292,14 @@ status_t GraphicBuffer::unflatten(void const* buffer, size_t size,
     }
 
     if (numFds || numInts) {
+        // [MTK] {{{
+        /*
+        if (stride != buf[3] || height != buf[2] || format != buf[4]) {
+            XLOGW("Unflatten with different type (w:%d h:%d f:%d) -> (w:%d h:%d f:%d)",
+                   stride, height, format, buf[3], buf[2], buf[4]);
+        }
+        */
+        // [MTK] }}}
         width  = buf[1];
         height = buf[2];
         stride = buf[3];
diff --git a/frameworks/native/libs/ui/GraphicBufferAllocator.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/ui/GraphicBufferAllocator.cpp
index ff550d9..db49f91 100644
--- a/frameworks/native/libs/ui/GraphicBufferAllocator.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/ui/GraphicBufferAllocator.cpp
@@ -26,6 +26,10 @@
 
 #include <ui/GraphicBufferAllocator.h>
 
+// [MTK] {{{
+#include <binder/IPCThreadState.h>
+// [MTK] }}}
+
 namespace android {
 // ---------------------------------------------------------------------------
 
@@ -44,10 +48,22 @@ GraphicBufferAllocator::GraphicBufferAllocator()
     if (err == 0) {
         gralloc_open(module, &mAllocDev);
     }
+
+    // [MTK] {{{
+#ifdef MTK_MMUMAP_SUPPORT
+    initMapper();
+#endif
+    // [MTK] }}}
 }
 
 GraphicBufferAllocator::~GraphicBufferAllocator()
 {
+    // [MTK] {{{
+#ifdef MTK_MMUMAP_SUPPORT
+    uninitMapper();
+#endif
+    // [MTK] }}}
+
     gralloc_close(mAllocDev);
 }
 
@@ -63,15 +79,17 @@ void GraphicBufferAllocator::dump(String8& result) const
     const size_t c = list.size();
     for (size_t i=0 ; i<c ; i++) {
         const alloc_rec_t& rec(list.valueAt(i));
+        // [MTK] {{{
         if (rec.size) {
-            snprintf(buffer, SIZE, "%10p: %7.2f KiB | %4u (%4u) x %4u | %8X | 0x%08x\n",
+            snprintf(buffer, SIZE, "%10p: %7.2f KiB | %4u (%4u) x %4u | %8X | 0x%08x | %u\n",
                     list.keyAt(i), rec.size/1024.0f,
-                    rec.w, rec.s, rec.h, rec.format, rec.usage);
+                    rec.w, rec.s, rec.h, rec.format, rec.usage, rec.pid);
         } else {
-            snprintf(buffer, SIZE, "%10p: unknown     | %4u (%4u) x %4u | %8X | 0x%08x\n",
+            snprintf(buffer, SIZE, "%10p: unknown     | %4u (%4u) x %4u | %8X | 0x%08x | %u\n",
                     list.keyAt(i),
-                    rec.w, rec.s, rec.h, rec.format, rec.usage);
+                    rec.w, rec.s, rec.h, rec.format, rec.usage, rec.pid);
         }
+        // [MTK] }}}
         result.append(buffer);
         total += rec.size;
     }
@@ -123,6 +141,9 @@ status_t GraphicBufferAllocator::alloc(uint32_t w, uint32_t h, PixelFormat forma
         rec.format = format;
         rec.usage = usage;
         rec.size = h * stride[0] * bpp;
+        // [MTK] {{{
+        rec.pid = IPCThreadState::self()->getCallingPid();
+        // [MTK] }}}
         list.add(*handle, rec);
     }
 
diff --git a/frameworks/native/libs/ui/GraphicBufferMapper.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/ui/GraphicBufferMapper.cpp
index 967da98..28a095e 100644
--- a/frameworks/native/libs/ui/GraphicBufferMapper.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/ui/GraphicBufferMapper.cpp
@@ -44,6 +44,14 @@ GraphicBufferMapper::GraphicBufferMapper()
     if (err == 0) {
         mAllocMod = (gralloc_module_t const *)module;
     }
+
+    // [MTK] {{{
+    // 20120918: gralloc extra device for internal purpose
+    mExtraDev = NULL;
+    if (err == 0) {
+        gralloc_extra_open(module, &mExtraDev);
+    }
+    // [MTK] }}}
 }
 
 status_t GraphicBufferMapper::registerBuffer(buffer_handle_t handle)
diff --git a/frameworks/native/libs/ui/PixelFormat.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/ui/PixelFormat.cpp
index 3ced41d..356b253 100644
--- a/frameworks/native/libs/ui/PixelFormat.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/ui/PixelFormat.cpp
@@ -52,6 +52,10 @@ static Info const sPixelFormatInfos[] = {
         { 1,  8, { 0, 0,   8, 0,   8, 0,   8, 0 }, PixelFormatInfo::L    },
         { 2, 16, {16, 8,   8, 0,   8, 0,   8, 0 }, PixelFormatInfo::LA   },
         { 1,  8, { 0, 0,   8, 5,   5, 2,   2, 0 }, PixelFormatInfo::RGB  },
+        // [MTK] {{{
+        // SGX_BGRX_8888
+        { 4, 24, { 0, 0,  24,16,  16, 8,   8, 0 }, PixelFormatInfo::RGB  },
+        // [MTK] }}}
 };
 
 static const Info* gGetPixelFormatTable(size_t* numEntries) {
@@ -109,7 +113,9 @@ status_t getPixelFormatInfo(PixelFormat format, PixelFormatInfo* info)
      done:
         info->format = format;
         info->components = COMPONENT_YUV;
-        info->bytesPerPixel = 1;
+        // [MTK] {{{
+        info->bytesPerPixel = 2;
+        // [MTK] }}}
         info->h_alpha = 0;
         info->l_alpha = 0;
         info->h_red = info->h_green = info->h_blue = 8;
@@ -117,9 +123,13 @@ status_t getPixelFormatInfo(PixelFormat format, PixelFormatInfo* info)
         return NO_ERROR;
     }
 
+    // [MTK] {{{
+    // for SGX BGRX 8888
+    int index = (format == 0x1FF) ? 12 : format;
     size_t numEntries;
-    const Info *i = gGetPixelFormatTable(&numEntries) + format;
-    bool valid = uint32_t(format) < numEntries;
+    const Info *i = gGetPixelFormatTable(&numEntries) + index;
+    bool valid = uint32_t(index) < numEntries;
+    // [MTK] }}}
     if (!valid) {
         return BAD_INDEX;
     }
diff --git a/frameworks/native/libs/utils/Android.mk b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/utils/Android.mk
index c9f8fd4..9156ed4 100644
--- a/frameworks/native/libs/utils/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/libs/utils/Android.mk
@@ -124,6 +124,19 @@ LOCAL_SHARED_LIBRARIES := \
 	libcorkscrew \
 	libz
 
+ifeq ($(TARGET_BUILD_VARIANT),eng)
+ifeq ($(filter banyan_addon banyan_addon_x86,$(TARGET_PRODUCT)),)
+ifeq ($(MTK_INTERNAL),yes)
+# mtk80143: enable FP and ARM build for debug15 memory debugging
+LOCAL_CFLAGS += \
+		-fno-omit-frame-pointer \
+		-mapcs
+LOCAL_ARM_MODE := arm
+endif	
+endif
+endif
+
+
 LOCAL_MODULE:= libutils
 include $(BUILD_SHARED_LIBRARY)
 
@@ -132,6 +145,9 @@ include $(BUILD_SHARED_LIBRARY)
 
 # If we're building with ONE_SHOT_MAKEFILE (mm, mmm), then what the framework
 # team really wants is to build the stuff defined by this makefile.
+ifneq (true,$(BUILD_TINY_ANDROID))
 ifeq (,$(ONE_SHOT_MAKEFILE))
 include $(call first-makefiles-under,$(LOCAL_PATH))
 endif
+endif
+
diff --git a/frameworks/native/opengl/libagl/egl.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/opengl/libagl/egl.cpp
index 172ef95..5636985 100644
--- a/frameworks/native/opengl/libagl/egl.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/opengl/libagl/egl.cpp
@@ -2047,6 +2047,13 @@ EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target,
         case HAL_PIXEL_FORMAT_BGRA_8888:
         case HAL_PIXEL_FORMAT_RGBA_5551:
         case HAL_PIXEL_FORMAT_RGBA_4444:
+ //shallytest, for sw gralloc interface
+        case HAL_PIXEL_FORMAT_YV12:
+        case HAL_PIXEL_FORMAT_I420:
+        case HAL_PIXEL_FORMAT_NV12_BLK:
+        case HAL_PIXEL_FORMAT_NV12_BLK_FCM:
+        //~shallytest, for sw gralloc interface
+
             break;
         default:
             return setError(EGL_BAD_PARAMETER, EGL_NO_IMAGE_KHR);
diff --git a/frameworks/native/opengl/libs/EGL/egl_cache.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/opengl/libs/EGL/egl_cache.cpp
index 72655df..1d22c80 100644
--- a/frameworks/native/opengl/libs/EGL/egl_cache.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/opengl/libs/EGL/egl_cache.cpp
@@ -34,7 +34,7 @@
 #endif
 
 #ifndef MAX_EGL_CACHE_SIZE
-#define MAX_EGL_CACHE_SIZE (64 * 1024);
+#define MAX_EGL_CACHE_SIZE (512 * 1024);
 #endif
 
 // Cache size limits.
diff --git a/frameworks/native/opengl/libs/GLES_trace/.gitignore b/frameworks/native/opengl/libs/GLES_trace/.gitignore
deleted file mode 100644
index 8df825e..0000000
--- a/frameworks/native/opengl/libs/GLES_trace/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-java
-*.pyc
-*.swp
-pyratemp.py
diff --git a/frameworks/native/opengl/tools/glgen/.gitignore b/frameworks/native/opengl/tools/glgen/.gitignore
deleted file mode 100644
index 007ec65..0000000
--- a/frameworks/native/opengl/tools/glgen/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-generated
-out
diff --git a/frameworks/native/opengl/tools/glgen/src/.gitignore b/frameworks/native/opengl/tools/glgen/src/.gitignore
deleted file mode 100644
index 6b468b6..0000000
--- a/frameworks/native/opengl/tools/glgen/src/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-*.class
diff --git a/frameworks/native/services/sensorservice/SensorService.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/sensorservice/SensorService.h
index 18591bf..b6e333c 100644
--- a/frameworks/native/services/sensorservice/SensorService.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/sensorservice/SensorService.h
@@ -37,7 +37,7 @@
 
 // ---------------------------------------------------------------------------
 
-#define DEBUG_CONNECTIONS   false
+#define DEBUG_CONNECTIONS   true
 
 struct sensors_poll_device_t;
 struct sensors_module_t;
diff --git a/frameworks/native/services/surfaceflinger/Android.mk b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/Android.mk
index 5a57697..3b57afb 100644
--- a/frameworks/native/services/surfaceflinger/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/Android.mk
@@ -53,6 +53,52 @@ LOCAL_SHARED_LIBRARIES := \
 	libui \
 	libgui
 
+# --- MediaTek ---------------------------------------------------------------
+LOCAL_SRC_FILES += \
+	mediatek/SurfaceFlinger.cpp \
+	mediatek/Layer.cpp \
+	mediatek/LayerBase.cpp \
+	mediatek/LayerDim.cpp \
+	mediatek/LayerScreenshot.cpp \
+	mediatek/DisplayHardware/HWComposer.cpp \
+	mediatek/SurfaceTextureLayer.cpp \
+	mediatek/SurfaceFlingerWatchDog.cpp
+
+ifeq ($(strip $(TARGET_BUILD_VARIANT)), user)
+	LOCAL_CFLAGS += -DMTK_USER_BUILD
+endif
+
+ifeq ($(MTK_GPU_SUPPORT), yes)
+	LOCAL_CFLAGS += -DMTK_GPU_SUPPORT
+endif
+
+ifneq ($(MTK_TABLET_HARDWARE), )
+	MTK_HWC_CHIP = $(shell echo $(MTK_TABLET_HARDWARE) | tr A-Z a-z )
+else
+	MTK_HWC_CHIP = $(shell echo $(MTK_PLATFORM) | tr A-Z a-z )
+endif
+
+ifeq ($(MTK_HWC_SUPPORT), yes)
+	LOCAL_REQUIRED_MODULES += hwcomposer.$(MTK_HWC_CHIP)
+endif
+
+ifeq ($(MTK_HWC_SUPPORT_V0), yes)
+	LOCAL_CFLAGS += -DMTK_HWC_SUPPORT_V0
+	LOCAL_REQUIRED_MODULES += hwcomposer.$(MTK_HWC_CHIP)
+endif
+
+ifeq ($(MTK_TRIPLE_FRAMEBUFFER_SUPPORT),yes)
+	LOCAL_CFLAGS += -DNUM_FRAMEBUFFER_SURFACE_BUFFERS=3
+endif
+
+LOCAL_SHARED_LIBRARIES += libskia
+
+LOCAL_C_INCLUDES := \
+	$(TOP)/$(MTK_ROOT)/hardware/mmumapper \
+	external/skia/include/core \
+	external/skia/include/images
+# ----------------------------------------------------------------------------
+
 LOCAL_MODULE:= libsurfaceflinger
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/frameworks/native/services/surfaceflinger/DisplayDevice.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayDevice.cpp
index ce98b67..7654694 100644
--- a/frameworks/native/services/surfaceflinger/DisplayDevice.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayDevice.cpp
@@ -44,6 +44,10 @@
 #include "SurfaceFlinger.h"
 #include "LayerBase.h"
 
+// [MTK] {{{
+#include "LayerScreenshot.h"
+// [MTK] }}}
+
 // ----------------------------------------------------------------------------
 using namespace android;
 // ----------------------------------------------------------------------------
@@ -152,11 +156,31 @@ void DisplayDevice::init(EGLConfig config)
     // get an h/w composer ID
     mHwcDisplayId = mFlinger->allocateHwcDisplayId(mType);
 
+    // [MTK] {{{
+    mLayersSwapRequired = false;
+    mHwOrientation = DisplayState::eOrientationDefault;
+    // [MTK] }}}
+
     // Name the display.  The name will be replaced shortly if the display
     // was created with createDisplay().
     switch (mType) {
         case DISPLAY_PRIMARY:
             mDisplayName = "Built-in Screen";
+            // [MTK] {{{
+            char value[PROPERTY_VALUE_MAX];
+            property_get("ro.sf.hwrotation", value, "0");
+            switch (atoi(value)) {
+                case 90:
+                    mHwOrientation = DisplayState::eOrientation90;
+                    break;
+                case 180:
+                    mHwOrientation = DisplayState::eOrientation180;
+                    break;
+                case 270:
+                    mHwOrientation = DisplayState::eOrientation270;
+                    break;
+            }
+            // [MTK] }}}
             break;
         case DISPLAY_EXTERNAL:
             mDisplayName = "HDMI Screen";
@@ -223,7 +247,12 @@ void DisplayDevice::swapBuffers(HWComposer& hwc) const {
             // as of hwc 1.1 we always call eglSwapBuffers if we have some
             // GLES layers
             if (hwc.hasGlesComposition(mType)) {
-                success = eglSwapBuffers(mDisplay, mSurface);
+                // [MTK] {{{
+                // layer swap applied for HWC 1.1 and later
+                if (mLayersSwapRequired || LayerScreenshot::getCount() > 0) {
+                    success = eglSwapBuffers(mDisplay, mSurface);
+                }
+                // [MTK] }}}
             }
         } else {
             // HWC doesn't have the framebuffer target, we don't call
@@ -386,6 +415,13 @@ void DisplayDevice::updateGeometryTransform() {
             // the destination frame can be invalid if it has never been set,
             // in that case we assume the whole display frame.
             frame = Rect(w, h);
+
+            // [MTK] {{{
+            if (mHwOrientation == DisplayState::eOrientation90 ||
+                mHwOrientation == DisplayState::eOrientation270) {
+                swap(frame.right, frame.bottom);
+            }
+            // [MTK] }}}
         }
 
         if (viewport.isEmpty()) {
@@ -434,12 +470,12 @@ void DisplayDevice::dump(String8& result, char* buffer, size_t SIZE) const {
     snprintf(buffer, SIZE,
         "+ DisplayDevice: %s\n"
         "   type=%x, layerStack=%u, (%4dx%4d), ANativeWindow=%p, orient=%2d (type=%08x), "
-        "flips=%u, isSecure=%d, secureVis=%d, acquired=%d, numLayers=%u\n"
+        "hw_orient=%2d, flips=%u, isSecure=%d, secureVis=%d, acquired=%d, numLayers=%u\n"
         "   v:[%d,%d,%d,%d], f:[%d,%d,%d,%d], "
         "transform:[[%0.3f,%0.3f,%0.3f][%0.3f,%0.3f,%0.3f][%0.3f,%0.3f,%0.3f]]\n",
         mDisplayName.string(), mType,
         mLayerStack, mDisplayWidth, mDisplayHeight, mNativeWindow.get(),
-        mOrientation, tr.getType(), getPageFlipCount(),
+        mOrientation, tr.getType(), mHwOrientation, getPageFlipCount(),
         mIsSecure, mSecureLayerVisible, mScreenAcquired, mVisibleLayersSortedByZ.size(),
         mViewport.left, mViewport.top, mViewport.right, mViewport.bottom,
         mFrame.left, mFrame.top, mFrame.right, mFrame.bottom,
diff --git a/frameworks/native/services/surfaceflinger/DisplayDevice.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayDevice.h
index d6da422..296afbd 100644
--- a/frameworks/native/services/surfaceflinger/DisplayDevice.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayDevice.h
@@ -204,6 +204,17 @@ private:
     Rect mFrame;
     Transform mGlobalTransform;
     bool mNeedsFiltering;
+
+    // [MTK] {{{
+private:
+    int mHwOrientation;
+
+public:
+    int getHwOrientation() const { return mHwOrientation; }
+
+    // for lazy swap
+    mutable bool mLayersSwapRequired;
+    // [MTK] }}}
 };
 
 }; // namespace android
diff --git a/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
new file mode 100644
index 0000000..d0983c1
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
@@ -0,0 +1,501 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+
+#include <cutils/properties.h>
+
+#include <utils/RefBase.h>
+#include <utils/Log.h>
+
+#include <ui/PixelFormat.h>
+#include <ui/FramebufferNativeWindow.h>
+
+#include <GLES/gl.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+
+#include "DisplayHardware/DisplayHardware.h"
+
+#include <hardware/gralloc.h>
+
+#include "DisplayHardwareBase.h"
+#include "GLExtensions.h"
+#include "HWComposer.h"
+#include "SurfaceFlinger.h"
+
+using namespace android;
+
+
+static __attribute__((noinline))
+void checkGLErrors()
+{
+    do {
+        // there could be more than one error flag
+        GLenum error = glGetError();
+        if (error == GL_NO_ERROR)
+            break;
+        ALOGE("GL error 0x%04x", int(error));
+    } while(true);
+}
+
+static __attribute__((noinline))
+void checkEGLErrors(const char* token)
+{
+    struct EGLUtils {
+        static const char *strerror(EGLint err) {
+            switch (err){
+                case EGL_SUCCESS:           return "EGL_SUCCESS";
+                case EGL_NOT_INITIALIZED:   return "EGL_NOT_INITIALIZED";
+                case EGL_BAD_ACCESS:        return "EGL_BAD_ACCESS";
+                case EGL_BAD_ALLOC:         return "EGL_BAD_ALLOC";
+                case EGL_BAD_ATTRIBUTE:     return "EGL_BAD_ATTRIBUTE";
+                case EGL_BAD_CONFIG:        return "EGL_BAD_CONFIG";
+                case EGL_BAD_CONTEXT:       return "EGL_BAD_CONTEXT";
+                case EGL_BAD_CURRENT_SURFACE: return "EGL_BAD_CURRENT_SURFACE";
+                case EGL_BAD_DISPLAY:       return "EGL_BAD_DISPLAY";
+                case EGL_BAD_MATCH:         return "EGL_BAD_MATCH";
+                case EGL_BAD_NATIVE_PIXMAP: return "EGL_BAD_NATIVE_PIXMAP";
+                case EGL_BAD_NATIVE_WINDOW: return "EGL_BAD_NATIVE_WINDOW";
+                case EGL_BAD_PARAMETER:     return "EGL_BAD_PARAMETER";
+                case EGL_BAD_SURFACE:       return "EGL_BAD_SURFACE";
+                case EGL_CONTEXT_LOST:      return "EGL_CONTEXT_LOST";
+                default: return "UNKNOWN";
+            }
+        }
+    };
+
+    EGLint error = eglGetError();
+    if (error && error != EGL_SUCCESS) {
+        ALOGE("%s: EGL error 0x%04x (%s)",
+                token, int(error), EGLUtils::strerror(error));
+    }
+}
+
+/*
+ * Initialize the display to the specified values.
+ *
+ */
+
+DisplayHardware::DisplayHardware(
+        const sp<SurfaceFlinger>& flinger,
+        uint32_t dpy)
+    : DisplayHardwareBase(flinger, dpy),
+      mFlinger(flinger), mFlags(0), mHwc(0)
+{
+    init(dpy);
+}
+
+DisplayHardware::~DisplayHardware()
+{
+    fini();
+}
+
+float DisplayHardware::getDpiX() const          { return mDpiX; }
+float DisplayHardware::getDpiY() const          { return mDpiY; }
+float DisplayHardware::getDensity() const       { return mDensity; }
+float DisplayHardware::getRefreshRate() const   { return mRefreshRate; }
+int DisplayHardware::getWidth() const           { return mWidth; }
+int DisplayHardware::getHeight() const          { return mHeight; }
+PixelFormat DisplayHardware::getFormat() const  { return mFormat; }
+uint32_t DisplayHardware::getMaxTextureSize() const { return mMaxTextureSize; }
+
+uint32_t DisplayHardware::getMaxViewportDims() const {
+    return mMaxViewportDims[0] < mMaxViewportDims[1] ?
+            mMaxViewportDims[0] : mMaxViewportDims[1];
+}
+
+static status_t selectConfigForPixelFormat(
+        EGLDisplay dpy,
+        EGLint const* attrs,
+        PixelFormat format,
+        EGLConfig* outConfig)
+{
+    EGLConfig config = NULL;
+    EGLint numConfigs = -1, n=0;
+    eglGetConfigs(dpy, NULL, 0, &numConfigs);
+    EGLConfig* const configs = new EGLConfig[numConfigs];
+    eglChooseConfig(dpy, attrs, configs, numConfigs, &n);
+    for (int i=0 ; i<n ; i++) {
+        EGLint nativeVisualId = 0;
+        eglGetConfigAttrib(dpy, configs[i], EGL_NATIVE_VISUAL_ID, &nativeVisualId);
+        if (nativeVisualId>0 && format == nativeVisualId) {
+            *outConfig = configs[i];
+            delete [] configs;
+            return NO_ERROR;
+        }
+    }
+    delete [] configs;
+    return NAME_NOT_FOUND;
+}
+
+
+void DisplayHardware::init(uint32_t dpy)
+{
+    mNativeWindow = new FramebufferNativeWindow();
+    framebuffer_device_t const * fbDev = mNativeWindow->getDevice();
+    if (!fbDev) {
+        ALOGE("Display subsystem failed to initialize. check logs. exiting...");
+        exit(0);
+    }
+
+    int format;
+    ANativeWindow const * const window = mNativeWindow.get();
+    window->query(window, NATIVE_WINDOW_FORMAT, &format);
+    mDpiX = mNativeWindow->xdpi;
+    mDpiY = mNativeWindow->ydpi;
+    mRefreshRate = fbDev->fps;
+
+    if (mDpiX == 0 || mDpiY == 0) {
+        ALOGE("invalid screen resolution from fb HAL (xdpi=%f, ydpi=%f), "
+               "defaulting to 160 dpi", mDpiX, mDpiY);
+        mDpiX = mDpiY = 160;
+    }
+
+    class Density {
+        static int getDensityFromProperty(char const* propName) {
+            char property[PROPERTY_VALUE_MAX];
+            int density = 0;
+            if (property_get(propName, property, NULL) > 0) {
+                density = atoi(property);
+            }
+            return density;
+        }
+    public:
+        static int getEmuDensity() {
+            return getDensityFromProperty("qemu.sf.lcd_density"); }
+        static int getBuildDensity()  {
+            return getDensityFromProperty("ro.sf.lcd_density"); }
+    };
+
+
+    // The density of the device is provided by a build property
+    mDensity = Density::getBuildDensity() / 160.0f;
+
+    if (mDensity == 0) {
+        // the build doesn't provide a density -- this is wrong!
+        // use xdpi instead
+        ALOGE("ro.sf.lcd_density must be defined as a build property");
+        mDensity = mDpiX / 160.0f;
+    }
+
+    if (Density::getEmuDensity()) {
+        // if "qemu.sf.lcd_density" is specified, it overrides everything
+        mDpiX = mDpiY = mDensity = Density::getEmuDensity();
+        mDensity /= 160.0f;
+    }
+
+
+
+    /* FIXME: this is a temporary HACK until we are able to report the refresh rate
+     * properly from the HAL. The WindowManagerService now relies on this value.
+     */
+#ifndef REFRESH_RATE
+    mRefreshRate = fbDev->fps;
+#else
+    mRefreshRate = REFRESH_RATE;
+#warning "refresh rate set via makefile to REFRESH_RATE"
+#endif
+
+    mRefreshPeriod = nsecs_t(1e9 / mRefreshRate);
+
+    EGLint w, h, dummy;
+    EGLint numConfigs=0;
+    EGLSurface surface;
+    EGLContext context;
+    EGLBoolean result;
+    status_t err;
+
+    // initialize EGL
+    EGLint attribs[] = {
+            EGL_SURFACE_TYPE,       EGL_WINDOW_BIT,
+            EGL_NONE,               0,
+            EGL_NONE
+    };
+
+    // debug: disable h/w rendering
+    char property[PROPERTY_VALUE_MAX];
+    if (property_get("debug.sf.hw", property, NULL) > 0) {
+        if (atoi(property) == 0) {
+            ALOGW("H/W composition disabled");
+            attribs[2] = EGL_CONFIG_CAVEAT;
+            attribs[3] = EGL_SLOW_CONFIG;
+        }
+    }
+
+    // TODO: all the extensions below should be queried through
+    // eglGetProcAddress().
+
+    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    eglInitialize(display, NULL, NULL);
+    eglGetConfigs(display, NULL, 0, &numConfigs);
+
+    EGLConfig config = NULL;
+    err = selectConfigForPixelFormat(display, attribs, format, &config);
+    // [MTK] {{{
+    ALOGE_IF(err, "couldn't find an EGLConfig matching the screen format(%d)", format);
+    // [MTK] }}}
+    
+    EGLint r,g,b,a;
+    eglGetConfigAttrib(display, config, EGL_RED_SIZE,   &r);
+    eglGetConfigAttrib(display, config, EGL_GREEN_SIZE, &g);
+    eglGetConfigAttrib(display, config, EGL_BLUE_SIZE,  &b);
+    eglGetConfigAttrib(display, config, EGL_ALPHA_SIZE, &a);
+
+    if (mNativeWindow->isUpdateOnDemand()) {
+        mFlags |= PARTIAL_UPDATES;
+    }
+    
+    if (eglGetConfigAttrib(display, config, EGL_CONFIG_CAVEAT, &dummy) == EGL_TRUE) {
+        if (dummy == EGL_SLOW_CONFIG)
+            mFlags |= SLOW_CONFIG;
+    }
+
+    /*
+     * Create our main surface
+     */
+
+    surface = eglCreateWindowSurface(display, config, mNativeWindow.get(), NULL);
+    eglQuerySurface(display, surface, EGL_WIDTH,  &mWidth);
+    eglQuerySurface(display, surface, EGL_HEIGHT, &mHeight);
+
+    if (mFlags & PARTIAL_UPDATES) {
+        // if we have partial updates, we definitely don't need to
+        // preserve the backbuffer, which may be costly.
+        eglSurfaceAttrib(display, surface,
+                EGL_SWAP_BEHAVIOR, EGL_BUFFER_DESTROYED);
+    }
+
+    /*
+     * Create our OpenGL ES context
+     */
+    
+    EGLint contextAttributes[] = {
+#ifdef EGL_IMG_context_priority
+#ifdef HAS_CONTEXT_PRIORITY
+#warning "using EGL_IMG_context_priority"
+        EGL_CONTEXT_PRIORITY_LEVEL_IMG, EGL_CONTEXT_PRIORITY_HIGH_IMG,
+#endif
+#endif
+        EGL_NONE, EGL_NONE
+    };
+    context = eglCreateContext(display, config, NULL, contextAttributes);
+
+    mDisplay = display;
+    mConfig  = config;
+    mSurface = surface;
+    mContext = context;
+    mFormat  = fbDev->format;
+    mPageFlipCount = 0;
+
+    /*
+     * Gather OpenGL ES extensions
+     */
+
+    result = eglMakeCurrent(display, surface, surface, context);
+    if (!result) {
+        ALOGE("Couldn't create a working GLES context. check logs. exiting...");
+        exit(0);
+    }
+
+    GLExtensions& extensions(GLExtensions::getInstance());
+    extensions.initWithGLStrings(
+            glGetString(GL_VENDOR),
+            glGetString(GL_RENDERER),
+            glGetString(GL_VERSION),
+            glGetString(GL_EXTENSIONS),
+            eglQueryString(display, EGL_VENDOR),
+            eglQueryString(display, EGL_VERSION),
+            eglQueryString(display, EGL_EXTENSIONS));
+
+    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &mMaxTextureSize);
+    glGetIntegerv(GL_MAX_VIEWPORT_DIMS, mMaxViewportDims);
+
+    ALOGI("EGL informations:");
+    ALOGI("# of configs : %d", numConfigs);
+    ALOGI("vendor    : %s", extensions.getEglVendor());
+    ALOGI("version   : %s", extensions.getEglVersion());
+    ALOGI("extensions: %s", extensions.getEglExtension());
+    ALOGI("Client API: %s", eglQueryString(display, EGL_CLIENT_APIS)?:"Not Supported");
+    ALOGI("EGLSurface: %d-%d-%d-%d, config=%p", r, g, b, a, config);
+
+    ALOGI("OpenGL informations:");
+    ALOGI("vendor    : %s", extensions.getVendor());
+    ALOGI("renderer  : %s", extensions.getRenderer());
+    ALOGI("version   : %s", extensions.getVersion());
+    ALOGI("extensions: %s", extensions.getExtension());
+    ALOGI("GL_MAX_TEXTURE_SIZE = %d", mMaxTextureSize);
+    ALOGI("GL_MAX_VIEWPORT_DIMS = %d x %d", mMaxViewportDims[0], mMaxViewportDims[1]);
+    ALOGI("flags = %08x", mFlags);
+
+    // Unbind the context from this thread
+    eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+
+
+    // initialize the H/W composer
+    mHwc = new HWComposer(mFlinger, *this, mRefreshPeriod);
+    if (mHwc->initCheck() == NO_ERROR) {
+        mHwc->setFrameBuffer(mDisplay, mSurface);
+    }
+
+    // [MTK] {{{
+    // 20120903: add to get accurate fps
+    nsecs_t period;
+    mHwc->getRefreshPeriod(&period);
+    if (period != mRefreshPeriod) {
+        mRefreshPeriod = period;
+        mRefreshRate = float(1e9 / mRefreshPeriod);
+        ALOGD("Use accurate FPS(%f, %lld)", mRefreshRate, mRefreshPeriod);
+    } else {
+        ALOGD("Use default FPS(%f, %lld)", mRefreshRate, mRefreshPeriod);
+    }
+    // [MTK] }}}
+}
+
+void DisplayHardware::setVSyncHandler(const sp<VSyncHandler>& handler) {
+    Mutex::Autolock _l(mLock);
+    mVSyncHandler = handler;
+}
+
+void DisplayHardware::eventControl(int event, int enabled) {
+    if (event == EVENT_VSYNC) {
+        mPowerHAL.vsyncHint(enabled);
+    }
+    mHwc->eventControl(event, enabled);
+}
+
+void DisplayHardware::onVSyncReceived(int dpy, nsecs_t timestamp) {
+    sp<VSyncHandler> handler;
+    { // scope for the lock
+        Mutex::Autolock _l(mLock);
+        mLastHwVSync = timestamp;
+        if (mVSyncHandler != NULL) {
+            handler = mVSyncHandler.promote();
+        }
+    }
+
+    if (handler != NULL) {
+        handler->onVSyncReceived(dpy, timestamp);
+    }
+}
+
+HWComposer& DisplayHardware::getHwComposer() const {
+    return *mHwc;
+}
+
+/*
+ * Clean up.  Throw out our local state.
+ *
+ * (It's entirely possible we'll never get here, since this is meant
+ * for real hardware, which doesn't restart.)
+ */
+
+void DisplayHardware::fini()
+{
+    // [MTK] {{{
+    // 20120807: mHwc should be deleted to avoid memory leak
+    delete mHwc;
+    // [MTK] }}}
+
+    eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    eglTerminate(mDisplay);
+}
+
+void DisplayHardware::releaseScreen() const
+{
+    DisplayHardwareBase::releaseScreen();
+    if (mHwc->initCheck() == NO_ERROR) {
+        mHwc->release();
+    }
+}
+
+void DisplayHardware::acquireScreen() const
+{
+    DisplayHardwareBase::acquireScreen();
+}
+
+uint32_t DisplayHardware::getPageFlipCount() const {
+    return mPageFlipCount;
+}
+
+nsecs_t DisplayHardware::getRefreshTimestamp() const {
+    // this returns the last refresh timestamp.
+    // if the last one is not available, we estimate it based on
+    // the refresh period and whatever closest timestamp we have.
+    Mutex::Autolock _l(mLock);
+    nsecs_t now = systemTime(CLOCK_MONOTONIC);
+    return now - ((now - mLastHwVSync) %  mRefreshPeriod);
+}
+
+nsecs_t DisplayHardware::getRefreshPeriod() const {
+    return mRefreshPeriod;
+}
+
+status_t DisplayHardware::compositionComplete() const {
+    return mNativeWindow->compositionComplete();
+}
+
+void DisplayHardware::flip(const Region& dirty) const
+{
+    checkGLErrors();
+
+    EGLDisplay dpy = mDisplay;
+    EGLSurface surface = mSurface;
+
+#ifdef EGL_ANDROID_swap_rectangle    
+    if (mFlags & SWAP_RECTANGLE) {
+        const Region newDirty(dirty.intersect(bounds()));
+        const Rect b(newDirty.getBounds());
+        eglSetSwapRectangleANDROID(dpy, surface,
+                b.left, b.top, b.width(), b.height());
+    } 
+#endif
+    
+    if (mFlags & PARTIAL_UPDATES) {
+        mNativeWindow->setUpdateRectangle(dirty.getBounds());
+    }
+    
+    mPageFlipCount++;
+
+    if (mHwc->initCheck() == NO_ERROR) {
+        mHwc->commit();
+    } else {
+        eglSwapBuffers(dpy, surface);
+    }
+    checkEGLErrors("eglSwapBuffers");
+
+    // for debugging
+    //glClearColor(1,0,0,0);
+    //glClear(GL_COLOR_BUFFER_BIT);
+}
+
+uint32_t DisplayHardware::getFlags() const
+{
+    return mFlags;
+}
+
+void DisplayHardware::makeCurrent() const
+{
+    eglMakeCurrent(mDisplay, mSurface, mSurface, mContext);
+}
+
+void DisplayHardware::dump(String8& res) const
+{
+    mNativeWindow->dump(res);
+}
diff --git a/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp
new file mode 100644
index 0000000..d3a8bde
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <utils/Log.h>
+
+#include "DisplayHardware/DisplayHardwareBase.h"
+#include "SurfaceFlinger.h"
+
+// ----------------------------------------------------------------------------
+namespace android {
+
+static char const * const kSleepFileName = "/sys/power/wait_for_fb_sleep";
+static char const * const kWakeFileName  = "/sys/power/wait_for_fb_wake";
+
+// ----------------------------------------------------------------------------
+
+DisplayHardwareBase::DisplayEventThread::DisplayEventThread(
+        const sp<SurfaceFlinger>& flinger)
+    : Thread(false), mFlinger(flinger) {
+}
+
+DisplayHardwareBase::DisplayEventThread::~DisplayEventThread() {
+}
+
+status_t DisplayHardwareBase::DisplayEventThread::initCheck() const {
+    return ((access(kSleepFileName, R_OK) == 0 &&
+            access(kWakeFileName, R_OK) == 0)) ? NO_ERROR : NO_INIT;
+}
+
+bool DisplayHardwareBase::DisplayEventThread::threadLoop() {
+
+    if (waitForFbSleep() == NO_ERROR) {
+        sp<SurfaceFlinger> flinger = mFlinger.promote();
+        ALOGD("About to give-up screen, flinger = %p", flinger.get());
+        if (flinger != 0) {
+            flinger->screenReleased();
+        }
+        if (waitForFbWake() == NO_ERROR) {
+            ALOGD("Screen about to return, flinger = %p", flinger.get());
+            if (flinger != 0) {
+                flinger->screenAcquired();
+            }
+            return true;
+        }
+    }
+
+    // error, exit the thread
+    return false;
+}
+
+status_t DisplayHardwareBase::DisplayEventThread::waitForFbSleep() {
+    int err = 0;
+    char buf;
+    int fd = open(kSleepFileName, O_RDONLY, 0);
+    // if the file doesn't exist, the error will be caught in read() below
+    do {
+        err = read(fd, &buf, 1);
+    } while (err < 0 && errno == EINTR);
+    close(fd);
+    ALOGE_IF(err<0, "*** ANDROID_WAIT_FOR_FB_SLEEP failed (%s)", strerror(errno));
+    return err < 0 ? -errno : int(NO_ERROR);
+}
+
+status_t DisplayHardwareBase::DisplayEventThread::waitForFbWake() {
+    int err = 0;
+    char buf;
+    int fd = open(kWakeFileName, O_RDONLY, 0);
+    // if the file doesn't exist, the error will be caught in read() below
+    do {
+        err = read(fd, &buf, 1);
+    } while (err < 0 && errno == EINTR);
+    close(fd);
+    ALOGE_IF(err<0, "*** ANDROID_WAIT_FOR_FB_WAKE failed (%s)", strerror(errno));
+    return err < 0 ? -errno : int(NO_ERROR);
+}
+
+// ----------------------------------------------------------------------------
+
+DisplayHardwareBase::DisplayHardwareBase(const sp<SurfaceFlinger>& flinger,
+        uint32_t displayIndex) 
+{
+    mScreenAcquired = true;
+    mDisplayEventThread = new DisplayEventThread(flinger);
+}
+
+void DisplayHardwareBase::startSleepManagement() const {
+    if (mDisplayEventThread->initCheck() == NO_ERROR) {
+        mDisplayEventThread->run("DisplayEventThread", PRIORITY_URGENT_DISPLAY);
+    } else {
+        ALOGW("/sys/power/wait_for_fb_{wake|sleep} don't exist");
+    }
+}
+
+DisplayHardwareBase::~DisplayHardwareBase() {
+    // request exit
+    mDisplayEventThread->requestExitAndWait();
+}
+
+bool DisplayHardwareBase::canDraw() const {
+    return mScreenAcquired;
+}
+
+void DisplayHardwareBase::releaseScreen() const {
+    mScreenAcquired = false;
+}
+
+void DisplayHardwareBase::acquireScreen() const {
+    mScreenAcquired = true;
+}
+
+bool DisplayHardwareBase::isScreenAcquired() const {
+    return mScreenAcquired;
+}
+
+}; // namespace android
diff --git a/frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp
index 6c86a53..f5a843a 100644
--- a/frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp
@@ -36,6 +36,17 @@
 #include "DisplayHardware/GraphicBufferAlloc.h"
 #include "DisplayHardware/HWComposer.h"
 
+// [MTK] {{{
+#include <dlfcn.h>
+#include <cutils/xlog.h>
+
+#ifdef NUM_FRAMEBUFFER_SURFACE_BUFFERS
+#define PREDEFINED_NUM_FRAMEBUFFER 1
+#else
+#define PREDEFINED_NUM_FRAMEBUFFER 0
+#endif
+// [MTK] }}}
+
 #ifndef NUM_FRAMEBUFFER_SURFACE_BUFFERS
 #define NUM_FRAMEBUFFER_SURFACE_BUFFERS (2)
 #endif
@@ -65,7 +76,42 @@ FramebufferSurface::FramebufferSurface(HWComposer& hwc, int disp) :
     mBufferQueue->setDefaultBufferFormat(mHwc.getFormat(disp));
     mBufferQueue->setDefaultBufferSize(mHwc.getWidth(disp),  mHwc.getHeight(disp));
     mBufferQueue->setSynchronousMode(true);
-    mBufferQueue->setDefaultMaxBufferCount(NUM_FRAMEBUFFER_SURFACE_BUFFERS);
+
+    // [MTK] {{{
+    // open hwinfo library
+#define SUPPORT_NUM_FRAMEBUFFER_BUFFERS 3
+
+    int bufferCount = NUM_FRAMEBUFFER_SURFACE_BUFFERS;
+
+#if !PREDEFINED_NUM_FRAMEBUFFER 
+    void* libhwinfo = dlopen("libhwinfo.so", RTLD_NOW);
+    if (libhwinfo) {
+        typedef bool (*Func)();
+        Func isHwSupport = (Func)dlsym(libhwinfo, "isHwSupport");
+        if (isHwSupport) {
+            if ((*isHwSupport)() == true) {
+                XLOGI("[hwinfo] return true");
+                bufferCount = SUPPORT_NUM_FRAMEBUFFER_BUFFERS;
+            }
+            else
+                XLOGI("[hwinfo] return false");
+        }
+        else
+            XLOGI("[hwinfo] isHwSupport() not found");
+
+        dlclose(libhwinfo);
+    }        
+    else {
+        XLOGI("[hwinfo] not found");
+    }
+
+    XLOGI("[FBS] bufferCount=%d", bufferCount);
+#else
+    XLOGI("[FBS] determine buffer count=%d", bufferCount);
+#endif    
+    // [MTK] }}}
+
+    mBufferQueue->setDefaultMaxBufferCount(bufferCount);
 }
 
 status_t FramebufferSurface::nextBuffer(sp<GraphicBuffer>& outBuffer, sp<Fence>& outFence) {
@@ -116,6 +162,12 @@ void FramebufferSurface::onFrameAvailable() {
                 strerror(-err), err);
         return;
     }
+
+    // [MTK] {{{
+    // check triple buffer
+    //ALOGD("[debug] FramebufferSurface::onFrameAvailable, ptr=%d", buf.get());
+    // [MTK] }}}
+    
     err = mHwc.fbPost(mDisplayType, acquireFence, buf);
     if (err != NO_ERROR) {
         ALOGE("error posting framebuffer: %d", err);
diff --git a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
index 31d731e..4c3aa6b 100644
--- a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
@@ -16,8 +16,14 @@
 
 #define ATRACE_TAG ATRACE_TAG_GRAPHICS
 
+// [MTK] {{{
+#ifdef MTK_HWC_SUPPORT_V0
+#define HWC_REMOVE_DEPRECATED_VERSIONS 0
+#else
 // Uncomment this to remove support for HWC_DEVICE_API_VERSION_0_3 and older
 #define HWC_REMOVE_DEPRECATED_VERSIONS 1
+#endif
+// [MTK] }}}
 
 #include <stdint.h>
 #include <stdio.h>
@@ -46,6 +52,12 @@
 #include "SurfaceFlinger.h"
 #include <utils/CallStack.h>
 
+// [MTK] {{{
+// get additional info
+#include "LayerScreenshot.h"
+#include <cutils/xlog.h>
+// [MTK] }}}
+
 namespace android {
 
 #define MIN_HWC_HEADER_VERSION 0
@@ -109,6 +121,18 @@ HWComposer::HWComposer(
 
     bool needVSyncThread = true;
 
+// [MTK] {{{
+#if !HWC_REMOVE_DEPRECATED_VERSIONS
+    needVSyncThread = initHWC_0();
+    if (mHwc_0 && mHwc_0->registerProcs) {
+        mCBContext->hwc = this;
+        mCBContext->procs.invalidate = &hook_invalidate;
+        mCBContext->procs.vsync = &hook_vsync;
+        memset(mCBContext->procs.zero, 0, sizeof(mCBContext->procs.zero));
+        mHwc_0->registerProcs(mHwc_0, &mCBContext->procs);
+    }
+#else
+// [MTK] }}}
     // Note: some devices may insist that the FB HAL be opened before HWC.
     loadFbHalModule();
     loadHwcModule();
@@ -166,6 +190,9 @@ HWComposer::HWComposer(
             mNumDisplays = 1;
         }
     }
+// [MTK] {{{
+#endif // HWC_REMOVE_DEPRECATED_VERSIONS
+// [MTK] }}}
 
     if (mFbDev) {
         ALOG_ASSERT(!(mHwc && hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)),
@@ -178,6 +205,12 @@ HWComposer::HWComposer(
         disp.format = mFbDev->format;
         disp.xdpi = mFbDev->xdpi;
         disp.ydpi = mFbDev->ydpi;
+
+        // [MTK] {{{
+        // 20120903: add to get accurate fps
+        disp.refresh = getRefreshPeriod();
+        // [MTK] }}}
+        
         if (disp.refresh == 0) {
             disp.refresh = nsecs_t(1e9 / mFbDev->fps);
             ALOGW("getting VSYNC period from fb HAL: %lld", disp.refresh);
@@ -201,6 +234,11 @@ HWComposer::HWComposer(
 }
 
 HWComposer::~HWComposer() {
+// [MTK] {{{
+#if !HWC_REMOVE_DEPRECATED_VERSIONS
+    deinitHWC_0();
+#else
+// [MTK] }}}
     if (mHwc) {
         eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0);
     }
@@ -210,6 +248,9 @@ HWComposer::~HWComposer() {
     if (mHwc) {
         hwc_close_1(mHwc);
     }
+// [MTK] {{{
+#endif // HWC_REMOVE_DEPRECATED_VERSIONS
+// [MTK] }}}
     if (mFbDev) {
         framebuffer_close(mFbDev);
     }
@@ -262,6 +303,11 @@ void HWComposer::loadFbHalModule()
 }
 
 status_t HWComposer::initCheck() const {
+// [MTK] {{{
+#if !HWC_REMOVE_DEPRECATED_VERSIONS
+    return mHwc_0 ? NO_ERROR : NO_INIT;
+#endif
+// [MTK] }}}
     return mHwc ? NO_ERROR : NO_INIT;
 }
 
@@ -444,6 +490,12 @@ bool HWComposer::isConnected(int disp) const {
 }
 
 void HWComposer::eventControl(int disp, int event, int enabled) {
+// [MTK] {{{
+#if !HWC_REMOVE_DEPRECATED_VERSIONS
+    eventControl_0(disp, event, enabled);
+    return;
+#endif
+// [MTK] }}}
     if (uint32_t(disp)>31 || !mAllocatedDisplayIDs.hasBit(disp)) {
         ALOGD("eventControl ignoring event %d on unallocated disp %d (en=%d)",
               event, disp, enabled);
@@ -484,6 +536,11 @@ void HWComposer::eventControl(int disp, int event, int enabled) {
 }
 
 status_t HWComposer::createWorkList(int32_t id, size_t numLayers) {
+// [MTK] {{{
+#if !HWC_REMOVE_DEPRECATED_VERSIONS
+    return createWorkList_0(id, numLayers);
+#endif
+// [MTK] }}}
     if (uint32_t(id)>31 || !mAllocatedDisplayIDs.hasBit(id)) {
         return BAD_INDEX;
     }
@@ -518,6 +575,14 @@ status_t HWComposer::createWorkList(int32_t id, size_t numLayers) {
                 &disp.framebufferTarget->displayFrame;
             disp.framebufferTarget->acquireFenceFd = -1;
             disp.framebufferTarget->releaseFenceFd = -1;
+            // [MTK] {{{
+            disp.framebufferTarget->ext.connectApi = -1;
+            disp.framebufferTarget->ext.identity = -1;
+            disp.framebufferTarget->ext.width = disp.width;
+            disp.framebufferTarget->ext.height = disp.height;
+            disp.framebufferTarget->ext.stride = disp.width;
+            disp.framebufferTarget->ext.format = disp.format;
+            // [MTK] }}}
         }
         disp.list->retireFenceFd = -1;
         disp.list->flags = HWC_GEOMETRY_CHANGED;
@@ -552,10 +617,22 @@ status_t HWComposer::setFramebufferTarget(int32_t id,
     disp.fbTargetHandle = buf->handle;
     disp.framebufferTarget->handle = disp.fbTargetHandle;
     disp.framebufferTarget->acquireFenceFd = acquireFenceFd;
+    // [MTK] {{{
+    disp.framebufferTarget->ext.width = buf->width;
+    disp.framebufferTarget->ext.height = buf->height;
+    disp.framebufferTarget->ext.stride = buf->stride;
+    disp.framebufferTarget->ext.format = buf->format;
+    // [MTK] }}}
     return NO_ERROR;
 }
 
 status_t HWComposer::prepare() {
+// [MTK] {{{
+    ATRACE_CALL();
+#if !HWC_REMOVE_DEPRECATED_VERSIONS
+    return prepare_0();
+#endif
+// [MTK] }}}
     for (size_t i=0 ; i<mNumDisplays ; i++) {
         DisplayData& disp(mDisplayData[i]);
         if (disp.framebufferTarget) {
@@ -572,6 +649,11 @@ status_t HWComposer::prepare() {
         }
         mLists[i] = disp.list;
         if (mLists[i]) {
+            // [MTK] {{{
+            if (LayerScreenshot::getCount() > 0) {
+                mLists[i]->flags |= HWC_LAYERSCREENSHOT_EXIST;
+            }
+            // [MTK] }}}
             if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_2)) {
                 mLists[i]->outbuf = NULL;
                 mLists[i]->outbufAcquireFenceFd = -1;
@@ -582,6 +664,20 @@ status_t HWComposer::prepare() {
             } else {
                 mLists[i]->dpy = EGL_NO_DISPLAY;
                 mLists[i]->sur = EGL_NO_SURFACE;
+
+                // [MTK] {{{
+                // External Display related
+                // (only need for HWC_DEVICE_API_VERSION_1_0 or lower version)
+                if (i == 0) {
+                    // only set in main display
+                    if (LayerScreenshot::isFrozen()) {
+                        mLists[i]->flags |= HWC_SCREEN_FROZEN;
+                    }
+
+                    sp<const DisplayDevice> hw(mFlinger->getDefaultDisplayDevice());
+                    mLists[i]->flags |= hw->getOrientation() << 16;
+                }
+                // [MTK] }}}
             }
         }
     }
@@ -649,6 +745,12 @@ int HWComposer::getAndResetReleaseFenceFd(int32_t id) {
 }
 
 status_t HWComposer::commit() {
+// [MTK] {{{
+    ATRACE_CALL();
+#if !HWC_REMOVE_DEPRECATED_VERSIONS
+    return commit_0();
+#endif
+// [MTK] }}}
     int err = NO_ERROR;
     if (mHwc) {
         if (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) {
@@ -659,6 +761,16 @@ status_t HWComposer::commit() {
             mLists[0]->sur = eglGetCurrentSurface(EGL_DRAW);
         }
 
+        // [MTK] {{{
+        // get layer swap information and raise flag if necessary
+        for (size_t i=0 ; i<mNumDisplays ; i++) {
+            DisplayData& disp(mDisplayData[i]);
+            if (disp.list && mFlinger->getAndClearLayersSwapRequired(i)) {
+                disp.list->flags |= HWC_SWAP_REQUIRED;
+            }
+        }
+        // [MTK] }}}
+
         err = mHwc->set(mHwc, mNumDisplays, mLists);
 
         for (size_t i=0 ; i<mNumDisplays ; i++) {
@@ -669,6 +781,13 @@ status_t HWComposer::commit() {
                     disp.list->retireFenceFd = -1;
                 }
                 disp.list->flags &= ~HWC_GEOMETRY_CHANGED;
+
+                // [MTK] {{{
+                // clear additional flags
+                disp.list->flags &=
+                    ~(HWC_SWAP_REQUIRED | HWC_LAYERSCREENSHOT_EXIST |
+                      HWC_SCREEN_FROZEN | HWC_ORIENTATION_MASK);
+                // [MTK] }}}
             }
         }
     }
@@ -677,6 +796,11 @@ status_t HWComposer::commit() {
 
 status_t HWComposer::release(int disp) {
     LOG_FATAL_IF(disp >= HWC_NUM_DISPLAY_TYPES);
+// [MTK] {{{
+#if !HWC_REMOVE_DEPRECATED_VERSIONS
+    return release_0(disp);
+#endif
+// [MTK] }}}
     if (mHwc) {
         eventControl(disp, HWC_EVENT_VSYNC, 0);
         return (status_t)mHwc->blank(mHwc, disp, 1);
@@ -712,8 +836,8 @@ int HWComposer::getVisualID() const {
         // FIXME: temporary hack until HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED
         // is supported by the implementation. we can only be in this case
         // if we have HWC 1.1
-        return HAL_PIXEL_FORMAT_RGBA_8888;
-        //return HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED;
+        //return HAL_PIXEL_FORMAT_RGBA_8888;
+        return HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED;
     } else {
         return mFbDev->format;
     }
@@ -803,7 +927,9 @@ public:
     virtual void setAcquireFenceFd(int fenceFd) {
         getLayer()->acquireFenceFd = fenceFd;
     }
-
+    virtual void setPerFrameDefaultState() {
+        //getLayer()->compositionType = HWC_FRAMEBUFFER;
+    }
     virtual void setDefaultState() {
         getLayer()->compositionType = HWC_FRAMEBUFFER;
         getLayer()->hints = 0;
@@ -815,6 +941,15 @@ public:
         getLayer()->visibleRegionScreen.rects = NULL;
         getLayer()->acquireFenceFd = -1;
         getLayer()->releaseFenceFd = -1;
+
+        // [MTK] {{{
+        getLayer()->ext.connectApi = -1;
+        getLayer()->ext.identity = -1;
+        getLayer()->ext.width = 0;
+        getLayer()->ext.height = 0;
+        getLayer()->ext.stride = 0;
+        getLayer()->ext.format = 0;
+        // [MTK] }}}
     }
     virtual void setSkip(bool skip) {
         if (skip) {
@@ -850,6 +985,13 @@ public:
             getLayer()->handle = 0;
         } else {
             getLayer()->handle = buffer->handle;
+            // [MTK] {{{
+            getLayer()->ext.width = buffer->width;
+            getLayer()->ext.height = buffer->height;
+            getLayer()->ext.stride = buffer->stride;
+            getLayer()->ext.format = buffer->format;
+            getLayer()->ext.mva = buffer->getMva();
+            // [MTK] }}}
         }
     }
     virtual void onDisplayed() {
@@ -864,12 +1006,56 @@ public:
 
         getLayer()->acquireFenceFd = -1;
     }
+
+    // [MTK] {{{
+    virtual int getMva() {
+        return getLayer()->ext.mva;
+    }
+    virtual void setLayerType(uint32_t type) {
+    }
+    virtual void setSecure(bool secure) {
+        if (secure)
+            getLayer()->flags |= HWC_SECURE_LAYER;
+        else
+            getLayer()->flags &= ~HWC_SECURE_LAYER;
+    }
+    virtual void setDirty(bool dirty) {
+        if (dirty)
+            getLayer()->flags |= HWC_DIRTY_LAYER;
+        else
+            getLayer()->flags &= ~HWC_DIRTY_LAYER;
+    }
+    virtual void setConnectedApi(int32_t api) {
+        getLayer()->ext.connectApi = api;
+    }
+    virtual void setIdentity(int32_t id) {
+        getLayer()->ext.identity = id;
+    }
+    virtual void setFillColor(struct hwc_color color) {
+        getLayer()->ext.fillColor = color;
+    }
+    virtual void setMatrix(const Transform& tr) {
+        float *m = getLayer()->ext.transformMatrix;
+        for (int i = 0, j = 0; i < 9; i += 3, j++) {
+            m[i + 0] = tr[0][j];
+            m[i + 1] = tr[1][j];
+            m[i + 2] = tr[2][j];
+        }
+    }
+    virtual void setStereosFlags(uint32_t flag) {
+    }
+    // [MTK] }}}
 };
 
 /*
  * returns an iterator initialized at a given index in the layer list
  */
 HWComposer::LayerListIterator HWComposer::getLayerIterator(int32_t id, size_t index) {
+// [MTK] {{{
+#if !HWC_REMOVE_DEPRECATED_VERSIONS
+    return getLayerIterator_0(id, index);
+#endif
+// [MTK] }}}
     if (uint32_t(id)>31 || !mAllocatedDisplayIDs.hasBit(id)) {
         return LayerListIterator();
     }
@@ -891,6 +1077,11 @@ HWComposer::LayerListIterator HWComposer::begin(int32_t id) {
  * returns an iterator on the end of the layer list
  */
 HWComposer::LayerListIterator HWComposer::end(int32_t id) {
+// [MTK] {{{
+#if !HWC_REMOVE_DEPRECATED_VERSIONS
+    return end_0(id);
+#endif
+// [MTK] }}}
     size_t numLayers = 0;
     if (uint32_t(id) <= 31 && mAllocatedDisplayIDs.hasBit(id)) {
         const DisplayData& disp(mDisplayData[id]);
@@ -910,6 +1101,11 @@ HWComposer::LayerListIterator HWComposer::end(int32_t id) {
 }
 
 void HWComposer::dump(String8& result, char* buffer, size_t SIZE) const {
+// [MTK] {{{
+#if !HWC_REMOVE_DEPRECATED_VERSIONS
+    dump_0(result, buffer, SIZE);
+#endif
+// [MTK] }}}
     if (mHwc) {
         result.appendFormat("Hardware Composer state (version %8x):\n", hwcApiVersion(mHwc));
         result.appendFormat("  mDebugForceFakeVSync=%d\n", mDebugForceFakeVSync);
@@ -931,9 +1127,9 @@ void HWComposer::dump(String8& result, char* buffer, size_t SIZE) const {
                         disp.list->numHwLayers, disp.list->flags);
 
                 result.append(
-                        "    type    |  handle  |   hints  |   flags  | tr | blend |  format  |       source crop         |           frame           name \n"
-                        "------------+----------+----------+----------+----+-------+----------+---------------------------+--------------------------------\n");
-                //      " __________ | ________ | ________ | ________ | __ | _____ | ________ | [_____,_____,_____,_____] | [_____,_____,_____,_____]
+                        "    type    | ovl |  handle  |   hints  |   flags  | tr | blend |  format  |       source crop         |           frame           name \n"
+                        "------------+-----+----------+----------+----------+----+-------+----------+---------------------------+--------------------------------\n");
+                //      " __________ | ___ | ________ | ________ | ________ | __ | _____ | ________ | [_____,_____,_____,_____] | [_____,_____,_____,_____]
                 for (size_t i=0 ; i<disp.list->numHwLayers ; i++) {
                     const hwc_layer_1_t&l = disp.list->hwLayers[i];
                     int32_t format = -1;
@@ -967,8 +1163,8 @@ void HWComposer::dump(String8& result, char* buffer, size_t SIZE) const {
                         type = NELEM(compositionTypeName) - 1;
 
                     result.appendFormat(
-                            " %10s | %08x | %08x | %08x | %02x | %05x | %08x | [%5d,%5d,%5d,%5d] | [%5d,%5d,%5d,%5d] %s\n",
-                                    compositionTypeName[type],
+                            " %10s | %3s | %08x | %08x | %08x | %02x | %05x | %08x | [%5d,%5d,%5d,%5d] | [%5d,%5d,%5d,%5d] %s\n",
+                                    compositionTypeName[type], l.ext.overlayType,
                                     intptr_t(l.handle), l.hints, l.flags, l.transform, l.blending, format,
                                     l.sourceCrop.left, l.sourceCrop.top, l.sourceCrop.right, l.sourceCrop.bottom,
                                     l.displayFrame.left, l.displayFrame.top, l.displayFrame.right, l.displayFrame.bottom,
@@ -982,6 +1178,13 @@ void HWComposer::dump(String8& result, char* buffer, size_t SIZE) const {
         mHwc->dump(mHwc, buffer, SIZE);
         result.append(buffer);
     }
+
+    // [MTK] {{{
+    // 20120814: add property function for debug purpose
+    if (mVSyncThread != NULL) {
+        mVSyncThread->setProperty();
+    }
+    // [MTK] }}}
 }
 
 // ---------------------------------------------------------------------------
diff --git a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h
index a78ffac..a76142d 100644
--- a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h
@@ -40,6 +40,26 @@ struct hwc_layer_1;
 struct hwc_procs;
 struct framebuffer_device_t;
 
+// [MTK] {{{
+#include "Transform.h"
+
+#ifndef HWC_REMOVE_DEPRECATED_VERSIONS
+#ifdef MTK_HWC_SUPPORT_V0
+#define HWC_REMOVE_DEPRECATED_VERSIONS 0
+#else
+#define HWC_REMOVE_DEPRECATED_VERSIONS 1
+#endif // MTK_HWC_SUPPORT_V0
+#endif // HWC_REMOVE_DEPRECATED_VERSIONS
+
+#if !HWC_REMOVE_DEPRECATED_VERSIONS
+struct hwc_composer_device;
+struct hwc_layer_list;
+struct hwc_layer;
+#endif
+
+struct hwc_color;
+// [MTK] }}}
+
 namespace android {
 // ---------------------------------------------------------------------------
 
@@ -141,6 +161,7 @@ public:
         virtual int32_t getCompositionType() const = 0;
         virtual uint32_t getHints() const = 0;
         virtual int getAndResetReleaseFenceFd() = 0;
+        virtual void setPerFrameDefaultState() = 0;
         virtual void setDefaultState() = 0;
         virtual void setSkip(bool skip) = 0;
         virtual void setBlending(uint32_t blending) = 0;
@@ -151,6 +172,18 @@ public:
         virtual void setBuffer(const sp<GraphicBuffer>& buffer) = 0;
         virtual void setAcquireFenceFd(int fenceFd) = 0;
         virtual void onDisplayed() = 0;
+
+        // [MTK] {{{
+        virtual int getMva() = 0;
+        virtual void setLayerType(uint32_t type) = 0;
+        virtual void setSecure(bool secure) = 0;
+        virtual void setDirty(bool dirty) = 0;
+        virtual void setConnectedApi(int32_t api) = 0;
+        virtual void setIdentity(int32_t id) = 0;
+        virtual void setFillColor(struct hwc_color color) = 0;
+        virtual void setMatrix(const Transform& tr) = 0;
+        virtual void setStereosFlags(uint32_t flag) = 0;
+        // [MTK] }}}
     };
 
     /*
@@ -253,6 +286,11 @@ public:
     public:
         VSyncThread(HWComposer& hwc);
         void setEnabled(bool enabled);
+
+        // [MTK] {{{
+        // 20120814: add property function for debug purpose
+        void setProperty();
+        // [MTK] }}}
     };
 
     friend class VSyncThread;
@@ -331,6 +369,34 @@ private:
 
     // thread-safe
     mutable Mutex mEventControlLock;
+
+    // [MTK] {{{
+private:
+    nsecs_t getRefreshPeriod() const;
+
+#if !HWC_REMOVE_DEPRECATED_VERSIONS
+    bool initHWC_0();
+    void deinitHWC_0();
+    void loadHwcModule_0();
+
+    LayerListIterator getLayerIterator_0(int32_t id, size_t index);
+
+    status_t prepare_0();
+    status_t commit_0();
+    status_t release_0(int disp) const;
+
+    status_t createWorkList_0(int32_t id, size_t numLayers);
+    void freeWorkList();
+
+    void eventControl_0(int disp, int event, int enabled);
+
+    LayerListIterator end_0(int32_t id);
+    void dump_0(String8& out, char* scratch, size_t SIZE) const;
+
+    struct hwc_composer_device*     mHwc_0;
+    struct hwc_layer_list*          mList;
+#endif // HWC_REMOVE_DEPRECATED_VERSIONS
+    // [MTK] }}}
 };
 
 // ---------------------------------------------------------------------------
diff --git a/frameworks/native/services/surfaceflinger/EventThread.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/EventThread.cpp
index edb9fa5..ff5f1b3 100644
--- a/frameworks/native/services/surfaceflinger/EventThread.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/EventThread.cpp
@@ -32,6 +32,12 @@
 #include "EventThread.h"
 #include "SurfaceFlinger.h"
 
+// [MTK] {{{
+// 20120906: reserve client pid infomation
+#include <binder/IPCThreadState.h>
+#include <cutils/xlog.h>
+// [MTK] }}}
+
 // ---------------------------------------------------------------------------
 namespace android {
 // ---------------------------------------------------------------------------
@@ -343,11 +349,21 @@ EventThread::Connection::Connection(
         const sp<EventThread>& eventThread)
     : count(-1), mEventThread(eventThread), mChannel(new BitTube())
 {
+    // [MTK] {{{
+    // 20120906: reserve client pid infomation
+    pid = IPCThreadState::self()->getCallingPid();
+    XLOGI("EventThread Client Pid (%d) created", pid);
+    // [MTK] }}}
 }
 
 EventThread::Connection::~Connection() {
     // do nothing here -- clean-up will happen automatically
     // when the main thread wakes up
+
+    // [MTK] {{{
+    // 20120906: reserve client pid infomation
+    XLOGI("EventThread Client Pid (%d) disconnected by (%d)", pid, getpid());
+    // [MTK] }}}
 }
 
 void EventThread::Connection::onFirstRef() {
@@ -360,15 +376,45 @@ sp<BitTube> EventThread::Connection::getDataChannel() const {
 }
 
 void EventThread::Connection::setVsyncRate(uint32_t count) {
+    // [MTK] {{{
+#ifndef MTK_USER_BUILD
+    XLOGD("setVsyncRate(%d, c=%d)", pid, count);
+#endif
+    // [MTK] }}}
     mEventThread->setVsyncRate(count, this);
 }
 
 void EventThread::Connection::requestNextVsync() {
+#ifndef VENDOR_EDIT
+//Pantengjiao@Prd.MidWare.Surfaceflinger, 2013/03/11, Remove for too much logs
+/*
+    // [MTK] {{{
+#ifndef MTK_USER_BUILD
+    XLOGD("requestNextVsync(%d)", pid);
+#endif
+    // [MTK] }}}
+*/
+#endif /* VENDOR_EDIT */
+
     mEventThread->requestNextVsync(this);
 }
 
 status_t EventThread::Connection::postEvent(
         const DisplayEventReceiver::Event& event) {
+    #ifndef VENDOR_EDIT
+    //Pantengjiao@Prd.MidWare.Surfaceflinger, 2013/03/11, Remove for too much logs
+    /*
+     // [MTK] {{{
+#ifndef MTK_USER_BUILD
+    if (event.header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC)
+        XLOGD("postEvent(%d, v/c=%d)", pid, event.vsync.count);
+    else
+        XLOGD("postEvent(%d)", pid);
+#endif
+    // [MTK] }}}
+    */
+    #endif /* VENDOR_EDIT */
+   
     ssize_t size = DisplayEventReceiver::sendEvents(mChannel, &event, 1);
     return size < 0 ? status_t(size) : status_t(NO_ERROR);
 }
diff --git a/frameworks/native/services/surfaceflinger/EventThread.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/EventThread.h
index 1934f98..5e2d466 100644
--- a/frameworks/native/services/surfaceflinger/EventThread.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/EventThread.h
@@ -51,6 +51,11 @@ class EventThread : public Thread {
         // count ==-1 : one-shot event that fired this round / disabled
         int32_t count;
 
+        // [MTK] {{{
+        // 20120905: reserve client pid infomation
+        int32_t pid;
+        // [MTK] }}}
+
     private:
         virtual ~Connection();
         virtual void onFirstRef();
diff --git a/frameworks/native/services/surfaceflinger/Layer.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/Layer.cpp
index 064f689..d59f043 100644
--- a/frameworks/native/services/surfaceflinger/Layer.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/Layer.cpp
@@ -44,6 +44,11 @@
 
 #include "DisplayHardware/HWComposer.h"
 
+// [MTK] {{{
+#include <hardware/hwcomposer.h>
+#include <cutils/xlog.h>
+// [MTK] }}}
+
 #define DEBUG_RESIZE    0
 
 namespace android {
@@ -75,6 +80,10 @@ void Layer::onLayerDisplayed(const sp<const DisplayDevice>& hw,
     LayerBaseClient::onLayerDisplayed(hw, layer);
     if (layer) {
         mSurfaceTexture->setReleaseFence(layer->getAndResetReleaseFenceFd());
+
+        // [MTK] {{{
+        mActiveBuffer->setMva(layer->getMva());
+        // [MTK] }}}
     }
 }
 
@@ -107,10 +116,26 @@ void Layer::onFirstRef()
 #warning "disabling triple buffering"
     mSurfaceTexture->setDefaultMaxBufferCount(2);
 #else
-    mSurfaceTexture->setDefaultMaxBufferCount(3);
+    // [MTK] {{{
+    // 20120818: read board prop to check if need to disable triple buffer
+    char value[PROPERTY_VALUE_MAX];
+    property_get("ro.sf.triplebuf.disable", value, "0");
+    if (atoi(value)) {
+        ALOGW("triple buffer is disabled...");
+        mSurfaceTexture->setDefaultMaxBufferCount(2);
+    } else {
+        mSurfaceTexture->setDefaultMaxBufferCount(3);
+    }
+    // [MTK] }}}
 #endif
 
-    updateTransformHint();
+    // [MTK] {{{
+    // [TODO] workaround to use quad buffer for SF layer, should remove it
+    mSurfaceTexture->setDefaultMaxBufferCount(4);
+    // [MTK] }}}
+
+    const sp<const DisplayDevice> hw(mFlinger->getDefaultDisplayDevice());
+    updateTransformHint(hw);
 }
 
 Layer::~Layer()
@@ -278,6 +303,16 @@ void Layer::setGeometry(
         layer.setTransform(finalTransform);
     }
     layer.setCrop(computeBufferCrop());
+
+    // [MTK] {{{
+    hwc_color_t color;
+    color.a = s.alpha;
+    layer.setFillColor(color);
+    layer.setTransform(finalTransform);
+    layer.setIdentity(getIdentity());
+    layer.setMatrix(tr);
+    layer.setSecure((isSecure() || isProtected()));
+    // [MTK] }}}
 }
 
 void Layer::setPerFrameData(const sp<const DisplayDevice>& hw,
@@ -286,6 +321,11 @@ void Layer::setPerFrameData(const sp<const DisplayDevice>& hw,
     // NOTE: buffer can be NULL if the client never drew into this
     // layer yet, or if we ran out of memory
     layer.setBuffer(mActiveBuffer);
+
+    // [MTK] {{{
+    layer.setConnectedApi(mSurfaceTexture->getConnectedApi());
+    layer.setDirty((mBufferDirty || mBufferRefCount <= 1 || contentDirty));
+    // [MTK] }}}
 }
 
 void Layer::setAcquireFence(const sp<const DisplayDevice>& hw,
@@ -334,6 +374,13 @@ void Layer::onDraw(const sp<const DisplayDevice>& hw, const Region& clip) const
         // if not everything below us is covered, we plug the holes!
         Region holes(clip.subtract(under));
         if (!holes.isEmpty()) {
+            // [MTK] {{{
+            // add debug log
+            XLOGI("[%s] %s(i:%d): clear screen hole (l:%d, t:%d, w:%d, h:%d)",
+                __func__, getName().string(), getIdentity(),
+                holes.getBounds().left, holes.getBounds().top,
+                holes.getBounds().width(), holes.getBounds().height());
+            // [MTK] }}}
             clearWithOpenGL(hw, holes, 0, 0, 0, 1);
         }
         return;
@@ -358,7 +405,21 @@ void Layer::onDraw(const sp<const DisplayDevice>& hw, const Region& clip) const
         mSurfaceTexture->getTransformMatrix(textureMatrix);
 
         // Set things up for texturing.
-        glBindTexture(GL_TEXTURE_EXTERNAL_OES, mTextureName);
+        // [MTK] {{{
+        // buffer conversion here for SF layer
+        if (true == mSurfaceTexture->isAuxSlotNeedConvert()) {
+            mSurfaceTexture->convertToAuxSlot(true);
+        }
+
+        if (true == mSurfaceTexture->isAuxSlotDirty()) {
+            // bind to aux buffer if converted successfully
+            mSurfaceTexture->bindToAuxSlot();
+        } else {
+            // bind to original buffer
+            glBindTexture(GL_TEXTURE_EXTERNAL_OES, mTextureName);
+        }
+        // [MTK] }}}
+
         GLenum filter = GL_NEAREST;
         if (useFiltering) {
             filter = GL_LINEAR;
@@ -698,6 +759,15 @@ Region Layer::latchBuffer(bool& recomputeVisibleRegions)
         const Layer::State& front(drawingState());
         Region dirtyRegion(Rect(front.active.w, front.active.h));
 
+        // [MTK] {{{
+        // store buffer dirty infomation and pass to hwc later
+        mBufferDirty = !dirtyRegion.isEmpty();
+        if (mBufferDirty == true){
+            // LazySwap(5) increment buffer ref count when the texture is created
+            mBufferRefCount++;
+        }
+        // [MTK] }}}
+
         // transform the dirty region to window-manager space
         outDirtyRegion = (front.transform.transform(dirtyRegion));
     }
@@ -725,9 +795,28 @@ void Layer::dump(String8& result, char* buffer, size_t SIZE) const
 
     result.append(buffer);
 
+    // [MTK] {{{
+    snprintf(buffer, SIZE, "secure=%d", mSecure);
+    result.append(buffer);
+    // [MTK] }}}
+
     if (mSurfaceTexture != 0) {
         mSurfaceTexture->dump(result, "            ", buffer, SIZE);
     }
+
+    // [MTK] {{{
+    char value[PROPERTY_VALUE_MAX];
+    int  layerdump;
+
+    property_get("debug.sf.layerdump", value, "0");
+    layerdump = atoi(value);
+
+    // check if the identity to dump, or -1 for all
+    if ((-1 == layerdump) || (getIdentity() == (uint32_t)layerdump)) {
+        mSurfaceTexture->dumpAux();
+        dumpActiveBuffer();
+    }
+    // [MTK] }}}
 }
 
 void Layer::dumpStats(String8& result, char* buffer, size_t SIZE) const
@@ -767,15 +856,12 @@ uint32_t Layer::getEffectiveUsage(uint32_t usage) const
     return usage;
 }
 
-void Layer::updateTransformHint() const {
+void Layer::updateTransformHint(const sp<const DisplayDevice>& hw) const {
     uint32_t orientation = 0;
     if (!mFlinger->mDebugDisableTransformHint) {
-        // The transform hint is used to improve performance on the main
-        // display -- we can only have a single transform hint, it cannot
+        // The transform hint is used to improve performance, but we can
+        // only have a single transform hint, it cannot
         // apply to all displays.
-        // This is why we use the default display here. This is not an
-        // oversight.
-        sp<const DisplayDevice> hw(mFlinger->getDefaultDisplayDevice());
         const Transform& planeTransform(hw->getTransform());
         orientation = planeTransform.getOrientation();
         if (orientation & Transform::ROT_INVALID) {
diff --git a/frameworks/native/services/surfaceflinger/Layer.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/Layer.h
index 6f75d8c..2ba1c5e 100644
--- a/frameworks/native/services/surfaceflinger/Layer.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/Layer.h
@@ -91,8 +91,8 @@ public:
     inline const sp<GraphicBuffer>& getActiveBuffer() const { return mActiveBuffer; }
 
     // Updates the transform hint in our SurfaceTexture to match
-    // the current orientation of the default display device.
-    virtual void updateTransformHint() const;
+    // the current orientation of the display device.
+    virtual void updateTransformHint(const sp<const DisplayDevice>& hw) const;
 
 protected:
     virtual void onFirstRef();
@@ -146,6 +146,25 @@ private:
     // page-flip thread (currently main thread)
     bool mSecure;         // no screenshots
     bool mProtectedByApp; // application requires protected path to external sink
+    
+    // [MTK] {{{
+    void dumpActiveBuffer() const;            // debug info
+    
+    // for continuous buffers dump
+    int mContBufsDumpById;
+    uint32_t mBackupBufsIndex;
+    uint32_t mBackupBufsMax; 
+    Vector< sp<GraphicBuffer> > mBackBufs;
+    
+    virtual void setContBufsDumpById(int identity);        
+    void dumpGraphicBuffer(sp<GraphicBuffer> buf, int index) const;
+    void backupProcess(void* dst, void* src, size_t size);
+
+public:
+    void dumpContinuousBuffer() const;
+    virtual void activeBufferBackup();
+    virtual bool queryBackupBufs(){return mQueuedFrames > 0;};
+    // [MTK] }}}
 };
 
 // ---------------------------------------------------------------------------
diff --git a/frameworks/native/services/surfaceflinger/LayerBase.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/LayerBase.cpp
index db4ef87..e448a25 100644
--- a/frameworks/native/services/surfaceflinger/LayerBase.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/LayerBase.cpp
@@ -35,6 +35,11 @@
 #include "SurfaceFlinger.h"
 #include "DisplayDevice.h"
 
+// [MTK] {{{
+#include <cutils/properties.h>
+#include <cutils/xlog.h>
+// [MTK] }}}
+
 namespace android {
 
 // ---------------------------------------------------------------------------
@@ -49,6 +54,14 @@ LayerBase::LayerBase(SurfaceFlinger* flinger)
       mTransactionFlags(0),
       mPremultipliedAlpha(true), mName("unnamed"), mDebug(false)
 {
+    // [MTK] {{{
+    mBufferRefCount = 0;
+
+    // for transactions setting
+    char value[PROPERTY_VALUE_MAX];
+    property_get("debug.sf.log_transaction", value, "0");
+    mLogTransaction = atoi(value);
+    // [MTK] }}}
 }
 
 LayerBase::~LayerBase()
@@ -83,6 +96,15 @@ void LayerBase::initStates(uint32_t w, uint32_t h, uint32_t flags)
     mCurrentState.transform.set(0, 0);
     mCurrentState.requested = mCurrentState.active;
 
+    // [MTK] {{{
+    // init MTK data for layer states
+    mCurrentState.flagsEx = layer_state_t::eExInitValue;
+    mCurrentState.s3dRequestFlags = layer_state_t::eExInvalid;
+    mCurrentState.s3dBufferFlags = layer_state_t::eExS3D_2D;
+    mCurrentState.stConnectedApi = BufferQueue::NO_CONNECTED_API;
+    mCurrentState.stCurrentTransform = Transform::ROT_INVALID;
+    // [MTK] }}}
+
     // drawing state & current state are identical
     mDrawingState = mCurrentState;
 }
@@ -93,6 +115,17 @@ bool LayerBase::needsFiltering(const sp<const DisplayDevice>& hw) const {
 
 void LayerBase::commitTransaction() {
     mDrawingState = mCurrentState;
+
+    // [MTK] {{
+    // dump state result after transaction committed
+    if (true == mLogTransaction) {
+        static const size_t SIZE = 1024;
+        char buf[SIZE];
+        String8 result;
+        LayerBase::dump(result, buf, SIZE);
+        XLOGD("%s", result.string());
+    }
+    // [MTK] }}
 }
 void LayerBase::forceVisibilityTransaction() {
     // this can be called without SurfaceFlinger.mStateLock, but if we
@@ -300,6 +333,7 @@ void LayerBase::setGeometry(
 
 void LayerBase::setPerFrameData(const sp<const DisplayDevice>& hw,
         HWComposer::HWCLayerInterface& layer) {
+    layer.setPerFrameDefaultState();
     // we have to set the visible region on every frame because
     // we currently free it during onLayerDisplayed(), which is called
     // after HWComposer::commit() -- every frame.
@@ -448,18 +482,22 @@ void LayerBase::dump(String8& result, char* buffer, size_t SIZE) const
     s.transparentRegion.dump(result, "transparentRegion");
     visibleRegion.dump(result, "visibleRegion");
 
+    // [MTK] {{{
+    // add some more MTK messages
     snprintf(buffer, SIZE,
             "      "
             "layerStack=%4d, z=%9d, pos=(%g,%g), size=(%4d,%4d), crop=(%4d,%4d,%4d,%4d), "
             "isOpaque=%1d, needsDithering=%1d, invalidate=%1d, "
-            "alpha=0x%02x, flags=0x%08x, tr=[%.2f, %.2f][%.2f, %.2f]\n",
+            "alpha=0x%02x, flags=0x%08x, flagsEx=0x%08x, tr=[%.2f, %.2f][%.2f, %.2f]\n",
             s.layerStack, s.z, s.transform.tx(), s.transform.ty(), s.active.w, s.active.h,
             s.active.crop.left, s.active.crop.top,
             s.active.crop.right, s.active.crop.bottom,
             isOpaque(), needsDithering(), contentDirty,
-            s.alpha, s.flags,
+            s.alpha, s.flags, s.flagsEx,
             s.transform[0][0], s.transform[0][1],
             s.transform[1][0], s.transform[1][1]);
+    // [MTK] }}}
+
     result.append(buffer);
 }
 
diff --git a/frameworks/native/services/surfaceflinger/LayerBase.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/LayerBase.h
index 00c4ffe..9272d0b 100644
--- a/frameworks/native/services/surfaceflinger/LayerBase.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/LayerBase.h
@@ -86,10 +86,23 @@ public:
                 int32_t         sequence;   // changes when visible regions can change
                 Transform       transform;
                 Region          transparentRegion;
+
+                // [MTK] {{{
+                uint32_t        flagsEx;
+
+                uint32_t        s3dRequestFlags;
+                uint32_t        s3dBufferFlags;
+                uint32_t        stConnectedApi;
+                uint32_t        stCurrentTransform;
+                int32_t         s3dOffset;
+                // [MTK] }}}
             };
 
             class LayerMesh {
                 friend class LayerBase;
+                // [MTK] {{{
+                friend class LayerScreenshot;
+                // [MTK] }}}
                 GLfloat mVertices[4][2];
                 size_t mNumVertices;
             public:
@@ -246,7 +259,7 @@ public:
      * Updates the SurfaceTexture's transform hint, for layers that have
      * a SurfaceTexture.
      */
-    virtual void updateTransformHint() const { }
+    virtual void updateTransformHint(const sp<const DisplayDevice>& hw) const { }
 
     /** always call base class first */
     virtual void dump(String8& result, char* scratch, size_t size) const;
@@ -303,6 +316,23 @@ public:
 
 private:
     LayerBase(const LayerBase& rhs);
+
+    // [MTK] {{{
+private:
+    bool mLogTransaction;
+
+public:
+    // 201120717: infomation for verifing if needs recompositon
+    bool mBufferDirty;
+    mutable uint64_t mBufferRefCount;
+
+    bool setFlagsEx(uint32_t flags, uint32_t mask);
+
+    // for continuous buffers dump
+    virtual void setContBufsDumpById(int identity){};
+    virtual void activeBufferBackup(){};
+    virtual bool queryBackupBufs(){return false;};
+    // [MTK] }}}
 };
 
 
diff --git a/frameworks/native/services/surfaceflinger/LayerDim.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/LayerDim.h
index 06f312d..ffa8452 100644
--- a/frameworks/native/services/surfaceflinger/LayerDim.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/LayerDim.h
@@ -41,6 +41,13 @@ public:
     virtual bool isProtectedByApp() const { return false; }
     virtual bool isProtectedByDRM() const { return false; }
     virtual const char* getTypeId() const { return "LayerDim"; }
+
+    // [MTK] {{{
+    virtual void setGeometry(const sp<const DisplayDevice>& hw,
+            HWComposer::HWCLayerInterface& layer);
+    virtual void setPerFrameData(const sp<const DisplayDevice>& hw,
+            HWComposer::HWCLayerInterface& layer);
+    // [MTK] }}}
 };
 
 // ---------------------------------------------------------------------------
diff --git a/frameworks/native/services/surfaceflinger/LayerScreenshot.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/LayerScreenshot.cpp
index f8009b3..954912d 100644
--- a/frameworks/native/services/surfaceflinger/LayerScreenshot.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/LayerScreenshot.cpp
@@ -46,6 +46,9 @@ LayerScreenshot::~LayerScreenshot()
     if (mTextureName) {
         mFlinger->deleteTextureAsync(mTextureName);
     }
+    // [MTK] {{{
+    clearStatus();
+    // [MTK] }}}
 }
 
 status_t LayerScreenshot::captureLocked(int32_t layerStack) {
@@ -143,7 +146,14 @@ void LayerScreenshot::onDraw(const sp<const DisplayDevice>& hw, const Region& cl
         }
 
         LayerMesh mesh;
-        computeGeometry(hw, &mesh);
+
+        // [MTK] {{{
+        int hwOrientation = hw->getHwOrientation();
+        if (hwOrientation != DisplayState::eOrientationDefault)
+            computeGeometryOrient(hw, &mesh, hwOrientation);
+        else
+            computeGeometry(hw, &mesh);
+        // [MTK] }}}
 
         glColor4f(alpha, alpha, alpha, alpha);
 
diff --git a/frameworks/native/services/surfaceflinger/LayerScreenshot.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/LayerScreenshot.h
index 38cbd88..65d6f8c 100644
--- a/frameworks/native/services/surfaceflinger/LayerScreenshot.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/LayerScreenshot.h
@@ -53,6 +53,21 @@ public:
 private:
     status_t captureLocked(int32_t layerStack);
     void initTexture(GLfloat u, GLfloat v);
+
+    // [MTK] {{{
+public:
+    virtual void setGeometry(const sp<const DisplayDevice>& hw,
+            HWComposer::HWCLayerInterface& layer);
+    virtual void setPerFrameData(const sp<const DisplayDevice>& hw,
+            HWComposer::HWCLayerInterface& layer);
+
+    static int getCount();
+    static bool isFrozen();
+
+private:
+    void computeGeometryOrient(const sp<const DisplayDevice>& hw, LayerMesh* mesh, int orient) const;
+    void clearStatus();
+    // [MTK] }}}
 };
 
 // ---------------------------------------------------------------------------
diff --git a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
index ce10c78..a6fe556 100644
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
@@ -73,6 +73,12 @@
 
 #define DISPLAY_COUNT       1
 
+// [MTK] {{{
+// additional mtk utils
+#include "mediatek/SurfaceFlingerWatchDog.h"
+#include <cutils/xlog.h>
+// [MTK] }}}
+
 namespace android {
 // ---------------------------------------------------------------------------
 
@@ -121,6 +127,14 @@ SurfaceFlinger::SurfaceFlinger()
     }
     ALOGI_IF(mDebugRegion, "showupdates enabled");
     ALOGI_IF(mDebugDDMS, "DDMS debugging enabled");
+
+    // [MTK] {{{
+    mBootAnimationEnabled = true;
+    mContentsDirty = false;
+    mForceContBufsDumpStop = false;
+
+    setMTKProperties();
+    // [MTK] }}}
 }
 
 void SurfaceFlinger::onFirstRef()
@@ -136,6 +150,11 @@ void SurfaceFlinger::onFirstRef()
 
 SurfaceFlinger::~SurfaceFlinger()
 {
+    // [MTK] {{{
+    // 20121003: mHwc should be deleted to avoid memory leak
+    delete mHwc;
+    // [MTK] }}}
+
     EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
     eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
     eglTerminate(display);
@@ -191,12 +210,22 @@ sp<IBinder> SurfaceFlinger::createDisplay(const String8& displayName,
     return token;
 }
 
+void SurfaceFlinger::createBuiltinDisplayLocked(DisplayDevice::DisplayType type) {
+    ALOGW_IF(mBuiltinDisplays[type],
+            "Overwriting display token for display type %d", type);
+    mBuiltinDisplays[type] = new BBinder();
+    DisplayDeviceState info(type);
+    // All non-virtual displays are currently considered secure.
+    info.isSecure = true;
+    mCurrentState.displays.add(mBuiltinDisplays[type], info);
+}
+
 sp<IBinder> SurfaceFlinger::getBuiltInDisplay(int32_t id) {
     if (uint32_t(id) >= DisplayDevice::NUM_DISPLAY_TYPES) {
         ALOGE("getDefaultDisplay: id=%d is not a valid default display id", id);
         return NULL;
     }
-    return mDefaultDisplays[id];
+    return mBuiltinDisplays[id];
 }
 
 sp<IGraphicBufferAlloc> SurfaceFlinger::createGraphicBufferAlloc()
@@ -223,6 +252,12 @@ void SurfaceFlinger::bootFinished()
     // formerly we would just kill the process, but we now ask it to exit so it
     // can choose where to stop the animation.
     property_set("service.bootanim.exit", "1");
+
+    // [MTK] {{{
+    // boot time profiling
+    ALOG(LOG_INFO,"boot","BOOTPROF:BootAnimation:End:%ld", long(ns2ms(systemTime())));
+    bootProf(0);
+    // [MTK] }}}
 }
 
 void SurfaceFlinger::deleteTextureAsync(GLuint texture) {
@@ -462,6 +497,8 @@ status_t SurfaceFlinger::readyToRun()
     ALOGI(  "SurfaceFlinger's main thread ready to run. "
             "Initializing graphics H/W...");
 
+    Mutex::Autolock _l(mStateLock);
+
     // initialize EGL for the default display
     mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
     eglInitialize(mEGLDisplay, NULL, NULL);
@@ -476,20 +513,29 @@ status_t SurfaceFlinger::readyToRun()
     mEGLConfig  = selectEGLConfig(mEGLDisplay, format);
     mEGLContext = createGLContext(mEGLDisplay, mEGLConfig);
 
-    LOG_ALWAYS_FATAL_IF(mEGLContext == EGL_NO_CONTEXT,
-            "couldn't create EGLContext");
+    // [MTK] {{{
+    // make sure 3D init success
+    //LOG_ALWAYS_FATAL_IF(mEGLContext == EGL_NO_CONTEXT,
+    //        "couldn't create EGLContext");
+    if (mEGLContext == EGL_NO_CONTEXT)
+    {
+        XLOGE("FATAL: couldn't create EGLContext");
+        delete mHwc;
+        eglTerminate(mEGLDisplay);
+        exit(0);
+    }
+    // [MTK] }}}
 
     // initialize our non-virtual displays
     for (size_t i=0 ; i<DisplayDevice::NUM_DISPLAY_TYPES ; i++) {
         DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i);
-        mDefaultDisplays[i] = new BBinder();
-        wp<IBinder> token = mDefaultDisplays[i];
-
         // set-up the displays that are already connected
         if (mHwc->isConnected(i) || type==DisplayDevice::DISPLAY_PRIMARY) {
             // All non-virtual displays are currently considered secure.
             bool isSecure = true;
-            mCurrentState.displays.add(token, DisplayDeviceState(type));
+            createBuiltinDisplayLocked(type);
+            wp<IBinder> token = mBuiltinDisplays[i];
+
             sp<FramebufferSurface> fbs = new FramebufferSurface(*mHwc, i);
             sp<SurfaceTextureClient> stc = new SurfaceTextureClient(
                         static_cast< sp<ISurfaceTexture> >(fbs->getBufferQueue()));
@@ -517,6 +563,11 @@ status_t SurfaceFlinger::readyToRun()
     DisplayDevice::makeCurrent(mEGLDisplay, hw, mEGLContext);
     initializeGL(mEGLDisplay);
 
+    // [MTK] {{{
+    adjustPriority();
+    mWatchDogIndex = SFWatchDog::getInstance()->registerNodeName("SurfaceFlinger");
+    // [MTK] }}}
+
     // start the EventThread
     mEventThread = new EventThread(this);
     mEventQueue.setEventThread(mEventThread);
@@ -543,9 +594,22 @@ int32_t SurfaceFlinger::allocateHwcDisplayId(DisplayDevice::DisplayType type) {
 }
 
 void SurfaceFlinger::startBootAnim() {
-    // start boot animation
-    property_set("service.bootanim.exit", "0");
-    property_set("ctl.start", "bootanim");
+    // [MTK] {{{
+    // dynamic disable/enable boot animation
+    mBootAnimationEnabled = isEnableBootAnim();
+    ALOG(LOG_INFO, "boot", "mBootAnimationEnabled = %d", mBootAnimationEnabled);
+    if (true == mBootAnimationEnabled) {
+        // start boot animation
+        property_set("service.bootanim.exit", "0");
+        property_set("ctl.start", "bootanim");
+
+        // boot time profiling
+        ALOG(LOG_INFO,"boot", "BOOTPROF:BootAnimation:Start:%ld", long(ns2ms(systemTime())));
+        bootProf(1);
+    } else {
+        XLOGI("Skip boot animation!");
+    }
+    // [MTK] }}}
 }
 
 uint32_t SurfaceFlinger::getMaxTextureSize() const {
@@ -601,9 +665,9 @@ bool SurfaceFlinger::authenticateSurfaceTexture(
 }
 
 status_t SurfaceFlinger::getDisplayInfo(const sp<IBinder>& display, DisplayInfo* info) {
-    int32_t type = BAD_VALUE;
+    int32_t type = NAME_NOT_FOUND;
     for (int i=0 ; i<DisplayDevice::NUM_DISPLAY_TYPES ; i++) {
-        if (display == mDefaultDisplays[i]) {
+        if (display == mBuiltinDisplays[i]) {
             type = i;
             break;
         }
@@ -614,10 +678,6 @@ status_t SurfaceFlinger::getDisplayInfo(const sp<IBinder>& display, DisplayInfo*
     }
 
     const HWComposer& hwc(getHwComposer());
-    if (!hwc.isConnected(type)) {
-        return NAME_NOT_FOUND;
-    }
-
     float xdpi = hwc.getDpiX(type);
     float ydpi = hwc.getDpiY(type);
 
@@ -745,11 +805,11 @@ void SurfaceFlinger::onHotplugReceived(int type, bool connected) {
 
     if (uint32_t(type) < DisplayDevice::NUM_DISPLAY_TYPES) {
         Mutex::Autolock _l(mStateLock);
-        if (connected == false) {
-            mCurrentState.displays.removeItem(mDefaultDisplays[type]);
+        if (connected) {
+            createBuiltinDisplayLocked((DisplayDevice::DisplayType)type);
         } else {
-            DisplayDeviceState info((DisplayDevice::DisplayType)type);
-            mCurrentState.displays.add(mDefaultDisplays[type], info);
+            mCurrentState.displays.removeItem(mBuiltinDisplays[type]);
+            mBuiltinDisplays[type].clear();
         }
         setTransactionFlags(eDisplayTransactionNeeded);
 
@@ -894,6 +954,13 @@ void SurfaceFlinger::rebuildLayerStacks() {
                 SurfaceFlinger::computeVisibleRegions(currentLayers,
                         hw->getLayerStack(), dirtyRegion, opaqueRegion);
 
+                // [MTK] {{{
+                // LazySwap(2) draw and swap if content updated
+                // (by transaction) in drawing state
+                hw->mLayersSwapRequired |= mContentsDirty;
+                mContentsDirty = false;
+                // [MTK] }}}
+
                 const size_t count = currentLayers.size();
                 for (size_t i=0 ; i<count ; i++) {
                     const sp<LayerBase>& layer(currentLayers[i]);
@@ -965,12 +1032,40 @@ void SurfaceFlinger::setUpHWComposer() {
             }
         }
 
+        // [MTK] {{{
+        // check if any previous layer is processed by gles
+        const bool prevGlesComposition = hwc.hasGlesComposition(DisplayDevice::DISPLAY_PRIMARY);
+        // [MTK] }}}
+
         status_t err = hwc.prepare();
         ALOGE_IF(err, "HWComposer::prepare failed (%s)", strerror(-err));
+
+        // [MTK] {{{
+        // do not render transparent region if unnecessary
+        for (size_t dpy=0 ; dpy<mDisplays.size() ; dpy++) {
+            sp<const DisplayDevice> hw(mDisplays[dpy]);
+            checkLayersSwapRequired(hw, prevGlesComposition);
+            hw->mLayersSwapRequired = (true == mPropertiesState.mBusySwap) ?
+                                          true : hw->mLayersSwapRequired;
+
+            if (true == mPropertiesState.mLogRepaint) {
+                XLOGD("@ disp(%d) layerswap:%d", dpy, hw->mLayersSwapRequired);
+            }
+        }
+        // [MTK] }}}
     }
 }
 
 void SurfaceFlinger::doComposition() {
+    // [MTK] {{{
+    // to slow down FPS
+    if (0 != mPropertiesState.mDelayTime) {
+        XLOGI("SurfaceFlinger slow motion timer: %d ms",
+              mPropertiesState.mDelayTime);
+        usleep(1000 * mPropertiesState.mDelayTime);
+    }
+    // [MTK] }}}
+
     ATRACE_CALL();
     const bool repaintEverything = android_atomic_and(0, &mRepaintEverything);
     for (size_t dpy=0 ; dpy<mDisplays.size() ; dpy++) {
@@ -1069,7 +1164,7 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
 
     if (transactionFlags & eTraversalNeeded) {
         for (size_t i=0 ; i<count ; i++) {
-            const sp<LayerBase>& layer = currentLayers[i];
+            const sp<LayerBase>& layer(currentLayers[i]);
             uint32_t trFlags = layer->getTransactionFlags(eTransactionNeeded);
             if (!trFlags) continue;
 
@@ -1142,18 +1237,6 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
                             disp->setProjection(state.orientation,
                                     state.viewport, state.frame);
                         }
-
-                        // Walk through all the layers in currentLayers,
-                        // and update their transform hint.
-                        //
-                        // TODO: we could be much more clever about which
-                        // layers we touch and how often we do these updates
-                        // (e.g. only touch the layers associated with this
-                        // display, and only on a rotation).
-                        for (size_t i = 0; i < count; i++) {
-                            const sp<LayerBase>& layerBase = currentLayers[i];
-                            layerBase->updateTransformHint();
-                        }
                     }
                 }
             }
@@ -1163,7 +1246,6 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
             for (size_t i=0 ; i<cc ; i++) {
                 if (draw.indexOfKey(curr.keyAt(i)) < 0) {
                     const DisplayDeviceState& state(curr[i]);
-                    bool isSecure = false;
 
                     sp<FramebufferSurface> fbs;
                     sp<SurfaceTextureClient> stc;
@@ -1174,10 +1256,6 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
                                 "surface is provided (%p), ignoring it",
                                 state.surface.get());
 
-                        // All non-virtual displays are currently considered
-                        // secure.
-                        isSecure = true;
-
                         // for supported (by hwc) displays we provide our
                         // own rendering surface
                         fbs = new FramebufferSurface(*mHwc, state.type);
@@ -1188,13 +1266,12 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
                         if (state.surface != NULL) {
                             stc = new SurfaceTextureClient(state.surface);
                         }
-                        isSecure = state.isSecure;
                     }
 
                     const wp<IBinder>& display(curr.keyAt(i));
                     if (stc != NULL) {
                         sp<DisplayDevice> hw = new DisplayDevice(this,
-                                state.type, isSecure, display, stc, fbs,
+                                state.type, state.isSecure, display, stc, fbs,
                                 mEGLConfig);
                         hw->setLayerStack(state.layerStack);
                         hw->setProjection(state.orientation,
@@ -1208,6 +1285,61 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
         }
     }
 
+    if (transactionFlags & (eTraversalNeeded|eDisplayTransactionNeeded)) {
+        // The transform hint might have changed for some layers
+        // (either because a display has changed, or because a layer
+        // as changed).
+        //
+        // Walk through all the layers in currentLayers,
+        // and update their transform hint.
+        //
+        // If a layer is visible only on a single display, then that
+        // display is used to calculate the hint, otherwise we use the
+        // default display.
+        //
+        // NOTE: we do this here, rather than in rebuildLayerStacks() so that
+        // the hint is set before we acquire a buffer from the surface texture.
+        //
+        // NOTE: layer transactions have taken place already, so we use their
+        // drawing state. However, SurfaceFlinger's own transaction has not
+        // happened yet, so we must use the current state layer list
+        // (soon to become the drawing state list).
+        //
+        sp<const DisplayDevice> disp;
+        uint32_t currentlayerStack = 0;
+        for (size_t i=0; i<count; i++) {
+            // NOTE: we rely on the fact that layers are sorted by
+            // layerStack first (so we don't have to traverse the list
+            // of displays for every layer).
+            const sp<LayerBase>& layerBase(currentLayers[i]);
+            uint32_t layerStack = layerBase->drawingState().layerStack;
+            if (i==0 || currentlayerStack != layerStack) {
+                currentlayerStack = layerStack;
+                // figure out if this layerstack is mirrored
+                // (more than one display) if so, pick the default display,
+                // if not, pick the only display it's on.
+                disp.clear();
+                for (size_t dpy=0 ; dpy<mDisplays.size() ; dpy++) {
+                    sp<const DisplayDevice> hw(mDisplays[dpy]);
+                    if (hw->getLayerStack() == currentlayerStack) {
+                        if (disp == NULL) {
+                            disp = hw;
+                        } else {
+                            disp = getDefaultDisplayDevice();
+                            break;
+                        }
+                    }
+                }
+            }
+            if (disp != NULL) {
+                // presumably this means this layer is using a layerStack
+                // that is not visible on any display
+                layerBase->updateTransformHint(disp);
+            }
+        }
+    }
+
+
     /*
      * Perform our own transaction if needed
      */
@@ -1221,6 +1353,14 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
     // some layers might have been removed, so
     // we need to update the regions they're exposing.
     if (mLayersRemoved) {
+        // [MTK] {{{
+        // LazySwap(1) draw and swap if layer removed
+        for (size_t dpy=0 ; dpy<mDisplays.size() ; dpy++) {
+            sp<DisplayDevice> hw(mDisplays[dpy]);
+            hw->mLayersSwapRequired = true;
+        }
+        // [MTK] }}}
+
         mLayersRemoved = false;
         mVisibleRegionsDirty = true;
         const size_t count = previousLayers.size();
@@ -1353,6 +1493,12 @@ void SurfaceFlinger::computeVisibleRegions(
         // subtract the opaque region covered by the layers above us
         visibleRegion.subtractSelf(aboveOpaqueLayers);
 
+        // [MTK] {{{
+        // LazySwap(2) draw and swap if content updated
+        // (by transaction) in drawing state
+        mContentsDirty |= layer->contentDirty;
+        // [MTK] }}}
+
         // compute this layer's dirty region
         if (layer->contentDirty) {
             // we need to invalidate the whole region
@@ -1409,6 +1555,11 @@ void SurfaceFlinger::invalidateLayerStack(uint32_t layerStack,
 
 void SurfaceFlinger::handlePageFlip()
 {
+    // [MTK] {{{
+    // wait for dump thread
+    Mutex::Autolock _l(mDumpLock);
+    // [MTK] }}}
+
     Region dirtyRegion;
 
     bool visibleRegions = false;
@@ -1416,7 +1567,22 @@ void SurfaceFlinger::handlePageFlip()
     const size_t count = currentLayers.size();
     for (size_t i=0 ; i<count ; i++) {
         const sp<LayerBase>& layer(currentLayers[i]);
+
+        // [MTK] {{{
+        // for continuous buffers dump
+        layer->setContBufsDumpById(mPropertiesState.mContBufsDump);
+        bool bBackupBufs = layer->queryBackupBufs();
+        // [MTK] }}}
+
         const Region dirty(layer->latchBuffer(visibleRegions));
+
+        // [MTK] {{{
+        // for continuous buffers dump
+        // backup active buffer
+        if (!mForceContBufsDumpStop && bBackupBufs)
+            layer->activeBufferBackup();
+        // [MTK] }}}
+
         const Layer::State& s(layer->drawingState());
         invalidateLayerStack(s.layerStack, dirty);
     }
@@ -1433,6 +1599,17 @@ void SurfaceFlinger::invalidateHwcGeometry()
 void SurfaceFlinger::doDisplayComposition(const sp<const DisplayDevice>& hw,
         const Region& inDirtyRegion)
 {
+    // [MTK] {{{
+    // doDisplayComposition debug msg
+    if (true == mPropertiesState.mLogRepaint) {
+        XLOGD("[doDisplayComposition] +");
+    }
+
+    // start watchdog
+    sp<SFWatchDog> watchDog(SFWatchDog::getInstance());
+    watchDog->markStartTransactionTime(mWatchDogIndex);
+    // [MTK] }}}
+
     Region dirtyRegion(inDirtyRegion);
 
     // compute the invalid region
@@ -1463,8 +1640,49 @@ void SurfaceFlinger::doDisplayComposition(const sp<const DisplayDevice>& hw,
     // update the swap region and clear the dirty region
     hw->swapRegion.orSelf(dirtyRegion);
 
+
+    // [MTK] {{{
+    // drawing debug line
+    if (true == mPropertiesState.mLineG3D) {
+        // get screen geometry
+        sp<const DisplayDevice> hw(getDefaultDisplayDevice());
+        const uint32_t hw_w = hw->getWidth();
+        const uint32_t hw_h = hw->getHeight();
+
+        static uint32_t cnt = 0;
+        uint32_t y = hw_h - cnt * 10;
+
+        glEnable(GL_SCISSOR_TEST);
+        glScissor(0, y, hw_h, 10);
+        glClearColor(0.0, 1.0, 0.0, 1.0);
+        glClear(GL_COLOR_BUFFER_BIT);
+        glDisable(GL_SCISSOR_TEST);
+
+        cnt = (cnt + 1) % 50;
+    }
+    // [MTK] }}}
+
     // swap buffers (presentation)
     hw->swapBuffers(getHwComposer());
+
+    // [MTK] {{{
+    // stop watchdog
+    watchDog->unmarkStartTransactionTime(mWatchDogIndex);
+
+    // for screen update FPS
+    if (true == mFps.update()) {
+        XLOGI("[SurfaceFlinger] fps:%f,dur:%.2f,max:%.2f,min:%.2f",
+            mFps.getFps(),
+            mFps.getLastLogDuration() / 1e6,
+            mFps.getMaxDuration() / 1e6,
+            mFps.getMinDuration() / 1e6);
+    }
+
+    // doDisplayComposition debug msg
+    if (true == mPropertiesState.mLogRepaint) {
+        XLOGD("[doDisplayComposition] -");
+    }
+    // [MTK] }}}
 }
 
 void SurfaceFlinger::doComposeSurfaces(const sp<const DisplayDevice>& hw, const Region& dirty)
@@ -1499,6 +1717,15 @@ void SurfaceFlinger::doComposeSurfaces(const sp<const DisplayDevice>& hw, const
                 // can happen with SurfaceView
                 drawWormhole(hw, region);
             }
+
+            // [MTK] {{{
+            // debug log
+            if (true == mPropertiesState.mLogRepaint) {
+                String8 str;
+                region.dump(str, "");
+                XLOGD("@ (wormhole)\n%s", str.string());
+            }
+            // [MTK] }}}
         }
 
         if (hw->getDisplayType() >= DisplayDevice::DISPLAY_EXTERNAL) {
@@ -1546,11 +1773,32 @@ void SurfaceFlinger::doComposeSurfaces(const sp<const DisplayDevice>& hw, const
                             // never clear the very first layer since we're
                             // guaranteed the FB is already cleared
                             layer->clearWithOpenGL(hw, clip);
+
+                            // [MTK] {{{
+                            // debug log
+                            if (true == mPropertiesState.mLogRepaint) {
+                                String8 str;
+                                clip.dump(str, "");
+                                XLOGD("hwc (%s\n%s)",
+                                      layer->getName().string(), str.string());
+                            }
+                            // [MTK] }}}
                         }
                         break;
                     }
                     case HWC_FRAMEBUFFER: {
                         layer->draw(hw, clip);
+
+                        // [MTK] {{{
+                        // debug log
+                        if (true == mPropertiesState.mLogRepaint) {
+                            String8 str;
+                            clip.dump(str, "");
+                            XLOGD("gles (%s\n%s)",
+                                  layer->getName().string(), str.string());
+                        }
+                        // [MTK] }}}
+
                         break;
                     }
                     case HWC_FRAMEBUFFER_TARGET: {
@@ -1571,6 +1819,15 @@ void SurfaceFlinger::doComposeSurfaces(const sp<const DisplayDevice>& hw, const
                     tr.transform(layer->visibleRegion)));
             if (!clip.isEmpty()) {
                 layer->draw(hw, clip);
+
+                // [MTK] {{{
+                // debug log
+                if (true == mPropertiesState.mLogRepaint) {
+                    String8 str;
+                    clip.dump(str, "");
+                    XLOGD("gles (%s\n%s)", layer->getName().string(), str.string());
+                }
+                // [MTK] }}}
             }
         }
     }
@@ -1833,6 +2090,11 @@ uint32_t SurfaceFlinger::setClientStateLocked(
         if (what & layer_state_t::eVisibilityChanged) {
             if (layer->setFlags(s.flags, s.mask))
                 flags |= eTraversalNeeded;
+
+            // [MTK] {{{
+            if (layer->setFlagsEx(s.flagsEx, s.maskEx))
+                flags |= eTraversalNeeded;
+            // [MTK] }}}
         }
         if (what & layer_state_t::eCropChanged) {
             if (layer->setCrop(s.crop))
@@ -2002,7 +2264,7 @@ void SurfaceFlinger::onInitializeDisplays() {
     Vector<DisplayState> displays;
     DisplayState d;
     d.what = DisplayState::eDisplayProjectionChanged;
-    d.token = mDefaultDisplays[DisplayDevice::DISPLAY_PRIMARY];
+    d.token = mBuiltinDisplays[DisplayDevice::DISPLAY_PRIMARY];
     d.orientation = DisplayState::eOrientationDefault;
     d.frame.makeInvalid();
     d.viewport.makeInvalid();
@@ -2034,6 +2296,11 @@ void SurfaceFlinger::onScreenAcquired(const sp<const DisplayDevice>& hw) {
         return;
     }
 
+    // [MTK] {{{
+    // tracking screen unblank
+    ATRACE_CALL();
+    // [MTK] }}}
+
     hw->acquireScreen();
     int32_t type = hw->getDisplayType();
     if (type < DisplayDevice::NUM_DISPLAY_TYPES) {
@@ -2043,6 +2310,10 @@ void SurfaceFlinger::onScreenAcquired(const sp<const DisplayDevice>& hw) {
         if (type == DisplayDevice::DISPLAY_PRIMARY) {
             // FIXME: eventthread only knows about the main display right now
             mEventThread->onScreenAcquired();
+
+            // [MTK] {{{
+            SFWatchDog::getInstance()->screenAcquired();
+            // [MTK] }}}
         }
     }
     mVisibleRegionsDirty = true;
@@ -2056,10 +2327,19 @@ void SurfaceFlinger::onScreenReleased(const sp<const DisplayDevice>& hw) {
         return;
     }
 
+    // [MTK] {{{
+    // tracking screen blank
+    ATRACE_CALL();
+    // [MTK] }}}
+
     hw->releaseScreen();
     int32_t type = hw->getDisplayType();
     if (type < DisplayDevice::NUM_DISPLAY_TYPES) {
         if (type == DisplayDevice::DISPLAY_PRIMARY) {
+            // [MTK] {{{
+            SFWatchDog::getInstance()->screenReleased();
+            // [MTK] }}}
+
             // FIXME: eventthread only knows about the main display right now
             mEventThread->onScreenReleased();
         }
@@ -2092,6 +2372,12 @@ void SurfaceFlinger::unblank(const sp<IBinder>& display) {
     };
     sp<MessageBase> msg = new MessageScreenAcquired(*this, display);
     postMessageSync(msg);
+
+    // [MTK] {{{
+    // notify IPO for black screen sync issue
+    usleep(16667);
+    property_set("sys.ipowin.done", "1");
+    // [MTK] }}}
 }
 
 void SurfaceFlinger::blank(const sp<IBinder>& display) {
@@ -2132,6 +2418,11 @@ status_t SurfaceFlinger::dump(int fd, const Vector<String16>& args)
                 IPCThreadState::self()->getCallingUid());
         result.append(buffer);
     } else {
+        // [MTK] {{{
+        // for run-time enable property
+        setMTKProperties(result);
+        // [MTK] }}}
+
         // Try to get the main lock, but don't insist if we can't
         // (this would indicate SF is stuck, but we want to be able to
         // print something in dumpsys).
@@ -2177,6 +2468,11 @@ status_t SurfaceFlinger::dump(int fd, const Vector<String16>& args)
             dumpAllLocked(result, buffer, SIZE);
         }
 
+        // [MTK] {{{
+        // pause continuous layer dump update
+        mForceContBufsDumpStop = false;
+        // [MTK] }}}
+
         if (locked) {
             mStateLock.unlock();
         }
@@ -2269,6 +2565,13 @@ void SurfaceFlinger::dumpAllLocked(
     nsecs_t inSwapBuffersDuration = (inSwapBuffers) ? now-inSwapBuffers : 0;
     nsecs_t inTransactionDuration = (inTransaction) ? now-inTransaction : 0;
 
+    // [MTK] {{{
+    Mutex::Autolock _l(mDumpLock);
+
+    // for data dump
+    system("mkdir /data/SF_dump");
+    // [MTK] }}}
+
     /*
      * Dump library configuration.
      */
@@ -2517,6 +2820,14 @@ status_t SurfaceFlinger::onTransact(
 }
 
 void SurfaceFlinger::repaintEverything() {
+    // [MTK] {{{
+    // LazySwap(7) draw and swap if region is invalidated
+    for (size_t dpy=0 ; dpy<mDisplays.size() ; dpy++) {
+        sp<DisplayDevice> hw(mDisplays[dpy]);
+        hw->mLayersSwapRequired = true;
+    }
+    // [MTK] }}}
+
     android_atomic_or(1, &mRepaintEverything);
     signalTransaction();
 }
@@ -2587,6 +2898,22 @@ status_t SurfaceFlinger::renderScreenToTextureLocked(uint32_t layerStack,
         layer->draw(hw);
     }
 
+    // [MTK] {{{
+    // drawing debug line
+    if (true == mPropertiesState.mLineScreenShot) {
+        static uint32_t cnt = 0;
+        uint32_t y = hw_w - cnt * 10;
+
+        glEnable(GL_SCISSOR_TEST);
+        glScissor(0, y, hw_h, 10);
+        glClearColor(1.0, 0.0, 0.0, 1.0);
+        glClear(GL_COLOR_BUFFER_BIT);
+        glDisable(GL_SCISSOR_TEST);
+
+        cnt = (cnt + 1) % 50;
+    }
+    // [MTK] }}}
+
     hw->compositionComplete();
 
     // back to main framebuffer
@@ -2626,6 +2953,15 @@ status_t SurfaceFlinger::captureScreenImplLocked(const sp<IBinder>& display,
         return PERMISSION_DENIED;
     }
 
+    // [MTK] {{{
+    int hwOrientation = hw->getHwOrientation();
+    if (hwOrientation & DisplayState::eOrientationSwapMask) {
+        int tmp = sw;
+        sw = sh;
+        sh = tmp;
+    }
+    // [MTK] }}}
+
     if ((sw > hw_w) || (sh > hw_h)) {
         ALOGE("size mismatch (%d, %d) > (%d, %d)", sw, sh, hw_w, hw_h);
         return BAD_VALUE;
@@ -2694,16 +3030,27 @@ status_t SurfaceFlinger::captureScreenImplLocked(const sp<IBinder>& display,
                     new MemoryHeapBase(size, 0, "screen-capture") );
             void* const ptr = base->getBase();
             if (ptr != MAP_FAILED) {
-                // capture the screen with glReadPixels()
-                ScopedTrace _t(ATRACE_TAG, "glReadPixels");
-                glReadPixels(0, 0, sw, sh, GL_RGBA, GL_UNSIGNED_BYTE, ptr);
-                if (glGetError() == GL_NO_ERROR) {
-                    *heap = base;
-                    *w = sw;
-                    *h = sh;
-                    *f = PIXEL_FORMAT_RGBA_8888;
-                    result = NO_ERROR;
+                // [MTK] {{{
+                if (DisplayState::eOrientationDefault != hwOrientation) {
+                    result = captureTransform(ptr, size, sw, sh, w, h, hwOrientation);
+
+                    if (result == NO_ERROR) {
+                        *heap = base;
+                        *f = PIXEL_FORMAT_RGBA_8888;
+                    }
+                } else {
+                    // capture the screen with glReadPixels()
+                    ScopedTrace _t(ATRACE_TAG, "glReadPixels");
+                    glReadPixels(0, 0, sw, sh, GL_RGBA, GL_UNSIGNED_BYTE, ptr);
+                    if (glGetError() == GL_NO_ERROR) {
+                        *heap = base;
+                        *w = sw;
+                        *h = sh;
+                        *f = PIXEL_FORMAT_RGBA_8888;
+                        result = NO_ERROR;
+                    }
                 }
+                // [MTK] }}}
             } else {
                 result = NO_MEMORY;
             }
diff --git a/frameworks/native/services/surfaceflinger/SurfaceFlinger.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
index b0d3bac..6f1f148 100644
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
@@ -50,6 +50,10 @@
 
 #include "DisplayHardware/HWComposer.h"
 
+// [MTK] {{{
+#include <gui/FpsCounter.h>
+// [MTK] }}}
+
 namespace android {
 
 // ---------------------------------------------------------------------------
@@ -112,7 +116,7 @@ public:
 
     // returns the default Display
     sp<const DisplayDevice> getDefaultDisplayDevice() const {
-        return getDisplayDevice(mDefaultDisplays[DisplayDevice::DISPLAY_PRIMARY]);
+        return getDisplayDevice(mBuiltinDisplays[DisplayDevice::DISPLAY_PRIMARY]);
     }
 
     // utility function to delete a texture on the main thread
@@ -328,6 +332,9 @@ private:
     // called when starting, or restarting after system_server death
     void initializeDisplays();
 
+    // Create an IBinder for a builtin display and add it to current state
+    void createBuiltinDisplayLocked(DisplayDevice::DisplayType type);
+
     // NOTE: can only be called from the main thread or with mStateLock held
     sp<const DisplayDevice> getDisplayDevice(const wp<IBinder>& dpy) const {
         return mDisplays.valueFor(dpy);
@@ -422,7 +429,7 @@ private:
     EGLContext mEGLContext;
     EGLConfig mEGLConfig;
     EGLDisplay mEGLDisplay;
-    sp<IBinder> mDefaultDisplays[DisplayDevice::NUM_DISPLAY_TYPES];
+    sp<IBinder> mBuiltinDisplays[DisplayDevice::NUM_DISPLAY_TYPES];
 
     // Can only accessed from the main thread, these members
     // don't need synchronization
@@ -458,6 +465,88 @@ private:
      */
 
     sp<IBinder> mExtDisplayToken;
+
+    // [MTK] {{{
+
+private:
+    // boot time info
+    bool mBootAnimationEnabled;
+
+    // track FPS for threadLoop
+    FpsCounter mFps;
+
+    // for lazy swap
+    static bool mContentsDirty;
+    void checkLayersSwapRequired(sp<const DisplayDevice>& hw,
+                                 const bool prevGlesComposition);
+
+    // for debug
+    void setMTKProperties();
+    void setMTKProperties(String8 &result);
+
+    // control thread priority
+    status_t adjustPriority() const;
+
+    // decide to run boot animation
+    bool isEnableBootAnim() const;
+
+    // set boot done msg
+    void bootProf(int start) const;
+
+    status_t captureTransform(void* const dst, size_t size, int sw, int sh,
+                              uint32_t* w, uint32_t* h, int orient);
+
+public:
+    struct PropertiesState {
+        // force to swap buffer every frame
+        bool mBusySwap;
+
+        // sf repaint log info
+        bool mLogRepaint;
+
+        // log buffer queue status use in SF
+        bool mLogBuffer;
+
+        // debug G3D render
+        bool mLineG3D;
+
+        // debug screen shot state
+        bool mLineScreenShot;
+
+        // debug dump screen shot to pic
+        bool mDumpScreenShot;
+
+        // switch S3D debug mode
+        bool mDebugS3D;
+
+        // for enabling slow motion
+        uint32_t mDelayTime;
+
+        // for continuous buffers dump
+        int mContBufsDump;
+
+        PropertiesState()
+            : mBusySwap(false)
+            , mLogRepaint(false)
+            , mLogBuffer(false)
+            , mLineG3D(false)
+            , mLineScreenShot(false)
+            , mDumpScreenShot(false)
+            , mDebugS3D(false)
+            , mDelayTime(0)
+            , mContBufsDump(0)
+        { }
+    };
+    static PropertiesState mPropertiesState;
+
+    bool mForceContBufsDumpStop;
+    mutable Mutex mDumpLock;
+
+    uint32_t mWatchDogIndex;
+
+    bool getAndClearLayersSwapRequired(int32_t id);
+
+    // [MTK] }}}
 };
 
 // ---------------------------------------------------------------------------
diff --git a/frameworks/native/services/surfaceflinger/SurfaceTextureLayer.h b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/SurfaceTextureLayer.h
index e892ea0..60f1075 100644
--- a/frameworks/native/services/surfaceflinger/SurfaceTextureLayer.h
+++ b/gb/12055-master/driveronly_mp_rom/frameworks/native/services/surfaceflinger/SurfaceTextureLayer.h
@@ -38,6 +38,19 @@ public:
     ~SurfaceTextureLayer();
 
     virtual status_t connect(int api, QueueBufferOutput* output);
+
+    // [MTK] {{{
+public:
+    // for get real type
+    virtual int32_t getType() const {
+        return BufferQueue::TYPE_SurfaceTextureLayer;
+    }
+
+    // for buffer log
+    virtual status_t queueBuffer(int buf,
+                                 const QueueBufferInput& input,
+                                 QueueBufferOutput* output);
+    // [MTK] }}}
 };
 
 // ---------------------------------------------------------------------------

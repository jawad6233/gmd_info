diff --git a/system/core/adb/Android.mk b/gb/12055-master/driveronly_mp_rom/system/core/adb/Android.mk
index bc8315e..3a42aa4 100644
--- a/system/core/adb/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/system/core/adb/Android.mk
@@ -49,6 +49,7 @@ ifeq ($(HOST_OS),windows)
   LOCAL_C_INCLUDES += development/host/windows/usb/api/
 endif
 
+LOCAL_C_INCLUDES += mediatek/kernel/drivers/video
 LOCAL_SRC_FILES := \
 	adb.c \
 	console.c \
@@ -99,6 +100,7 @@ endif
 
 include $(CLEAR_VARS)
 
+LOCAL_C_INCLUDES += mediatek/kernel/drivers/video
 LOCAL_SRC_FILES := \
 	adb.c \
 	backup_service.c \
@@ -120,7 +122,18 @@ LOCAL_SRC_FILES := \
 LOCAL_CFLAGS := -O2 -g -DADB_HOST=0 -Wall -Wno-unused-parameter
 LOCAL_CFLAGS += -D_XOPEN_SOURCE -D_GNU_SOURCE
 
-ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
+ifeq ($(MTK_EMULATOR_SUPPORT),yes)
+LOCAL_CFLAGS += -DEMULATOR_PROJECT
+endif
+
+#ifndef VENDOR_EDIT
+#LinJie.Xu@Prd.SysSrv.USB, 2013/03/30, Modify for user version could get root permission by change property
+#ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
+#else /* VENDOR_EDIT */
+ifneq (,$(filter userdebug user eng,$(TARGET_BUILD_VARIANT)))
+#endif /* VENDOR_EDIT */
+
+
 LOCAL_CFLAGS += -DALLOW_ADBD_ROOT=1
 endif
 
diff --git a/system/core/adb/adb.c b/gb/12055-master/driveronly_mp_rom/system/core/adb/adb.c
index 07bfbe5..4db494b 100644
--- a/system/core/adb/adb.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/adb/adb.c
@@ -53,7 +53,7 @@ static int auth_enabled = 0;
 static const char *adb_device_banner = "device";
 #endif
 
-void fatal(const char *fmt, ...)
+void adb_fatal(const char *fmt, ...)
 {
     va_list ap;
     va_start(ap, fmt);
@@ -64,7 +64,7 @@ void fatal(const char *fmt, ...)
     exit(-1);
 }
 
-void fatal_errno(const char *fmt, ...)
+void adb_fatal_errno(const char *fmt, ...)
 {
     va_list ap;
     va_start(ap, fmt);
@@ -211,13 +211,14 @@ void handle_online(atransport *t)
 {
     D("adb: online\n");
     t->online = 1;
+    XLOGD("adb: online\n");
 }
 
 void handle_offline(atransport *t)
 {
     D("adb: offline\n");
+    XLOGD("adb: offline\n");
     //Close the associated usb
-    t->online = 0;
     run_transport_disconnects(t);
 }
 
@@ -315,6 +316,7 @@ static size_t fill_connect_data(char *buf, size_t bufsize)
 static void send_connect(atransport *t)
 {
     D("Calling send_connect \n");
+    XLOGD("Calling send_connect \n");
     apacket *cp = get_apacket();
     cp->msg.command = A_CNXN;
     cp->msg.arg0 = A_VERSION;
@@ -322,6 +324,11 @@ static void send_connect(atransport *t)
     cp->msg.data_length = fill_connect_data((char *)cp->data,
                                             sizeof(cp->data));
     send_packet(cp, t);
+#if ADB_HOST
+        /* XXX why sleep here? */
+    // allow the device some time to respond to the connect message
+    adb_sleep_ms(1000);
+#endif
 }
 
 static void send_auth_request(atransport *t)
@@ -455,7 +462,7 @@ void parse_banner(char *banner, atransport *t)
                 }
                 key = adb_strtok_r(NULL, prop_seps, &save);
             }
-        }
+    }
     }
 
     if(!strcmp(type, "bootloader")){
@@ -501,6 +508,8 @@ void handle_packet(apacket *p, atransport *t)
 
     switch(p->msg.command){
     case A_SYNC:
+        XLOGD("%s: %s %08x %08x %04x \n",
+            "recv", "SYNC", p->msg.arg0, p->msg.arg1, p->msg.data_length);
         if(p->msg.arg0){
             send_packet(p, t);
             if(HOST) send_connect(t);
@@ -513,6 +522,8 @@ void handle_packet(apacket *p, atransport *t)
 
     case A_CNXN: /* CONNECT(version, maxdata, "system-id-string") */
             /* XXX verify version, etc */
+       XLOGD("%s: %s %08x %08x %04x %s\n",
+            "recv", "CNXN", p->msg.arg0, p->msg.arg1, p->msg.data_length, p->data);
         if(t->connection_state != CS_OFFLINE) {
             t->connection_state = CS_OFFLINE;
             handle_offline(t);
@@ -604,6 +615,7 @@ void handle_packet(apacket *p, atransport *t)
 
     default:
         printf("handle_packet: what is %08x?!\n", p->msg.command);
+        XLOGW("handle_packet: what is %08x?!\n", p->msg.command);
     }
 
     put_apacket(p);
@@ -635,6 +647,8 @@ static void ss_listener_event_func(int _fd, unsigned ev, void *_l)
             return;
         }
 
+        D("ss_listener_event_func adb_close \n");
+        XLOGD("ss_listener_event_func adb_close \n");
         adb_close(fd);
     }
 }
@@ -660,6 +674,8 @@ static void listener_event_func(int _fd, unsigned ev, void *_l)
             return;
         }
 
+        D("listener_event_func adb_close \n");
+        XLOGD("listener_event_func adb_close \n");
         adb_close(fd);
     }
 }
@@ -719,6 +735,7 @@ int local_name_to_fd(const char *name)
 
 #endif
     printf("unknown local portname '%s'\n", name);
+    XLOGD("unknown local portname '%s'\n", name);
     return -1;
 }
 
@@ -744,6 +761,7 @@ static int install_listener(const char *local_name, const char *connect_to, atra
     alistener *l;
 
     //printf("install_listener('%s','%s')\n", local_name, connect_to);
+    XLOGD("install_listener('%s','%s')\n", local_name, connect_to);
 
     for(l = listener_list.next; l != &listener_list; l = l->next){
         if(strcmp(local_name, l->local_name) == 0) {
@@ -782,6 +800,7 @@ static int install_listener(const char *local_name, const char *connect_to, atra
         free((void*) l->connect_to);
         free(l);
         printf("cannot bind '%s'\n", local_name);
+        XLOGD("cannot bind '%s'\n", local_name);
         return -2;
     }
 
@@ -1195,8 +1214,8 @@ int adb_main(int is_daemon, int server_port)
     // If one of these properties is set, also listen on that port
     // If one of the properties isn't set and we couldn't listen on usb,
     // listen on the default port.
-    property_get("service.adb.tcp.port", value, "");
-    if (!value[0]) {
+     property_get("service.adb.tcp.port", value, "");
+    if (!value[0]){
         property_get("persist.adb.tcp.port", value, "");
     }
     if (sscanf(value, "%d", &port) == 1 && port > 0) {
@@ -1209,8 +1228,10 @@ int adb_main(int is_daemon, int server_port)
     }
 
     D("adb_main(): pre init_jdwp()\n");
+    XLOGD("adb_main(): pre init_jdwp()\n");
     init_jdwp();
     D("adb_main(): post init_jdwp()\n");
+    XLOGD("adb_main(): post init_jdwp()\n");
 #endif
 
     if (is_daemon)
@@ -1225,6 +1246,7 @@ int adb_main(int is_daemon, int server_port)
         start_logging();
     }
     D("Event loop starting\n");
+    XLOGD("Event loop starting\n");
 
     fdevent_loop();
 
@@ -1377,20 +1399,20 @@ int handle_host_request(char *service, transport_type ttype, char* serial, int r
     }
 
     // return a list of all connected devices
-    if (!strncmp(service, "devices", 7)) {
+    if (!strncmp(service, "devices", 7)) {  
         char buffer[4096];
-        int use_long = !strcmp(service+7, "-l");
-        if (use_long || service[7] == 0) {
+        int use_long = !strcmp(service+7, "-l"); 
+        if (use_long || service[7] == 0) {   
             memset(buf, 0, sizeof(buf));
             memset(buffer, 0, sizeof(buffer));
             D("Getting device list \n");
-            list_transports(buffer, sizeof(buffer), use_long);
+            list_transports(buffer, sizeof(buffer), use_long); 
             snprintf(buf, sizeof(buf), "OKAY%04x%s",(unsigned)strlen(buffer),buffer);
             D("Wrote device list \n");
             writex(reply_fd, buf, strlen(buf));
             return 0;
         }
-    }
+    } 
 
     // add a new TCP transport, device or emulator
     if (!strncmp(service, "connect:", 8)) {
diff --git a/system/core/adb/adb.h b/gb/12055-master/driveronly_mp_rom/system/core/adb/adb.h
index 9da8af8..c1df639 100644
--- a/system/core/adb/adb.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/adb/adb.h
@@ -21,6 +21,17 @@
 
 #include "transport.h"  /* readx(), writex() */
 
+#if !ADB_HOST
+#  include <cutils/xlog.h>
+#  define LOG_TAG "ADB_SERVICES"
+#else
+#  define XLOGV(...)          ((void)0)
+#  define XLOGD(...)          ((void)0)
+#  define XLOGW(...)          ((void)0)
+#  define XLOGI(...)          ((void)0)
+#  define XLOGE(...)          ((void)0)
+#endif
+
 #define MAX_PAYLOAD 4096
 
 #define A_SYNC 0x434e5953
@@ -250,8 +261,12 @@ asocket *create_remote_socket(unsigned id, atransport *t);
 void connect_to_remote(asocket *s, const char *destination);
 void connect_to_smartsocket(asocket *s);
 
-void fatal(const char *fmt, ...);
-void fatal_errno(const char *fmt, ...);
+void adb_fatal(const char *fmt, ...);
+void adb_fatal_errno(const char *fmt, ...);
+
+#define fatal(x...) do{ adb_fatal(x); XLOGE(x); }while(0)
+#define fatal_errno(x...) do{ adb_fatal(x); XLOGE(x); }while(0)
+
 
 void handle_packet(apacket *p, atransport *t);
 void send_packet(apacket *p, atransport *t);
diff --git a/system/core/adb/fdevent.c b/gb/12055-master/driveronly_mp_rom/system/core/adb/fdevent.c
index 5c374a7..d9f0636 100644
--- a/system/core/adb/fdevent.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/adb/fdevent.c
@@ -244,6 +244,17 @@ static void fdevent_process()
 #include <sys/select.h>
 #endif
 
+#if !ADB_HOST
+#  include <cutils/xlog.h>
+#  define LOG_TAG "ADB_SERVICES"
+#else
+#  define XLOGV(...)          ((void)0)
+#  define XLOGD(...)          ((void)0)
+#  define XLOGW(...)          ((void)0)
+#  define XLOGI(...)          ((void)0)
+#  define XLOGE(...)          ((void)0)
+#endif
+
 static fd_set read_fds;
 static fd_set write_fds;
 static fd_set error_fds;
@@ -362,6 +373,10 @@ int i;
 }
 #endif
 
+#define FDEVENT_ARRAY_SIZE 64
+clock_t last_fdevent_time = 0;
+int fdevent_array[FDEVENT_ARRAY_SIZE] = {0};
+int fdevent_idx = 0;
 static void fdevent_process()
 {
     int i, n;
@@ -418,6 +433,43 @@ static void fdevent_process()
                 fde->fd, fde->events, fde->state);
             if(fde->state & FDE_PENDING) continue;
             fde->state |= FDE_PENDING;
+#if !ADB_HOST
+            bool bFound = false;
+            int idx = 0;
+            for(idx = 0; idx < FDEVENT_ARRAY_SIZE; ++idx){
+                if(fdevent_array[idx] == fde->fd){
+                    //Do not need to update array
+                    bFound = true;
+                    break;
+                }
+            }
+
+            if(bFound == false){
+                if(fdevent_idx > FDEVENT_ARRAY_SIZE - 1){
+                    //Out of range, so we have to print fd directly
+                    XLOGD("Too many fdevent_process fd=%d, ", fde->fd);
+                }else{
+                    fdevent_array[fdevent_idx] = fde->fd;
+                    fdevent_idx++;
+                }
+            }
+
+            clock_t this_fdevent_time = clock();
+            double cpu_time_used = ((double) (this_fdevent_time - last_fdevent_time)) / CLOCKS_PER_SEC;
+            if( cpu_time_used > 5.0 ){
+                char output_log[512];
+                char tmp[16];
+                sprintf(output_log, "%s", "adb fdevent_process list ");
+                for(idx = 0; idx < fdevent_idx; ++idx){
+                    sprintf(tmp, "(%d) ", fdevent_array[idx]);
+                    strcat(output_log, tmp);
+                    fdevent_array[idx] = 0;
+                }
+                XLOGD("%s\n", output_log);
+                last_fdevent_time = this_fdevent_time;
+                fdevent_idx = 0;
+            }
+#endif
             fdevent_plist_enqueue(fde);
         }
     }
diff --git a/system/core/adb/framebuffer_service.c b/gb/12055-master/driveronly_mp_rom/system/core/adb/framebuffer_service.c
index 20c08d2..f0dc26f 100644
--- a/system/core/adb/framebuffer_service.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/adb/framebuffer_service.c
@@ -30,6 +30,21 @@
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 
+#if defined(EMULATOR_PROJECT)
+	#define LCDC_CAPTURE   (0)
+#else
+	#define LCDC_CAPTURE   (1)
+#endif
+
+#if LCDC_CAPTURE
+#include "mtkfb.h"
+// TODO: include from <linux/fb.h>
+#define FBIOLOCK_FB             0x4630
+#define FBIOUNLOCK_FB           0x4631
+#define FBIOLOCKED_IOCTL        0x4632
+static void lcdc_screen_cap(void);
+static int vinfoToPixelFormat(struct fb_var_screeninfo* vinfo, uint32_t* bytespp, uint32_t* f);
+#endif
 /* TODO:
 ** - sync with vsync to avoid tearing
 */
@@ -52,12 +67,15 @@ struct fbinfo {
     unsigned int alpha_length;
 } __attribute__((packed));
 
+#define LOG_TAG "ddmscap"
+#include <utils/Log.h>
+
 void framebuffer_service(int fd, void *cookie)
 {
     struct fbinfo fbinfo;
     unsigned int i;
     char buf[640];
-    int fd_screencap;
+    int fd_screencap,fb;
     int w, h, f;
     int fds[2];
 
@@ -70,10 +88,24 @@ void framebuffer_service(int fd, void *cookie)
         dup2(fds[1], STDOUT_FILENO);
         close(fds[0]);
         close(fds[1]);
+    #if (0 == LCDC_CAPTURE)
         const char* command = "screencap";
         const char *args[2] = {command, NULL};
         execvp(command, (char**)args);
         exit(1);
+    #else // #if (LCDC_CAPTURE)
+        if ((fb=open("/system/bin/lcdc_screen_cap",O_RDONLY)) >= 0){
+            close(fb);
+            const char * command = "lcdc_screen_cap";
+	    const char *args[2] = {command, NULL};
+            execvp(command, (char**)args);
+            exit(1);
+    }
+        else{
+        lcdc_screen_cap();
+        exit(0);
+        }
+    #endif
     }
 
     fd_screencap = fds[0];
@@ -178,3 +210,120 @@ done:
     close(fds[1]);
     close(fd);
 }
+
+#if LCDC_CAPTURE
+static int vinfoToPixelFormat(struct fb_var_screeninfo* vinfo,
+                              uint32_t* bytespp, uint32_t* f)
+{
+
+    switch (vinfo->bits_per_pixel) {
+        case 16:
+            *f = 4; //PIXEL_FORMAT_RGB_565
+            *bytespp = 2;
+            break;
+        case 24:
+            *f = 3; //PIXEL_FORMAT_RGB_888
+            *bytespp = 3;
+            break;
+        case 32:
+            // TODO: do better decoding of vinfo here
+            //*f = PIXEL_FORMAT_RGBX_8888;
+            *f = 5; //PIXEL_FORMAT_BGRA_8888
+            *bytespp = 4;
+            break;
+        default:
+            return -1;
+    }
+    return 0;
+}
+
+static void lcdc_screen_cap(void)
+{
+    int step = 0;
+    int fd = dup(STDOUT_FILENO);
+    unsigned long fb_lock[2]   = {MTKFB_LOCK_FRONT_BUFFER,   (unsigned long)NULL};
+    unsigned long fb_unlock[2] = {MTKFB_UNLOCK_FRONT_BUFFER, (unsigned long)NULL};
+    unsigned long fb_capture[2] = {MTKFB_CAPTURE_FRAMEBUFFER, (unsigned long)NULL};
+    void *base = NULL, *base_align = NULL;
+    int capture_buffer_size = 0, capture_buffer_size_align = 0;
+    struct fb_var_screeninfo vinfo;
+    int fb;
+    uint32_t bytespp;
+    uint32_t w, h, f;
+    size_t size = 0;
+
+    if (0 > (fb = open("/dev/graphics/fb0", O_RDONLY))) goto done;
+    //LOGI("[DDMSCap]Open /dev/graphics/fb0\n");
+    fcntl(fb, F_SETFD, FD_CLOEXEC);
+    if(ioctl(fb, FBIOGET_VSCREENINFO, &vinfo) < 0) goto done;
+    //LOGI("[DDMSCap]FBIOGET_VSCREENINFO\n");
+    if(ioctl(fb, FBIOLOCK_FB, NULL) < 0) goto done;
+    //LOGI("[DDMSCap]FBIOLOCK_FB\n");
+    ++ step; //1
+    if(ioctl(fb, FBIOLOCKED_IOCTL, fb_lock) < 0) goto done;
+    //LOGI("[DDMSCap]FBIOLOCKED_IOCTL\n");
+    ++ step; //2
+
+    if (vinfoToPixelFormat(&vinfo, &bytespp, &f) == 0) 
+    {
+        w = vinfo.xres;
+        h = vinfo.yres;
+        size = w * h * bytespp;
+        ALOGI("[DDMSCap]screen_width = %d, screen_height = %d, bpp = %d, format = %d, size = %d\n", w, h, bytespp, f, size);
+    }
+    {
+        capture_buffer_size = w * h * bytespp;
+        capture_buffer_size_align = capture_buffer_size + 32; //for M4U 32-byte alignment
+        base_align = malloc(capture_buffer_size_align);
+
+        if(base_align == NULL)
+        {
+            ALOGE("[DDMSCap]pmem_alloc size 0x%08x failed", capture_buffer_size_align);
+            goto done;
+        }
+        else
+        {
+             ALOGI("[DDMSCap]pmem_alloc size = 0x%08x, addr = 0x%08x", capture_buffer_size_align, base_align);
+        }
+
+        base = (void *)((unsigned long)base_align + 32 - ((unsigned long)base_align & 0x1F)); //for M4U 32-byte alignment
+        ALOGI("[DDMSCap]pmem_alloc base = 0x%08x", base);
+        fb_capture[1] = (unsigned long)&base;
+        if(ioctl(fb, FBIOLOCKED_IOCTL, fb_capture) < 0)
+        {
+            ALOGE("[DDMSCap]ioctl of MTKFB_CAPTURE_FRAMEBUFFER fail\n");
+            goto done;
+        }
+
+        if (step > 1) 
+            ioctl(fb, FBIOLOCKED_IOCTL, fb_unlock);
+        if (step > 0) 
+            ioctl(fb, FBIOUNLOCK_FB, NULL);
+
+        ++ step; //3
+    }
+
+    if (base) 
+    {
+        {
+            write(fd, &w, 4);
+            write(fd, &h, 4);
+            write(fd, &f, 4);
+            write(fd, base, size);
+        }
+    }
+done:
+    if (NULL != base_align)
+        free(base_align);
+    if (step < 3)
+    {
+        if (step > 1) 
+            ioctl(fb, FBIOLOCKED_IOCTL, fb_unlock);
+        if (step > 0) 
+            ioctl(fb, FBIOUNLOCK_FB, NULL);
+    }
+    if(fb >= 0) close(fb);
+    close(fd);
+    return 0;
+}
+#endif //#if LCDC_CAPTURE
diff --git a/system/core/adb/jdwp_service.c b/gb/12055-master/driveronly_mp_rom/system/core/adb/jdwp_service.c
index cd62b55..b97f33f 100644
--- a/system/core/adb/jdwp_service.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/adb/jdwp_service.c
@@ -198,6 +198,7 @@ jdwp_process_alloc( int  socket )
 
     if (proc == NULL) {
         D("not enough memory to create new JDWP process\n");
+        XLOGW("not enough memory to create new JDWP process\n");
         return NULL;
     }
 
@@ -209,6 +210,7 @@ jdwp_process_alloc( int  socket )
     proc->fde = fdevent_create( socket, jdwp_process_event, proc );
     if (proc->fde == NULL) {
         D("could not create fdevent for new JDWP process\n" );
+        XLOGW("could not create fdevent for new JDWP process\n" );
         free(proc);
         return NULL;
     }
@@ -253,10 +255,14 @@ jdwp_process_event( int  socket, unsigned  events, void*  _proc )
                     D("weird unknown JDWP process failure: %s\n",
                       strerror(errno));
 
+                    XLOGW("weird unknown JDWP process failure: %s\n",
+                      strerror(errno));
+
                     goto CloseProcess;
                 }
                 if (len == 0) {  /* end of stream ? */
                     D("weird end-of-stream from unknown JDWP process\n");
+                    XLOGW("weird end-of-stream from unknown JDWP process\n");
                     goto CloseProcess;
                 }
                 p            += len;
@@ -269,11 +275,13 @@ jdwp_process_event( int  socket, unsigned  events, void*  _proc )
 
             if (sscanf( temp, "%04x", &proc->pid ) != 1) {
                 D("could not decode JDWP %p PID number: '%s'\n", proc, temp);
+                XLOGW("could not decode JDWP %p PID number: '%s'\n", proc, temp);
                 goto CloseProcess;
             }
 
             /* all is well, keep reading to detect connection closure */
             D("Adding pid %d to jdwp process list\n", proc->pid);
+            XLOGD("Adding socket %d pid %d to jdwp process list\n", proc->socket, proc->pid);
             jdwp_process_list_updated();
         }
         else
@@ -293,18 +301,24 @@ jdwp_process_event( int  socket, unsigned  events, void*  _proc )
                     else {
                         D("terminating JDWP %d connection: %s\n", proc->pid,
                           strerror(errno));
+                        XLOGW("terminating JDWP %d connection: %s\n", proc->pid,
+                          strerror(errno));
                         break;
                     }
                 }
                 else {
                     D( "ignoring unexpected JDWP %d control socket activity (%d bytes)\n",
                        proc->pid, len );
+                    XLOGW( "ignoring unexpected JDWP %d control socket activity (%d bytes)\n",
+                       proc->pid, len );
                 }
             }
 
         CloseProcess:
-            if (proc->pid >= 0)
+            if (proc->pid >= 0) {
                 D( "remove pid %d to jdwp process list\n", proc->pid );
+                XLOGD( "remove pid %d to jdwp process list\n", proc->pid );
+            }
             jdwp_process_free(proc);
             return;
         }
@@ -313,6 +327,8 @@ jdwp_process_event( int  socket, unsigned  events, void*  _proc )
     if (events & FDE_WRITE) {
         D("trying to write to JDWP pid controli (count=%d first=%d) %d\n",
           proc->pid, proc->out_count, proc->out_fds[0]);
+        XLOGW("trying to write to JDWP socket=%d pid=%d count=%d out_fds=%d\n",
+          proc->socket, proc->pid, proc->out_count, proc->out_fds[0]);
         if (proc->out_count > 0) {
             int  fd = proc->out_fds[0];
             int  n, ret;
@@ -344,6 +360,8 @@ jdwp_process_event( int  socket, unsigned  events, void*  _proc )
             if (flags == -1) {
                 D("failed to get cntl flags for socket %d: %s\n",
                   proc->pid, strerror(errno));
+                XLOGW("failed to get cntl flags for socket %d: %s\n",
+                  proc->pid, strerror(errno));
                 goto CloseProcess;
 
             }
@@ -351,6 +369,8 @@ jdwp_process_event( int  socket, unsigned  events, void*  _proc )
             if (fcntl(proc->socket, F_SETFL, flags & ~O_NONBLOCK) == -1) {
                 D("failed to remove O_NONBLOCK flag for socket %d: %s\n",
                   proc->pid, strerror(errno));
+                XLOGW("failed to remove O_NONBLOCK flag for socket %d: %s\n",
+                  proc->pid, strerror(errno));
                 goto CloseProcess;
             }
 
@@ -364,6 +384,8 @@ jdwp_process_event( int  socket, unsigned  events, void*  _proc )
                     continue;
                 D("sending new file descriptor to JDWP %d failed: %s\n",
                   proc->pid, strerror(errno));
+                XLOGW("sending new file descriptor to JDWP %d failed: %s\n",
+                  proc->pid, strerror(errno));
                 goto CloseProcess;
             }
 
@@ -376,6 +398,8 @@ jdwp_process_event( int  socket, unsigned  events, void*  _proc )
             if (fcntl(proc->socket, F_SETFL, flags) == -1) {
                 D("failed to set O_NONBLOCK flag for socket %d: %s\n",
                   proc->pid, strerror(errno));
+                XLOGW("failed to set O_NONBLOCK flag for socket %d: %s\n",
+                  proc->pid, strerror(errno));
                 goto CloseProcess;
             }
 
@@ -398,6 +422,7 @@ create_jdwp_connection_fd(int  pid)
         }
     }
     D("search failed !!\n");
+    XLOGW("search failed !!\n");
     return -1;
 
 FoundIt:
@@ -407,12 +432,16 @@ FoundIt:
         if (proc->out_count >= MAX_OUT_FDS) {
             D("%s: too many pending JDWP connection for pid %d\n",
               __FUNCTION__, pid);
+            XLOGW("%s: too many pending JDWP connection for pid %d\n",
+              __FUNCTION__, pid);
             return -1;
         }
 
         if (adb_socketpair(fds) < 0) {
             D("%s: socket pair creation failed: %s\n",
               __FUNCTION__, strerror(errno));
+            XLOGW("%s: socket pair creation failed: %s\n",
+              __FUNCTION__, strerror(errno));
             return -1;
         }
 
@@ -420,6 +449,8 @@ FoundIt:
         if (++proc->out_count == 1)
             fdevent_add( proc->fde, FDE_WRITE );
 
+        XLOGW("looking for pid %d in JDWP process list return fds0(%d) fds1(%d)\n", pid, fds[0], fds[1]);
+
         return fds[0];
     }
 }
@@ -458,6 +489,8 @@ jdwp_control_init( JdwpControl*  control,
     if (pathlen >= maxpath) {
         D( "vm debug control socket name too long (%d extra chars)\n",
            pathlen+1-maxpath );
+        XLOGW( "vm debug control socket name too long (%d extra chars)\n",
+           pathlen+1-maxpath );
         return -1;
     }
 
@@ -469,6 +502,8 @@ jdwp_control_init( JdwpControl*  control,
     if (s < 0) {
         D( "could not create vm debug control socket. %d: %s\n",
            errno, strerror(errno));
+        XLOGW( "could not create vm debug control socket. %d: %s\n",
+           errno, strerror(errno));
         return -1;
     }
 
@@ -477,6 +512,8 @@ jdwp_control_init( JdwpControl*  control,
     if (bind(s, (struct sockaddr*)&addr, addrlen) < 0) {
         D( "could not bind vm debug control socket: %d: %s\n",
            errno, strerror(errno) );
+        XLOGW( "could not bind vm debug control socket: %d: %s\n",
+           errno, strerror(errno) );
         adb_close(s);
         return -1;
     }
@@ -484,6 +521,8 @@ jdwp_control_init( JdwpControl*  control,
     if ( listen(s, 4) < 0 ) {
         D("listen failed in jdwp control socket: %d: %s\n",
           errno, strerror(errno));
+        XLOGW("listen failed in jdwp control socket: %d: %s\n",
+          errno, strerror(errno));
         adb_close(s);
         return -1;
     }
@@ -493,6 +532,7 @@ jdwp_control_init( JdwpControl*  control,
     control->fde = fdevent_create(s, jdwp_control_event, control);
     if (control->fde == NULL) {
         D( "could not create fdevent for jdwp control socket\n" );
+        XLOGW( "could not create fdevent for jdwp control socket\n" );
         adb_close(s);
         return -1;
     }
@@ -525,11 +565,14 @@ jdwp_control_event( int  s, unsigned  events, void*  _control )
                 if (errno == ECONNABORTED) {
                     /* oops, the JDWP process died really quick */
                     D("oops, the JDWP process died really quick\n");
+                    XLOGW("oops, the JDWP process died really quick\n");
                     return;
                 }
                 /* the socket is probably closed ? */
                 D( "weird accept() failed on jdwp control socket: %s\n",
                    strerror(errno) );
+                XLOGW( "weird accept() failed on jdwp control socket: %s\n",
+                   strerror(errno) );
                 return;
             }
         }
diff --git a/system/core/adb/log_service.c b/gb/12055-master/driveronly_mp_rom/system/core/adb/log_service.c
index 6e9bdee..c0f0129 100644
--- a/system/core/adb/log_service.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/adb/log_service.c
@@ -28,7 +28,7 @@
 
 #define LOG_FILE_DIR    "/dev/log/"
 
-void write_log_entry(int fd, struct logger_entry *buf);
+int write_log_entry(int fd, struct logger_entry *buf);
 
 void log_service(int fd, void *cookie)
 {
@@ -64,7 +64,10 @@ void log_service(int fd, void *cookie)
 
         entry->msg[entry->len] = '\0';
 
-        write_log_entry(fd, entry);
+        if (write_log_entry(fd, entry) < 0)
+        {
+            goto done;
+        }
     }
 
 done:
@@ -84,9 +87,9 @@ char * get_log_file_path(const char * log_name) {
 
 
 /* prints one log entry into the file descriptor fd */
-void write_log_entry(int fd, struct logger_entry *buf)
+int write_log_entry(int fd, struct logger_entry *buf)
 {
     size_t size = sizeof(struct logger_entry) + buf->len;
 
-    writex(fd, buf, size);
+    return writex(fd, buf, size);
 }
diff --git a/system/core/adb/services.c b/gb/12055-master/driveronly_mp_rom/system/core/adb/services.c
index 495a083..79d1550 100644
--- a/system/core/adb/services.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/adb/services.c
@@ -235,6 +235,7 @@ static int create_service_thread(void (*func)(int, void *), void *cookie)
 
     if(adb_socketpair(s)) {
         printf("cannot create service socket pair\n");
+        XLOGW("cannot create service socket pair\n");
         return -1;
     }
 
@@ -249,6 +250,7 @@ static int create_service_thread(void (*func)(int, void *), void *cookie)
         adb_close(s[0]);
         adb_close(s[1]);
         printf("cannot create service thread\n");
+        XLOGW("cannot create service thread\n");
         return -1;
     }
 
@@ -257,6 +259,13 @@ static int create_service_thread(void (*func)(int, void *), void *cookie)
 }
 
 #if !ADB_HOST
+void catcher()
+{
+    D("Enter catcher : wait too long in create_subprocess\n");
+    XLOGV("Enter catcher : wait too long in create_subprocess\n");
+    exit(-1);
+}
+
 static int create_subprocess(const char *cmd, const char *arg0, const char *arg1, pid_t *pid)
 {
 #ifdef HAVE_WIN32_PROC
@@ -283,7 +292,8 @@ static int create_subprocess(const char *cmd, const char *arg0, const char *arg1
 
     *pid = fork();
     if(*pid < 0) {
-        printf("- fork failed: %s -\n", strerror(errno));
+        printf("- fork failed: pid(%d) %s -\n", *pid, strerror(errno));
+        XLOGV("- fork failed: pid(%d) %s -\n", *pid, strerror(errno));
         adb_close(ptm);
         return -1;
     }
@@ -296,6 +306,7 @@ static int create_subprocess(const char *cmd, const char *arg0, const char *arg1
         pts = unix_open(devname, O_RDWR);
         if(pts < 0) {
             fprintf(stderr, "child failed to open pseudo-term slave: %s\n", devname);
+            XLOGV("child failed to open pseudo-term slave: %s\n", devname);
             exit(-1);
         }
 
@@ -315,10 +326,55 @@ static int create_subprocess(const char *cmd, const char *arg0, const char *arg1
             adb_close(fd);
         } else {
            D("adb: unable to open %s\n", text);
+           XLOGW("adb: unable to open %s\n", text);
+        }
+
+        timer_t timerid;
+        struct sigevent sev;
+        /* Create the timer */
+        sev.sigev_notify = SIGEV_SIGNAL;
+        sev.sigev_signo = SIGALRM;
+        sev.sigev_value.sival_ptr = &timerid;
+        if (timer_create(CLOCK_REALTIME, &sev, &timerid) == -1)
+        {
+            D("adb: Call timer_create failed!\n");
+            XLOGV("adb: Call timer_create failed!\n");
+            exit(-1);
+        }
+
+        struct itimerspec its;
+        /* Start the timer */
+        its.it_value.tv_sec = 1;
+        its.it_value.tv_nsec = 0;
+        its.it_interval.tv_sec = 3;
+        its.it_interval.tv_nsec = 0;
+
+        if (timer_settime(timerid, 0, &its, NULL) == -1)
+        {
+            D("adb: Call timer_settime failed!\n");
+            XLOGV("adb: Call timer_settime failed!\n");
+            exit(-1);
         }
-        execl(cmd, cmd, arg0, arg1, NULL);
-        fprintf(stderr, "- exec '%s' failed: %s (%d) -\n",
-                cmd, strerror(errno), errno);
+
+        sigset_t mask;
+        struct sigaction sa;
+        /* Establish handler for timer signal */
+        sa.sa_flags = SA_SIGINFO;
+        sa.sa_sigaction = catcher;
+        sigemptyset(&sa.sa_mask);
+        if (sigaction(SIGALRM, &sa, NULL) == -1)
+        {
+            D("adb: Call sigaction failed!\n");
+            XLOGV("adb: Call sigaction failed!\n");
+            exit(-1);
+        }
+
+        int nRet = execl(cmd, cmd, arg0, arg1, NULL);
+
+        fprintf(stderr, "- exec '%s' failed: %s (%d) nRet(%d) -\n",
+                cmd, strerror(errno), errno, nRet);
+        XLOGV("- exec '%s' failed: %s (%d) nRet(%d) -\n",
+                cmd, strerror(errno), errno, nRet);
         exit(-1);
     } else {
         // Don't set child's OOM adjustment to zero.
@@ -345,22 +401,26 @@ static void subproc_waiter_service(int fd, void *cookie)
     D("entered. fd=%d of pid=%d\n", fd, pid);
     for (;;) {
         int status;
-        pid_t p = waitpid(pid, &status, 0);
-        if (p == pid) {
-            D("fd=%d, post waitpid(pid=%d) status=%04x\n", fd, p, status);
+        pid_t p = waitpid(-1/*pid*/, &status, 0);
+        D("fd=%d, post waitpid(pid=%d) status=%04x %s errno(%d)\n", fd, p, status, strerror(errno), errno);
+
+		//if (p == pid) {
             if (WIFSIGNALED(status)) {
                 D("*** Killed by signal %d\n", WTERMSIG(status));
-                break;
+                //break;
             } else if (!WIFEXITED(status)) {
                 D("*** Didn't exit!!. status %d\n", status);
-                break;
+                //break;
             } else if (WEXITSTATUS(status) >= 0) {
                 D("*** Exit code %d\n", WEXITSTATUS(status));
-                break;
-            }
+                //break;
          }
+        //}
+        if ( p == -1 )
+            usleep(100000);  // poll every 0.1 sec
     }
     D("shell exited fd=%d of pid=%d err=%d\n", fd, pid, errno);
+    XLOGV("shell exited fd=%d of pid=%d err=%d\n", fd, pid, errno);
     if (SHELL_EXIT_NOTIFY_FD >=0) {
       int res;
       res = writex(SHELL_EXIT_NOTIFY_FD, &fd, sizeof(fd));
@@ -369,31 +429,65 @@ static void subproc_waiter_service(int fd, void *cookie)
     }
 }
 
+
+#define MAX_LINE 256
+char line[MAX_LINE];
+static int read_meminfo(long *mem_free)
+{
+    FILE *f;
+
+    f = fopen("/proc/meminfo", "r");
+    if (!f) return errno;
+
+    while (fgets(line, MAX_LINE, f)) {
+        sscanf(line, "MemFree: %ld kB", mem_free);
+    }
+
+    fclose(f);
+    return 0;
+}
+
+static stinfo *sti = 0;
 static int create_subproc_thread(const char *name)
 {
-    stinfo *sti;
     adb_thread_t t;
     int ret_fd;
     pid_t pid;
+
+    long mem_free = 0;
+    read_meminfo(&mem_free);
+    D("read_meminfo() mem_free=%d\n", mem_free);
+    XLOGV("read_meminfo() mem_free=%d\n", mem_free);
+
     if(name) {
         ret_fd = create_subprocess(SHELL_COMMAND, "-c", name, &pid);
     } else {
         ret_fd = create_subprocess(SHELL_COMMAND, "-", 0, &pid);
     }
     D("create_subprocess() ret_fd=%d pid=%d\n", ret_fd, pid);
+    XLOGV("create_subprocess() ret_fd=%d pid=%d\n", ret_fd, pid);
 
+    if ( sti == 0 )
+    {
     sti = malloc(sizeof(stinfo));
     if(sti == 0) fatal("cannot allocate stinfo");
     sti->func = subproc_waiter_service;
     sti->cookie = (void*)pid;
     sti->fd = ret_fd;
 
-    if(adb_thread_create( &t, service_bootstrap_func, sti)){
+        int nRet = adb_thread_create( &t, service_bootstrap_func, sti);
+
+        if(nRet)
+        {
+            D("adb_thread_create() nRet=%d errno=%d\n", nRet, errno);
+            XLOGW("adb_thread_create() nRet=%d errno=%d\n", nRet, errno);
         free(sti);
+            sti = 0;
         adb_close(ret_fd);
         printf("cannot create service thread\n");
         return -1;
     }
+    }
 
     D("service thread started, fd=%d pid=%d\n",ret_fd, pid);
     return ret_fd;
@@ -404,6 +498,10 @@ int service_to_fd(const char *name)
 {
     int ret = -1;
 
+#if !ADB_HOST
+    XLOGV("service_to_fd() name=%s\n", name);
+#endif
+
     if(!strncmp(name, "tcp:", 4)) {
         int port = atoi(name + 4);
         name = strchr(name + 4, ':');
diff --git a/system/core/adb/sockets.c b/gb/12055-master/driveronly_mp_rom/system/core/adb/sockets.c
index 305cb44..1573959 100644
--- a/system/core/adb/sockets.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/adb/sockets.c
@@ -20,6 +20,7 @@
 #include <errno.h>
 #include <string.h>
 #include <ctype.h>
+#include <sys/time.h>
 
 #include "sysdeps.h"
 
@@ -153,6 +154,7 @@ static int local_socket_enqueue(asocket *s, apacket *p)
         }
         if((r == 0) || (errno != EAGAIN)) {
             D( "LS(%d): not ready, errno=%d: %s\n", s->id, errno, strerror(errno) );
+            XLOGW( "LS(%d): not ready, errno=%d: %s\n", s->id, errno, strerror(errno) );
             s->close(s);
             return 1; /* not ready (error) */
         } else {
@@ -180,11 +182,50 @@ enqueue:
     return 1; /* not ready (backlog) */
 }
 
+#define READY_ARRAY_SIZE 64
+clock_t last_ready_time = 0;
+int fd_ready_array[READY_ARRAY_SIZE] = {0};
+int fd_ready_idx = 0;
 static void local_socket_ready(asocket *s)
 {
         /* far side is ready for data, pay attention to
            readable events */
+    bool bFound = false;
+    int i = 0;
+    for(i = 0; i < READY_ARRAY_SIZE; ++i){
+        if(fd_ready_array[i] == s->fde.fd){
+            //Do not need to update array
+            bFound = true;
+            break;
+        }
+    }
+
+    if(bFound == false){
+        if(fd_ready_idx > READY_ARRAY_SIZE - 1){
+            //Out of range, so we have to print fd directly
+            XLOGD("Too many local_socket_ready fd=%d, ", s->fde.fd);
+        }else{
+            fd_ready_array[fd_ready_idx] = s->fde.fd;
+            fd_ready_idx++;
+        }
+    }
     fdevent_add(&s->fde, FDE_READ);
+    clock_t this_ready_time = clock();
+    double cpu_time_used = ((double) (this_ready_time - last_ready_time)) / CLOCKS_PER_SEC;
+    if( cpu_time_used > 5.0 ){
+        char output_log[512];
+        char tmp[16];
+        sprintf(output_log, "%s", "adb local_socket_ready list ");
+        int i = 0;
+        for(i = 0; i < fd_ready_idx; ++i){
+            sprintf(tmp, "(%d) ", fd_ready_array[i]);
+            strcat(output_log, tmp);
+            fd_ready_array[i] = 0;
+        }
+        XLOGD("%s\n", output_log);
+        last_ready_time = this_ready_time;
+        fd_ready_idx = 0;
+    }
 //    D("LS(%d): ready()\n", s->id);
 }
 
@@ -260,6 +301,18 @@ static void local_socket_close_locked(asocket *s)
     insert_local_socket(s, &local_socket_closing_list);
 }
 
+// For debug purpose
+#define FD_ARRAY_SIZE 64
+clock_t last_read_time = 0;
+int read_data = 0;
+int fd_read_array[FD_ARRAY_SIZE] = {0};
+int fd_read_idx = 0;
+clock_t last_write_time = 0;
+int write_data = 0;
+int fd_write_array[FD_ARRAY_SIZE] = {0};
+int fd_write_idx = 0;
+clock_t max_read_time = 0;
+clock_t max_send_time = 0;
 static void local_socket_event_func(int fd, unsigned ev, void *_s)
 {
     asocket *s = _s;
@@ -270,6 +323,27 @@ static void local_socket_event_func(int fd, unsigned ev, void *_s)
     ** in order to simplify the code.
     */
     if(ev & FDE_WRITE){
+        //check if in the array
+        bool bFound = false;
+        int i = 0;
+        for(i = 0; i < FD_ARRAY_SIZE; ++i){
+            if(fd_write_array[i] == fd){
+                //Do not need to update array
+                bFound = true;
+                break;
+            }
+        }
+
+        if(bFound == false){
+            if(fd_write_idx > FD_ARRAY_SIZE - 1){
+                //Out of range, so we have to print fd directly
+                XLOGD("Too many write adb socket fd=%d, ", fd);
+            }else{
+                fd_write_array[fd_write_idx] = fd;
+                fd_write_idx++;
+            }
+        }
+
         apacket *p;
 
         while((p = s->pkt_first) != 0) {
@@ -288,10 +362,31 @@ static void local_socket_event_func(int fd, unsigned ev, void *_s)
                     if(errno == EINTR) continue;
                 }
                 D(" closing after write because r=%d and errno is %d\n", r, errno);
+                XLOGW(" closing after write because r=%d and errno is %d\n", r, errno);
                 s->close(s);
                 return;
             }
 
+            clock_t this_write_time = clock();
+            double cpu_time_used = ((double) (this_write_time - last_write_time)) / CLOCKS_PER_SEC;
+            if( cpu_time_used > 10.0 )
+            {
+                char output_log[512];
+                char tmp[16];
+                sprintf(output_log, "%s", "adb socket write list ");
+                int i = 0;
+                for(i = 0; i < fd_write_idx; ++ i){
+                    sprintf(tmp, "(%d) ", fd_write_array[i]);
+                    strcat(output_log, tmp);
+                    //XLOGD("adb socket write fd=%d, ", fd_write_array[i]);
+                    fd_write_array[i] = 0;
+                }
+                XLOGD("%s\n", output_log);
+                XLOGD("write_data=%d\n", write_data);
+                last_write_time = this_write_time;
+                write_data = 0;
+                fd_write_idx = 0;
+            }
             if(p->len == 0) {
                 s->pkt_first = p->next;
                 if(s->pkt_first == 0) s->pkt_last = 0;
@@ -304,6 +399,7 @@ static void local_socket_event_func(int fd, unsigned ev, void *_s)
             */
         if (s->closing) {
             D(" closing because 'closing' is set after write\n");
+            XLOGW(" closing because 'closing' is set after write\n");
             s->close(s);
             return;
         }
@@ -316,20 +412,42 @@ static void local_socket_event_func(int fd, unsigned ev, void *_s)
         s->peer->ready(s->peer);
     }
 
-
     if(ev & FDE_READ){
+        //check if in the array
+        bool bFound = false;
+        int i = 0;
+        for(i = 0; i < FD_ARRAY_SIZE; ++i){
+            if(fd_read_array[i] == fd){
+                //Do not need to update array
+                bFound = true;
+                break;
+            }
+        }
+
+        if(bFound == false){
+            if(fd_read_idx > FD_ARRAY_SIZE - 1){
+                //Out of range, so we have to print directly
+                XLOGD("Too many read adb socket fd=%d, ", fd);
+            }else{
+                fd_read_array[fd_read_idx] = fd;
+                fd_read_idx++;
+            }
+        }
+
         apacket *p = get_apacket();
         unsigned char *x = p->data;
         size_t avail = MAX_PAYLOAD;
         int r;
         int is_eof = 0;
 
+        clock_t time1 = clock();
         while(avail > 0) {
             r = adb_read(fd, x, avail);
             D("LS(%d): post adb_read(fd=%d,...) r=%d (errno=%d) avail=%d\n", s->id, s->fd, r, r<0?errno:0, avail);
             if(r > 0) {
                 avail -= r;
                 x += r;
+                read_data += r;
                 continue;
             }
             if(r < 0) {
@@ -341,8 +459,35 @@ static void local_socket_event_func(int fd, unsigned ev, void *_s)
             is_eof = 1;
             break;
         }
+
+        clock_t this_read_time = clock();
+        double cpu_time_used = ((double) (this_read_time - last_read_time)) / CLOCKS_PER_SEC;
+        if( cpu_time_used > 5.0 )
+        {
+            char output_log[512];
+            char tmp[16];
+            sprintf(output_log, "%s", "adb socket read list ");
+            int i = 0;
+            for(i = 0; i < fd_read_idx; ++ i){
+                sprintf(tmp, "(%d) ", fd_read_array[i]);
+                strcat(output_log, tmp);
+                //XLOGD("adb socket read fd=%d, ", fd_read_array[i]);
+                fd_read_array[i] = 0;
+            }
+            XLOGD("%s\n", output_log);
+            XLOGD("read_data=%d\n", read_data);
+            last_read_time = this_read_time;
+            read_data = 0;
+            fd_read_idx = 0;
+        }
+
         D("LS(%d): fd=%d post avail loop. r=%d is_eof=%d forced_eof=%d\n",
           s->id, s->fd, r, is_eof, s->fde.force_eof);
+        clock_t time2 = clock();
+        if ( time2 - time1 > max_read_time ){
+            max_read_time = time2 - time1;
+        }
+
         if((avail == MAX_PAYLOAD) || (s->peer == 0)) {
             put_apacket(p);
         } else {
@@ -350,6 +495,10 @@ static void local_socket_event_func(int fd, unsigned ev, void *_s)
 
             r = s->peer->enqueue(s->peer, p);
             D("LS(%d): fd=%d post peer->enqueue(). r=%d\n", s->id, s->fd, r);
+            clock_t time3 = clock();
+            if( time3 - time2 > max_send_time){
+                max_send_time = time3 - time2;
+            }
 
             if(r < 0) {
                     /* error return means they closed us as a side-effect
@@ -371,9 +520,19 @@ static void local_socket_event_func(int fd, unsigned ev, void *_s)
                 fdevent_del(&s->fde, FDE_READ);
             }
         }
+
+        if( cpu_time_used > 5.0 ) {
+            double read_time = ((double) max_read_time) / CLOCKS_PER_SEC;
+            double send_time = ((double) max_send_time) / CLOCKS_PER_SEC;
+            XLOGD("max_read_time=%f max_send_time=%f \n", read_time, send_time);
+            max_read_time = 0;
+            max_send_time = 0;
+        }
+
         /* Don't allow a forced eof if data is still there */
         if((s->fde.force_eof && !r) || is_eof) {
             D(" closing because is_eof=%d r=%d s->fde.force_eof=%d\n", is_eof, r, s->fde.force_eof);
+            XLOGD(" closing because is_eof=%d r=%d s->fde.force_eof=%d\n", is_eof, r, s->fde.force_eof);
             s->close(s);
         }
     }
@@ -385,7 +544,7 @@ static void local_socket_event_func(int fd, unsigned ev, void *_s)
             */
 //        s->close(s);
         D("LS(%d): FDE_ERROR (fd=%d)\n", s->id, s->fd);
-
+        XLOGD("LS(%d): FDE_ERROR (fd=%d)\n", s->id, s->fd);
         return;
     }
 }
@@ -412,6 +571,8 @@ asocket *create_local_service_socket(const char *name)
     asocket *s;
     int fd;
 
+    XLOGW("create_local_service_socket() name=%s\n", name);
+
 #if !ADB_HOST
     if (!strcmp(name,"jdwp")) {
         return create_jdwp_service_socket();
@@ -421,13 +582,19 @@ asocket *create_local_service_socket(const char *name)
     }
 #endif
     fd = service_to_fd(name);
-    if(fd < 0) return 0;
+    if(fd < 0){
+        XLOGW("create_local_service_socket fail");
+        return 0;
+    }
 
     s = create_local_socket(fd);
     D("LS(%d): bound to '%s' via %d\n", s->id, name, fd);
 
 #if !ADB_HOST
-    if ((!strncmp(name, "root:", 5) && getuid() != 0)
+    char value[PROPERTY_VALUE_MAX];
+    property_get("ro.debuggable", value, "");
+
+    if ((!strncmp(name, "root:", 5) && getuid() != 0 && (strcmp(value, "1") == 0))
         || !strncmp(name, "usb:", 4)
         || !strncmp(name, "tcpip:", 6)) {
         D("LS(%d): enabling exit_on_close\n", s->id);
@@ -669,6 +836,7 @@ static int smart_socket_enqueue(asocket *s, apacket *p)
     } else {
         if((s->pkt_first->len + p->len) > MAX_PAYLOAD) {
             D("SS(%d): overflow\n", s->id);
+            XLOGW("SS(%d): overflow\n", s->id);
             put_apacket(p);
             goto fail;
         }
@@ -687,6 +855,7 @@ static int smart_socket_enqueue(asocket *s, apacket *p)
     len = unhex(p->data, 4);
     if((len < 1) ||  (len > 1024)) {
         D("SS(%d): bad size (%d)\n", s->id, len);
+        XLOGW("SS(%d): bad size (%d)\n", s->id, len);
         goto fail;
     }
 
@@ -821,6 +990,7 @@ fail:
         ** return -1 to signal that state to the local socket
         ** who is enqueueing against us
         */
+    XLOGW("SS(%d): smart_socket_enqueue fail\n");
     s->close(s);
     return -1;
 }
diff --git a/system/core/adb/transport.c b/gb/12055-master/driveronly_mp_rom/system/core/adb/transport.c
index 9fd6cc2..21418fd 100644
--- a/system/core/adb/transport.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/adb/transport.c
@@ -65,6 +65,8 @@ static void  dump_hex( const unsigned char*  ptr, size_t  len )
 void
 kick_transport(atransport*  t)
 {
+    D("kick_transport fd: %d \n", t->fd);
+    XLOGD("kick_transport fd: %d \n", t->fd);
     if (t && !t->kicked)
     {
         int  kicked;
@@ -76,16 +78,21 @@ kick_transport(atransport*  t)
         adb_mutex_unlock(&transport_lock);
 
         if (!kicked)
+        {
+            D("kick_transport kicked fd: %d \n", t->fd);
+            XLOGD("kick_transport kicked fd: %d \n", t->fd);
             t->kick(t);
     }
 }
+}
 
 void
 run_transport_disconnects(atransport*  t)
 {
     adisconnect*  dis = t->disconnects.next;
 
-    D("%s: run_transport_disconnects\n", t->serial);
+    D("%s: run_transport_disconnects fd: %d\n", t->serial, t->fd);
+    XLOGD("%s: run_transport_disconnects fd: %d\n", t->serial, t->fd);
     while (dis != &t->disconnects) {
         adisconnect*  next = dis->next;
         dis->func( dis->opaque, t );
@@ -152,6 +159,7 @@ read_packet(int  fd, const char* name, apacket** ppacket)
         } else {
             D("%s: read_packet (fd=%d), error ret=%d errno=%d: %s\n", name, fd, r, errno, strerror(errno));
             if((r < 0) && (errno == EINTR)) continue;
+            XLOGW("%s: read_packet (fd=%d), error ret=%d errno=%d: %s\n", name, fd, r, errno, strerror(errno));
             return -1;
         }
     }
@@ -189,6 +197,7 @@ write_packet(int  fd, const char* name, apacket** ppacket)
         } else {
             D("%s: write_packet (fd=%d) error ret=%d errno=%d: %s\n", name, fd, r, errno, strerror(errno));
             if((r < 0) && (errno == EINTR)) continue;
+            XLOGW("%s: write_packet (fd=%d) error ret=%d errno=%d: %s\n", name, fd, r, errno, strerror(errno));
             return -1;
         }
     }
@@ -203,6 +212,7 @@ static void transport_socket_events(int fd, unsigned events, void *_t)
         apacket *p = 0;
         if(read_packet(fd, t->serial, &p)){
             D("%s: failed to read packet from transport socket on fd %d\n", t->serial, fd);
+            XLOGV("%s: failed to read packet from transport socket on fd %d\n", t->serial, fd);
         } else {
             handle_packet(p, (atransport *) _t);
         }
@@ -259,6 +269,8 @@ static void *output_thread(void *_t)
 
     D("%s: starting transport output thread on fd %d, SYNC online (%d)\n",
        t->serial, t->fd, t->sync_token + 1);
+    XLOGW("%s: starting transport output thread on fd %d, SYNC online (%d)\n",
+       t->serial, t->fd, t->sync_token + 1);
     p = get_apacket();
     p->msg.command = A_SYNC;
     p->msg.arg0 = 1;
@@ -267,6 +279,7 @@ static void *output_thread(void *_t)
     if(write_packet(t->fd, t->serial, &p)) {
         put_apacket(p);
         D("%s: failed to write SYNC packet\n", t->serial);
+        XLOGW("%s: failed to write SYNC packet\n", t->serial);
         goto oops;
     }
 
@@ -280,16 +293,19 @@ static void *output_thread(void *_t)
             if(write_packet(t->fd, t->serial, &p)){
                 put_apacket(p);
                 D("%s: failed to write apacket to transport\n", t->serial);
+                XLOGW("%s: failed to write apacket to transport\n", t->serial);
                 goto oops;
             }
         } else {
             D("%s: remote read failed for transport\n", t->serial);
+            XLOGW("%s: remote read failed for transport\n", t->serial);
             put_apacket(p);
             break;
         }
     }
 
     D("%s: SYNC offline for transport\n", t->serial);
+    XLOGW("%s: SYNC offline for transport\n", t->serial);
     p = get_apacket();
     p->msg.command = A_SYNC;
     p->msg.arg0 = 0;
@@ -298,10 +314,12 @@ static void *output_thread(void *_t)
     if(write_packet(t->fd, t->serial, &p)) {
         put_apacket(p);
         D("%s: failed to write SYNC apacket to transport", t->serial);
+        XLOGW("%s: failed to write SYNC apacket to transport", t->serial);
     }
 
 oops:
-    D("%s: transport output thread is exiting\n", t->serial);
+    D("%s: transport output thread is exiting fd %d \n", t->serial, t->fd);
+    XLOGW("%s: transport output thread is exiting fd %d \n", t->serial, t->fd);
     kick_transport(t);
     transport_unref(t);
     return 0;
@@ -315,25 +333,33 @@ static void *input_thread(void *_t)
 
     D("%s: starting transport input thread, reading from fd %d\n",
        t->serial, t->fd);
+    XLOGW("%s: starting transport input thread, reading from fd %d\n",
+       t->serial, t->fd);
 
     for(;;){
         if(read_packet(t->fd, t->serial, &p)) {
             D("%s: failed to read apacket from transport on fd %d\n",
                t->serial, t->fd );
+            XLOGW("%s: failed to read apacket from transport on fd %d\n",
+               t->serial, t->fd );
             break;
         }
         if(p->msg.command == A_SYNC){
             if(p->msg.arg0 == 0) {
                 D("%s: transport SYNC offline\n", t->serial);
+                XLOGW("%s: transport SYNC offline\n", t->serial);
                 put_apacket(p);
                 break;
             } else {
                 if(p->msg.arg1 == t->sync_token) {
                     D("%s: transport SYNC online\n", t->serial);
+                    XLOGW("%s: transport SYNC online\n", t->serial);
                     active = 1;
                 } else {
                     D("%s: transport ignoring SYNC %d != %d\n",
                       t->serial, p->msg.arg1, t->sync_token);
+                    XLOGW("%s: transport ignoring SYNC %d != %d\n",
+                        t->serial, p->msg.arg1, t->sync_token);
                 }
             }
         } else {
@@ -342,6 +368,7 @@ static void *input_thread(void *_t)
                 t->write_to_remote(p, t);
             } else {
                 D("%s: transport ignoring packet while offline\n", t->serial);
+                XLOGW("%s: transport ignoring packet while offline\n", t->serial);
             }
         }
 
@@ -353,6 +380,7 @@ static void *input_thread(void *_t)
     close_all_sockets(t);
 
     D("%s: transport input thread is exiting, fd %d\n", t->serial, t->fd);
+    XLOGW("%s: transport input thread is exiting, fd %d\n", t->serial, t->fd);
     kick_transport(t);
     transport_unref(t);
     return 0;
@@ -535,6 +563,8 @@ transport_read_action(int  fd, struct tmsg*  m)
             if((r < 0) && (errno == EINTR)) continue;
             D("transport_read_action: on fd %d, error %d: %s\n",
               fd, errno, strerror(errno));
+            XLOGW("transport_read_action: on fd %d, error %d: %s\n",
+              fd, errno, strerror(errno));
             return -1;
         }
     }
@@ -557,6 +587,8 @@ transport_write_action(int  fd, struct tmsg*  m)
             if((r < 0) && (errno == EINTR)) continue;
             D("transport_write_action: on fd %d, error %d: %s\n",
               fd, errno, strerror(errno));
+            XLOGW("transport_write_action: on fd %d, error %d: %s\n",
+              fd, errno, strerror(errno));
             return -1;
         }
     }
@@ -583,11 +615,15 @@ static void transport_registration_func(int _fd, unsigned ev, void *data)
 
     if(m.action == 0){
         D("transport: %s removing and free'ing %d\n", t->serial, t->transport_socket);
-
+        XLOGD("transport: %s removing and free'ing %d\n", t->serial, t->transport_socket);
             /* IMPORTANT: the remove closes one half of the
             ** socket pair.  The close closes the other half.
             */
         fdevent_remove(&(t->transport_fde));
+
+        D("transport: transport_registration_func adb_close fd: %d \n", t->fd);
+        XLOGD("transport: transport_registration_func adb_close fd: %d \n", t->fd);
+
         adb_close(t->fd);
 
         adb_mutex_lock(&transport_lock);
@@ -625,6 +661,7 @@ static void transport_registration_func(int _fd, unsigned ev, void *data)
         }
 
         D("transport: %s (%d,%d) starting\n", t->serial, s[0], s[1]);
+        XLOGD("transport: %s (%d,%d) starting\n", t->serial, s[0], s[1]);
 
         t->transport_socket = s[0];
         t->fd = s[1];
@@ -684,6 +721,8 @@ static void register_transport(atransport *transport)
     m.transport = transport;
     m.action = 1;
     D("transport: %s registered\n", transport->serial);
+    XLOGD("transport: %s registered\n", transport->serial);
+
     if(transport_write_action(transport_registration_send, &m)) {
         fatal_errno("cannot write transport registration socket\n");
     }
@@ -695,6 +734,8 @@ static void remove_transport(atransport *transport)
     m.transport = transport;
     m.action = 0;
     D("transport: %s removed\n", transport->serial);
+    XLOGD("transport: %s removed\n", transport->serial);
+
     if(transport_write_action(transport_registration_send, &m)) {
         fatal_errno("cannot write transport registration socket\n");
     }
@@ -706,6 +747,7 @@ static void transport_unref_locked(atransport *t)
     t->ref_count--;
     if (t->ref_count == 0) {
         D("transport: %s unref (kicking and closing)\n", t->serial);
+        XLOGD("transport: %s unref (kicking and closing)\n", t->serial);
         if (!t->kicked) {
             t->kicked = 1;
             t->kick(t);
@@ -714,11 +756,15 @@ static void transport_unref_locked(atransport *t)
         remove_transport(t);
     } else {
         D("transport: %s unref (count=%d)\n", t->serial, t->ref_count);
+        XLOGD("transport: %s unref (count=%d)\n", t->serial, t->ref_count);
     }
 }
 
 static void transport_unref(atransport *t)
 {
+    D("transport: %s transport_unref fd:%d (kick)\n", t->serial, t->fd);
+    XLOGD("transport: %s transport_unref fd:%d (kick)\n", t->serial, t->fd);
+
     if (t) {
         adb_mutex_lock(&transport_lock);
         transport_unref_locked(t);
@@ -992,6 +1038,7 @@ void register_socket_transport(int s, const char *serial, int port, int local)
         serial = buff;
     }
     D("transport: %s init'ing for socket %d, on port %d\n", serial, s, port);
+    XLOGD("transport: %s init'ing for socket %d, on port %d\n", serial, s, port);
     if ( init_socket_transport(t, s, port, local) < 0 ) {
         adb_close(s);
         free(t);
@@ -1036,6 +1083,8 @@ void unregister_transport(atransport *t)
 // unregisters all non-emulator TCP transports
 void unregister_all_tcp_transports()
 {
+    D("unregister_all_tcp_transports \n");
+    XLOGD("unregister_all_tcp_transports \n");
     atransport *t, *next;
     adb_mutex_lock(&transport_lock);
     for (t = transport_list.next; t != &transport_list; t = next) {
@@ -1063,6 +1112,9 @@ void register_usb_transport(usb_handle *usb, const char *serial, const char *dev
     atransport *t = calloc(1, sizeof(atransport));
     D("transport: %p init'ing for usb_handle %p (sn='%s')\n", t, usb,
       serial ? serial : "");
+    XLOGD("transport: %p init'ing for usb_handle %p (sn='%s')\n", t, usb,
+      serial ? serial : "");
+
     init_usb_transport(t, usb, (writeable ? CS_OFFLINE : CS_NOPERM));
     if(serial) {
         t->serial = strdup(serial);
@@ -1107,10 +1159,12 @@ int readx(int fd, void *ptr, size_t len)
         } else {
             if (r < 0) {
                 D("readx: fd=%d error %d: %s\n", fd, errno, strerror(errno));
+                XLOGW("readx: fd=%d error %d: %s\n", fd, errno, strerror(errno));
                 if (errno == EINTR)
                     continue;
             } else {
                 D("readx: fd=%d disconnected\n", fd);
+                XLOGW("readx: fd=%d disconnected\n", fd);
             }
             return -1;
         }
@@ -1140,10 +1194,12 @@ int writex(int fd, const void *ptr, size_t len)
         } else {
             if (r < 0) {
                 D("writex: fd=%d error %d: %s\n", fd, errno, strerror(errno));
+                XLOGW("writex: fd=%d error %d: %s\n", fd, errno, strerror(errno));
                 if (errno == EINTR)
                     continue;
             } else {
                 D("writex: fd=%d disconnected\n", fd);
+                XLOGW("writex: fd=%d disconnected\n", fd);
             }
             return -1;
         }
@@ -1155,11 +1211,13 @@ int check_header(apacket *p)
 {
     if(p->msg.magic != (p->msg.command ^ 0xffffffff)) {
         D("check_header(): invalid magic\n");
+        XLOGW("check_header(): invalid magic\n");
         return -1;
     }
 
     if(p->msg.data_length > MAX_PAYLOAD) {
         D("check_header(): %d > MAX_PAYLOAD\n", p->msg.data_length);
+        XLOGW("check_header(): %d > MAX_PAYLOAD\n", p->msg.data_length);
         return -1;
     }
 
diff --git a/system/core/adb/transport_local.c b/gb/12055-master/driveronly_mp_rom/system/core/adb/transport_local.c
index 96a24ba..6613e39 100644
--- a/system/core/adb/transport_local.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/adb/transport_local.c
@@ -56,6 +56,7 @@ static int remote_read(apacket *p, atransport *t)
 {
     if(readx(t->sfd, &p->msg, sizeof(amessage))){
         D("remote local: read terminated (message)\n");
+        XLOGE("remote local: read terminated (message)\n");
         return -1;
     }
 
@@ -67,16 +68,19 @@ static int remote_read(apacket *p, atransport *t)
 #endif
     if(check_header(p)) {
         D("bad header: terminated (data)\n");
+        XLOGE("bad header: terminated (data)\n");
         return -1;
     }
 
     if(readx(t->sfd, p->data, p->msg.data_length)){
         D("remote local: terminated (data)\n");
+        XLOGE("remote local: terminated (data)\n");
         return -1;
     }
 
     if(check_data(p)) {
         D("bad data: terminated (data)\n");
+        XLOGE("bad data: terminated (data)\n");
         return -1;
     }
 
@@ -95,6 +99,7 @@ static int remote_write(apacket *p, atransport *t)
 #endif
     if(writex(t->sfd, &p->msg, sizeof(amessage) + length)) {
         D("remote local: write terminated\n");
+        XLOGE("remote local: write terminated\n");
         return -1;
     }
 
@@ -182,6 +187,7 @@ static void *server_socket_thread(void * arg)
         }
     }
     D("transport: server_socket_thread() exiting\n");
+    XLOGE("transport: server_socket_thread() exiting\n");
     return 0;
 }
 
diff --git a/system/core/adb/transport_usb.c b/gb/12055-master/driveronly_mp_rom/system/core/adb/transport_usb.c
index ee6b637..e955946 100644
--- a/system/core/adb/transport_usb.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/adb/transport_usb.c
@@ -53,6 +53,7 @@ unsigned host_to_le32(unsigned n)
 static int remote_read(apacket *p, atransport *t)
 {
     if(usb_read(t->usb, &p->msg, sizeof(amessage))){
+        XLOGW("remote usb: read terminated (message)\n");
         D("remote usb: read terminated (message)\n");
         return -1;
     }
@@ -60,18 +61,21 @@ static int remote_read(apacket *p, atransport *t)
     fix_endians(p);
 
     if(check_header(p)) {
+        XLOGW("remote usb: check_header failed\n");
         D("remote usb: check_header failed\n");
         return -1;
     }
 
     if(p->msg.data_length) {
         if(usb_read(t->usb, p->data, p->msg.data_length)){
+            XLOGW("remote usb: terminated (data)\n");
             D("remote usb: terminated (data)\n");
             return -1;
         }
     }
 
     if(check_data(p)) {
+        XLOGW("remote usb: check_data failed\n");
         D("remote usb: check_data failed\n");
         return -1;
     }
@@ -86,11 +90,13 @@ static int remote_write(apacket *p, atransport *t)
     fix_endians(p);
 
     if(usb_write(t->usb, &p->msg, sizeof(amessage))) {
+        XLOGW("remote usb: 1 - write terminated\n");
         D("remote usb: 1 - write terminated\n");
         return -1;
     }
     if(p->msg.data_length == 0) return 0;
     if(usb_write(t->usb, &p->data, size)) {
+        XLOGW("remote usb: 2 - write terminated\n");
         D("remote usb: 2 - write terminated\n");
         return -1;
     }
@@ -112,6 +118,7 @@ static void remote_kick(atransport *t)
 void init_usb_transport(atransport *t, usb_handle *h, int state)
 {
     D("transport: usb\n");
+    XLOGI("transport: usb\n");
     t->close = remote_close;
     t->kick = remote_kick;
     t->read_from_remote = remote_read;
diff --git a/system/core/adb/usb_linux_client.c b/gb/12055-master/driveronly_mp_rom/system/core/adb/usb_linux_client.c
index fb1dad0..35d3b7c 100644
--- a/system/core/adb/usb_linux_client.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/adb/usb_linux_client.c
@@ -162,10 +162,11 @@ static void *usb_adb_open_thread(void *x)
         do {
             /* XXX use inotify? */
             fd = unix_open("/dev/android_adb", O_RDWR);
-            if (fd < 0) {
+            /* /dev/andriod can't access on MTK platform */
+            /* if (fd < 0) {
                 // to support older kernels
                 fd = unix_open("/dev/android", O_RDWR);
-            }
+            } */
             if (fd < 0) {
                 adb_sleep_ms(1000);
             }
@@ -192,6 +193,8 @@ static int usb_adb_write(usb_handle *h, const void *data, int len)
     if(n != len) {
         D("ERROR: fd = %d, n = %d, errno = %d (%s)\n",
             h->fd, n, errno, strerror(errno));
+        XLOGE("ERROR: fd = %d, n = %d, errno = %d (%s)\n",
+            h->fd, n, errno, strerror(errno));
         return -1;
     }
     D("[ done fd=%d ]\n", h->fd);
@@ -207,6 +210,8 @@ static int usb_adb_read(usb_handle *h, void *data, int len)
     if(n != len) {
         D("ERROR: fd = %d, n = %d, errno = %d (%s)\n",
             h->fd, n, errno, strerror(errno));
+        XLOGE("ERROR: fd = %d, n = %d, errno = %d (%s)\n",
+            h->fd, n, errno, strerror(errno));
         return -1;
     }
     D("[ done fd=%d ]\n", h->fd);
@@ -217,7 +222,8 @@ static void usb_adb_kick(usb_handle *h)
 {
     D("usb_kick\n");
     adb_mutex_lock(&h->lock);
-    adb_close(h->fd);
+    int nRet = adb_close(h->fd);
+    XLOGW("usb_kick fd = %d, n = %d\n", h->fd, nRet);
     h->fd = -1;
 
     // notify usb_adb_open_thread that we are disconnected
diff --git a/system/core/charger/Android.mk b/gb/12055-master/driveronly_mp_rom/system/core/charger/Android.mk
index 0258604..fe0c91d 100644
--- a/system/core/charger/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/system/core/charger/Android.mk
@@ -12,10 +12,6 @@ ifeq ($(strip $(BOARD_CHARGER_DISABLE_INIT_BLANK)),true)
 LOCAL_CFLAGS := -DCHARGER_DISABLE_INIT_BLANK
 endif
 
-ifeq ($(strip $(BOARD_CHARGER_ENABLE_SUSPEND)),true)
-LOCAL_CFLAGS += -DCHARGER_ENABLE_SUSPEND
-endif
-
 LOCAL_MODULE := charger
 LOCAL_MODULE_TAGS := optional
 LOCAL_FORCE_STATIC_EXECUTABLE := true
@@ -25,9 +21,6 @@ LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
 LOCAL_C_INCLUDES := bootable/recovery
 
 LOCAL_STATIC_LIBRARIES := libminui libpixelflinger_static libpng
-ifeq ($(strip $(BOARD_CHARGER_ENABLE_SUSPEND)),true)
-LOCAL_STATIC_LIBRARIES += libsuspend
-endif
 LOCAL_STATIC_LIBRARIES += libz libstdc++ libcutils libm libc
 
 include $(BUILD_EXECUTABLE)
diff --git a/system/core/charger/charger.c b/gb/12055-master/driveronly_mp_rom/system/core/charger/charger.c
index 353bdf0..c5e4ec2 100644
--- a/system/core/charger/charger.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/charger/charger.c
@@ -41,10 +41,6 @@
 #include <cutils/misc.h>
 #include <cutils/uevent.h>
 
-#ifdef CHARGER_ENABLE_SUSPEND
-#include <suspend/autosuspend.h>
-#endif
-
 #include "minui/minui.h"
 
 #ifndef max
@@ -356,21 +352,6 @@ static void remove_supply(struct charger *charger, struct power_supply *supply)
     free(supply);
 }
 
-#ifdef CHARGER_ENABLE_SUSPEND
-static int request_suspend(bool enable)
-{
-    if (enable)
-        return autosuspend_enable();
-    else
-        return autosuspend_disable();
-}
-#else
-static int request_suspend(bool enable)
-{
-    return 0;
-}
-#endif
-
 static void parse_uevent(const char *msg, struct uevent *uevent)
 {
     uevent->action = "";
@@ -704,8 +685,6 @@ static void update_screen_state(struct charger *charger, int64_t now)
         charger->next_screen_transition = -1;
         gr_fb_blank(true);
         LOGV("[%lld] animation done\n", now);
-        if (charger->num_supplies_online > 0)
-            request_suspend(true);
         return;
     }
 
@@ -845,10 +824,8 @@ static void process_key(struct charger *charger, int code, int64_t now)
             }
         } else {
             /* if the power key got released, force screen state cycle */
-            if (key->pending) {
-                request_suspend(false);
+            if (key->pending)
                 kick_animation(charger->batt_anim);
-            }
         }
     }
 
@@ -866,7 +843,6 @@ static void handle_input_state(struct charger *charger, int64_t now)
 static void handle_power_supply_state(struct charger *charger, int64_t now)
 {
     if (charger->num_supplies_online == 0) {
-        request_suspend(false);
         if (charger->next_pwr_check == -1) {
             charger->next_pwr_check = now + UNPLUGGED_SHUTDOWN_TIME;
             LOGI("[%lld] device unplugged: shutting down in %lld (@ %lld)\n",
diff --git a/system/core/debuggerd/Android.mk b/gb/12055-master/driveronly_mp_rom/system/core/debuggerd/Android.mk
index 15083f4..77d12d2 100644
--- a/system/core/debuggerd/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/system/core/debuggerd/Android.mk
@@ -3,6 +3,7 @@
 ifneq ($(filter arm mips x86,$(TARGET_ARCH)),)
 
 LOCAL_PATH:= $(call my-dir)
+ifneq ($(HAVE_AEE_FEATURE),yes)
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:= \
@@ -32,6 +33,7 @@ LOCAL_CFLAGS += -DHAVE_SELINUX
 endif
 
 include $(BUILD_EXECUTABLE)
+endif # HAVE_AEE_FEATURE
 
 include $(CLEAR_VARS)
 LOCAL_SRC_FILES := crasher.c
diff --git a/system/core/fastboot/Android.mk b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/Android.mk
index 92e9219..ca7fe04 100644
--- a/system/core/fastboot/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/Android.mk
@@ -40,6 +40,13 @@ ifeq ($(HOST_OS),windows)
     LOCAL_C_INCLUDES += /usr/include/w32api/ddk
   endif
   ifneq ($(strip $(USE_MINGW)),)
+    ##### For Auto Enter Fastboot Mode ####
+    LOCAL_SRC_FILES += autoenter/brom.cpp autoenter/comscan.cpp autoenter/IEnterFastboot.cpp autoenter/NewCOMUtil.cpp autoenter/preloadercmd.cpp
+    LOCAL_C_INCLUDES += $(LOCAL_PATH)/autoenter
+    LOCAL_CPPFLAGS += -fexceptions
+    LOCAL_LDLIBS += -lsetupapi
+    ##### For Auto Enter Fastboot Mode END####
+    
     # MinGW under Linux case
     LOCAL_LDLIBS += -lws2_32
     USE_SYSDEPS_WIN32 := 1
@@ -78,3 +85,5 @@ endif
 ifeq ($(HOST_OS),windows)
 $(LOCAL_INSTALLED_MODULE): $(HOST_OUT_EXECUTABLES)/AdbWinApi.dll
 endif
+
+
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/IEnterFastboot.cpp b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/IEnterFastboot.cpp
new file mode 100755
index 0000000..fbb26b4
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/IEnterFastboot.cpp
@@ -0,0 +1,142 @@
+// auto.cpp : Defines the entry point for the console application.
+//
+
+#include "windows.h"
+
+#include "brom.h"
+#include "status.h"
+#include "comscan.h"
+#include "stdio.h"
+
+/* Notify phone enter FASTBOOT mode. 
+*  This function will scan and communicate with preloader COM port that parameters indicated.
+*  Any COM port in parameters was detected, this port will be the communication agent.
+*  return: 0 is OK, -1 is error.
+*  params: 
+*    preloaderSinglePortFilter: preloader single COM port's PID&VID, string like "VID_0E8D&PID_2000"
+*    preloaderCompositePortFilter: preloader composite COM port's PID&VID, string like "VID_1004&PID_6000"
+*    if these two were NULL, then default PID&VID will be used. "VID_0E8D&PID_2000" and "VID_1004&PID_6000"
+*/
+extern "C" int NotifyEnterFastbootMode(char* preloaderSinglePortFilter, char* preloaderCompositePortFilter)
+{
+	char* asBROMPortFilter = "VID_0E8D&PID_0003";
+	char* asPreloaderSinglePortFilter = "VID_0E8D&PID_2000";
+	char* asPreloaderCompositePortFilter = "VID_1004&PID_6000";
+
+	if(preloaderSinglePortFilter != NULL)
+	{
+		asPreloaderSinglePortFilter = preloaderSinglePortFilter;
+	}
+
+	if(preloaderCompositePortFilter != NULL)
+	{
+		asPreloaderCompositePortFilter = preloaderCompositePortFilter;
+	}
+
+	BOOT_ARG_S stArg;
+	int iRet;
+	int BootStop = 0;  
+	BOOTTYPE eType;    
+
+	stArg.m_pStopFlag = &BootStop;    
+	stArg.m_uBaudrate = 115200;
+	stArg.m_uInterval = 10;  //2000 will failed.
+	stArg.m_uRetryTime = 3;
+	stArg.m_uTimeout = 3500;
+	stArg.m_bIsUSBEnable = true;
+	stArg.m_bIsSymbolicEnable = false;
+	stArg.m_bIsCompositeDeviceEnable = false;   
+	stArg.m_euBootMode = FASTBOOT;
+
+
+	//Use USB port, necessary to scan
+	COM_FILTER_LIST_S sCOMFilter;
+	COM_PROPERTY_S sCOMProperty;
+
+	int asDeviceType = 1;//Composite
+	unsigned int uTimout = 35000; // ms
+	char * ppFilter[3];
+
+	ppFilter[0] = asPreloaderSinglePortFilter;
+	ppFilter[1] = asPreloaderCompositePortFilter;
+	ppFilter[2] = asBROMPortFilter;
+	sCOMFilter.m_uCount = 2;      //do no use BRom.
+	sCOMFilter.m_eType = WHITE_LIST;
+	sCOMFilter.m_ppFilterID = ppFilter;
+
+  printf("Wait %d seconds for connection..\n", uTimout/1000);
+	if( asDeviceType == 1 )  //Composite
+	{
+		iRet = GetIncrementCOMPortWithFilter(&sCOMFilter, &sCOMProperty, NULL, false, &BootStop, uTimout);
+	}
+	else                       //Single
+	{
+		iRet = GetIncrementCOMPortWithFilter(&sCOMFilter, &sCOMProperty, NULL, true, &BootStop, uTimout);
+	}
+	if(0 == iRet)
+	{
+		switch(sCOMProperty.m_iFilterIndex)
+		{
+		case 0:
+			eType = PreloaderUSB;
+			break;
+		case 1:
+			eType = PreloaderUSB;
+			break;
+		case 2:
+			eType = BootROMUSB;
+			break;
+		default:
+			printf("Search filter index error!\n");
+			return -1;
+		}
+
+		stArg.m_uPortNumber = sCOMProperty.m_uNumber;
+		strncpy(stArg.m_szPortSymbolic, sCOMProperty.m_rSymbolic, 256);
+	}
+	else
+	{
+		switch(iRet)
+		{		
+		case S_TIMEOUT:
+			printf("Search Preloader/BootROM USB COM port timout!\n");
+			break;
+		case S_INVALID_ARGUMENTS:
+			printf("Invalid arguments for searching COM port!\n");
+			break;
+		default:
+			printf("Search Preloader/BootROM USB COM port fail!\n");
+		}		
+		return -1;
+	}
+
+	if( asDeviceType == 1 )   //Composite
+	{
+		Sleep(500);
+	}
+
+
+	if(BootROMUSB == eType)
+	{
+		printf("Assert, BRom mode not open in code.\n");
+		return -1;
+	}
+	else if(PreloaderUSB == eType)
+	{
+		iRet = Preloader_BootMode(&stArg);
+		if(0 != iRet)
+		{ 
+			printf("Enter Fastboot Mode Fail. Err(%u).\n", iRet);
+			return -1;
+		}
+	}
+	else
+	{
+		printf("Error: PreloaderUSB != eType\n");
+		return -1;
+	}
+
+	printf("Enter Fastboot Mode Success.\n");
+	return 0;
+}
+
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/IEnterFastboot.h b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/IEnterFastboot.h
new file mode 100755
index 0000000..c013724
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/IEnterFastboot.h
@@ -0,0 +1,15 @@
+#ifndef _IENTERFASTBOOT_H_
+#define _IENTERFASTBOOT_H_
+
+/* Notify phone enter FASTBOOT mode. 
+*  This function will scan and communicate with preloader's COM port that parameters indicated.
+*  Any COM port in parameters was detected, this port will be the communication agent.
+*  return: 0 is OK, -1 is error.
+*  params: 
+*    preloaderSinglePortFilter: preloader single COM port's PID&VID, string like "VID_0E8D&PID_2000"
+*    preloaderCompositePortFilter: preloader composite COM port's PID&VID, string like "VID_1004&PID_6000"
+*    if these two were NULL, then default PID&VID will be used: "VID_0E8D&PID_2000" and "VID_1004&PID_6000"
+*/
+int NotifyEnterFastbootMode(char* preloaderSinglePortFilter, char* preloaderCompositePortFilter);
+
+#endif
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/NewCOMUtil.cpp b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/NewCOMUtil.cpp
new file mode 100755
index 0000000..ee4c5f2
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/NewCOMUtil.cpp
@@ -0,0 +1,268 @@
+
+#include "NewCOMUtil.h"
+#include "stdio.h"
+
+NewCOMUtil::NewCOMUtil()
+{
+    m_hCOM = INVALID_HANDLE_VALUE;
+}
+
+NewCOMUtil::~NewCOMUtil()
+{
+}
+
+int NewCOMUtil::SetCommTimeout(unsigned int rd_timeout_msec, unsigned int wr_timeout_msec)
+{
+    COMMTIMEOUTS  timeouts={0};
+    
+    timeouts.ReadIntervalTimeout = 0xFFFFFFFF;
+    timeouts.ReadTotalTimeoutMultiplier = 0;
+    timeouts.WriteTotalTimeoutMultiplier = 0;
+    timeouts.ReadTotalTimeoutConstant = rd_timeout_msec;
+    timeouts.WriteTotalTimeoutConstant = wr_timeout_msec;
+    
+    if(!::SetCommTimeouts(m_hCOM, &timeouts)) 
+    {
+        printf("NewCOMUtil::SetCommTimeout(): Set timeout fail! Handle(%p), COMMTIMEOUTS={ %u, %u, %u, %u, %u }, Err(%u).", m_hCOM,
+        						timeouts.ReadIntervalTimeout,
+        						timeouts.ReadTotalTimeoutMultiplier,
+        						timeouts.ReadTotalTimeoutConstant,
+        						timeouts.WriteTotalTimeoutMultiplier,
+        						timeouts.WriteTotalTimeoutConstant,
+        						GetLastError());
+        return 1;
+    }
+
+    return 0;
+}
+
+int NewCOMUtil::GetCommTimeout(unsigned int &rd_timeout_msec, unsigned int &wr_timeout_msec) 
+{
+    COMMTIMEOUTS  timeouts={0};
+    
+    if(!::GetCommTimeouts(m_hCOM, &timeouts)) 
+    {
+        printf( "NewCOMUtil::GetCommTimeout(): Get timeout fail! Handle(%p), COMMTIMEOUTS={ %u, %u, %u, %u, %u }, Err(%u).", m_hCOM,
+        				timeouts.ReadIntervalTimeout,
+        				timeouts.ReadTotalTimeoutMultiplier,
+        				timeouts.ReadTotalTimeoutConstant,
+        				timeouts.WriteTotalTimeoutMultiplier,
+        				timeouts.WriteTotalTimeoutConstant,
+        				GetLastError());
+        return 1;
+    }
+    
+    rd_timeout_msec = timeouts.ReadTotalTimeoutConstant;
+    wr_timeout_msec = timeouts.WriteTotalTimeoutConstant;
+    
+    return 0;
+}
+
+int NewCOMUtil::ChangeCommState(unsigned int baudrate) 
+{
+    DWORD err;
+    DCB  dcb;
+    COMSTAT  comstat;
+
+    ::ClearCommError(m_hCOM, &err, &comstat);    
+    if( !::GetCommState(m_hCOM, &dcb) ) 
+    {
+       printf("NewCOMUtil::ChangeCommState(): Get state fail! Handle(%p), Err(%u).", m_hCOM, GetLastError());
+       return 1;
+    }
+    
+    // WARNING!!! abort on error flag must be disabled, 
+    // otherwise all the com port apis will fail after using HyperTerminal 
+    dcb.fAbortOnError = FALSE;
+    dcb.BaudRate = baudrate;
+    
+    dcb.DCBlength = sizeof(DCB);
+    dcb.Parity = NOPARITY;
+    dcb.ByteSize = 8;
+    dcb.StopBits = ONESTOPBIT;
+    dcb.fBinary = TRUE;
+    dcb.fParity = FALSE;    
+    dcb.fOutxDsrFlow = FALSE;
+    dcb.fDtrControl = DTR_CONTROL_ENABLE;
+    dcb.fDsrSensitivity = FALSE;
+    dcb.fErrorChar = FALSE;
+    dcb.fNull = FALSE;
+    dcb.ErrorChar = 0;
+    dcb.EofChar = 0;
+    dcb.EvtChar = 0;
+    dcb.fTXContinueOnXoff = FALSE;	
+    dcb.fRtsControl = RTS_CONTROL_ENABLE;  
+    dcb.fOutxCtsFlow = FALSE;
+    dcb.fOutX = FALSE;
+    dcb.fInX = FALSE;
+    dcb.XonChar = 0;
+    dcb.XoffChar = 0;
+    
+    if( !::SetCommState(m_hCOM, &dcb) ) 
+    {
+        printf("NewCOMUtil::ChangeCommState(): Set state fail! Handle(%p), Err(%u).", m_hCOM, GetLastError());
+        return 2;
+    }
+    
+    if( !::PurgeComm(m_hCOM, PURGE_TXABORT|PURGE_TXCLEAR|PURGE_RXABORT|PURGE_RXCLEAR) ) 
+    {
+        printf("NewCOMUtil::ChangeCommState(): Purge fail! Handle(%p), Err(%u).", m_hCOM, GetLastError());
+        return 3;
+    }
+    
+    return 0;
+}
+
+int NewCOMUtil::DumpState()
+{
+    COMMPROP prop;
+    DCB dcb;
+
+    if (!::GetCommProperties(m_hCOM, &prop)) 
+    {    
+        printf("NewCOMUtil::%s: Get properties fail! Handle(%p), Err(%u) !", __FUNCTION__, m_hCOM, GetLastError());
+        return 1;
+    } 
+    else if (!::GetCommState(m_hCOM, &dcb)) 
+    {
+        printf("NewCOMUtil::%s: Get state fail! Handle(%p), Err(%u) !", __FUNCTION__, m_hCOM, GetLastError());
+        return 2;
+    }
+
+   printf("NewCOMUtil::%s(%p): dwMaxTxQueue(%d), dwMaxRxQueue(%d), dwMaxBaud(0x%x), dwProvSubType(0x%x), dwProvCapabilities(0x%x) ", 
+           __FUNCTION__, m_hCOM, prop.dwMaxTxQueue, prop.dwMaxRxQueue, prop.dwMaxBaud, prop.dwProvSubType, prop.dwProvCapabilities);
+    printf( "NewCOMUtil::%s(%p): dwSettableParams(0x%x), dwSettableBaud(0x%x), wSettableData(0x%x), wSettableStopParity(0x%x), dwCurrentTxQueue(%d), dwCurrentRxQueue(%d)", 
+           __FUNCTION__, m_hCOM, prop.dwSettableParams, prop.dwSettableBaud, prop.wSettableData, prop.wSettableStopParity, prop.dwCurrentTxQueue, prop.dwCurrentRxQueue);
+    printf("NewCOMUtil::%s(%p): baud(%d), XonLim(%d), XoffLim(%d), ByteSize(%d), Parity(%d), StopBits(%d), XonChar(%d), XoffChar(%d), ErrorChar(%d), EofChar(%d), EvtChar(%d)",
+           __FUNCTION__, m_hCOM, dcb.BaudRate, dcb.XonLim, dcb.XoffLim, dcb.ByteSize, dcb.Parity, dcb.StopBits, dcb.XonChar, dcb.XoffChar, dcb.ErrorChar, dcb.EofChar, dcb.EvtChar);    
+    printf("NewCOMUtil::%s(%p): fBinary(%d), fParity(%d), fOutxCtsFlow(%d), fOutxDsrFlow(%d), fDtrControl(%d), fDsrSensitivity(%d)",
+           __FUNCTION__, m_hCOM, dcb.fBinary, dcb.fParity, dcb.fOutxCtsFlow, dcb.fOutxDsrFlow, dcb.fDtrControl, dcb.fDsrSensitivity);
+    printf("NewCOMUtil::%s(%p): fTXContinueOnXoff(%d), fOutX(%d), fInX(%d), fErrorChar(%d), fNull(%d), fRtsControl(%d), fAbortOnError(%d)",
+           __FUNCTION__, m_hCOM, dcb.fTXContinueOnXoff, dcb.fOutX, dcb.fInX, dcb.fErrorChar, dcb.fNull, dcb.fRtsControl, dcb.fAbortOnError);    
+
+    return 0;        
+}
+
+int NewCOMUtil::WriteComm(const void * pBuf,  const DWORD dwPredictLen, DWORD *pWriteLen)
+{
+    if(!WriteFile(m_hCOM, pBuf, dwPredictLen, pWriteLen, NULL)) 
+    {
+        printf("NewCOMUtil::WriteComm(): Write fail! Handle(%p), Err(%u).", m_hCOM, GetLastError());
+        return 1;
+    }
+
+    return 0;
+}
+
+int NewCOMUtil::ReadComm(void * pBuf, const DWORD dwPredictLen, DWORD *pReadLen)
+{
+    if(!ReadFile(m_hCOM, pBuf, dwPredictLen, pReadLen, NULL)) 
+    {
+        printf( "NewCOMUtil::ReadComm(): Read fail! Handle(%p), Err(%u).", m_hCOM, GetLastError());
+        return 1;
+    }
+    
+    return 0;
+}
+
+int NewCOMUtil::FlushComm()
+{
+    if(!FlushFileBuffers(m_hCOM)) 
+    {
+        printf( "NewCOMUtil::FlushComm(): Flush fail! Handle(%p), Err(%u).", m_hCOM, GetLastError());
+        return 1;
+    }
+
+    return 0;
+}
+
+int NewCOMUtil::GetCommBaudrate(DWORD *pBaudrate)
+{
+    DCB  dcb;
+    if(!::GetCommState(m_hCOM, &dcb)) 
+    {
+    	printf( "NewCOMUtil::GetCommBaudrate(): Get baudrate fail! Handle(%p), Err(%u).", m_hCOM, GetLastError());
+    	return 1;
+    }
+	
+    if (NULL != pBaudrate)
+        *pBaudrate = dcb.BaudRate;
+        
+    return 0;
+}
+
+int NewCOMUtil::SetCommBaudrate(const DWORD dwBaudrate)
+{
+    DCB  dcb;
+    
+    if( !::GetCommState(m_hCOM, &dcb) ) 
+    {
+        printf("NewCOMUtil::SetCommBaudrate(): Get baudrate fail! Handle(%p), Err(%u).", m_hCOM, GetLastError());
+        return 1;
+    }
+    
+    dcb.BaudRate = dwBaudrate;
+    if( !::SetCommState(m_hCOM, &dcb) ) 
+    {
+        printf("NewCOMUtil::SetCommBaudrate(): Set baudrate fail! Handle(%p), Err(%u).", m_hCOM, GetLastError());
+        return 2;
+    }
+    
+   // printf( "NewCOMUtil::SetCommBaudrate(): Set baudrate to %u", dwBaudrate);
+    return 0;
+}
+
+int NewCOMUtil::PurgeComm(DWORD *p_ret) 
+{
+    if(!::PurgeComm(m_hCOM, PURGE_TXABORT|PURGE_TXCLEAR|PURGE_RXABORT|PURGE_RXCLEAR)) 
+    {
+        printf("NewCOMUtil::PurgeComm(): Purge fail!, Handle(%p), Err(%u).",  m_hCOM, GetLastError());
+        return 1;
+    }
+    
+    return 0;
+}
+
+int NewCOMUtil::SetupCommBuffer(const DWORD dwInput, const DWORD dwOutput) 
+{
+    DWORD err;
+    //DCB  dcb;
+    COMSTAT  comstat;
+
+    ::ClearCommError(m_hCOM, &err, &comstat);    
+    if( !::SetupComm(m_hCOM, dwInput, dwOutput) ) 
+    {
+        printf("NewCOMUtil::SetupCommBuffer(): Setup buffer fail! Handle(%p), Err(%u).", m_hCOM, GetLastError());
+        return 1;
+    }
+
+    return 0;
+}
+
+int NewCOMUtil::Open(const char * pPortName) 
+{
+    m_hCOM = ::CreateFile(pPortName, 
+                                              GENERIC_READ | GENERIC_WRITE, 
+                                              0, 0, OPEN_EXISTING, 
+                                              FILE_ATTRIBUTE_NORMAL, 0);
+    if( INVALID_HANDLE_VALUE == m_hCOM ) 
+    {
+        printf("NewCOMUtil::Open(): Open COM port  fail! Err(%u), Port name(%s).", GetLastError(), pPortName);
+        return 1;    
+    }
+    
+    return 0;
+}
+
+int NewCOMUtil::Close()
+{
+    if(!::CloseHandle(m_hCOM))
+    {
+        printf( "NewCOMUtil::Close(): Close COM port  fail! Err(%u).", GetLastError());
+        return 1;        
+    }
+
+    return 0;
+}
+
+
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/NewCOMUtil.h b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/NewCOMUtil.h
new file mode 100755
index 0000000..0064f4f
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/NewCOMUtil.h
@@ -0,0 +1,35 @@
+#ifndef _NEW_COMUTIL_H_
+#define _NEW_COMUTIL_H_
+
+#include "windows.h"
+
+class NewCOMUtil
+{
+public:
+
+    NewCOMUtil();
+    ~NewCOMUtil();
+
+    int SetCommTimeout(unsigned int rd_timeout_msec, unsigned int wr_timeout_msec);
+    int GetCommTimeout(unsigned int &rd_timeout_msec, unsigned int &wr_timeout_msec);
+    int ChangeCommState(unsigned int baudrate);
+    int DumpCommState();
+    int WriteComm(const void * pBuf,  const DWORD dwPredictLen, DWORD *pWriteLen);
+    int ReadComm(void * pBuf, const DWORD dwPredictLen, DWORD *pReadLen);
+    int FlushComm();
+    int GetCommBaudrate(DWORD *pBaudrate);
+    int SetCommBaudrate(const DWORD dwBaudrate);
+    int PurgeComm(DWORD *p_ret);
+    int SetupCommBuffer(const DWORD dwInput, const DWORD dwOutput);
+
+    int DumpState();
+    
+    int Open(const char * pPortName);
+    int Close();
+
+public:
+    HANDLE m_hCOM;
+    
+};
+
+#endif
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/brom.cpp b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/brom.cpp
new file mode 100755
index 0000000..c1beb53
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/brom.cpp
@@ -0,0 +1,43 @@
+
+#include "brom.h"
+#include "status.h"
+#include "stdio.h"
+#include "preloadercmd.h"
+
+void DumpBootArg(BOOT_ARG_S * pArg)
+{
+    printf("DumpBootArg(): <<<<<<<<<<<<<<<<Boot arguments>>>>>>>>>>>>>>>>\n");
+    printf("DumpBootArg(): Preloader timeout(%u)\n", pArg->m_uTimeout);
+    printf("DumpBootArg(): Preloader retry time(%u)\n", pArg->m_uRetryTime);
+    printf("DumpBootArg(): Preloader retry interval(%u)\n", pArg->m_uInterval);
+    printf("DumpBootArg(): UART port baudrate(%u)\n", pArg->m_uBaudrate);
+    printf("DumpBootArg(): Stop flag addr(0x%p)\n", pArg->m_pStopFlag);
+    
+    printf("DumpBootArg(): USB enable(%u)\n", pArg->m_bIsUSBEnable);
+    printf("DumpBootArg(): Symbolic name enable(%u)\n", pArg->m_bIsSymbolicEnable);
+    printf("DumpBootArg(): Composite device enable(%u)\n", pArg->m_bIsCompositeDeviceEnable);
+    printf("DumpBootArg(): Boot mode type(%u)\n", pArg->m_euBootMode);
+    printf("DumpBootArg(): Port number(COM%u)\n", pArg->m_uPortNumber);
+    printf("DumpBootArg(): Symbolic name(%s)\n", pArg->m_szPortSymbolic);  
+ 
+}
+
+int __stdcall Preloader_BootMode(BOOT_ARG_S * pArg)
+{
+    //printf("\n================== DLL Calling ====================\n");
+    
+    int iRet = S_DONE;    
+    
+    //Check parameters
+    if(NULL == pArg)
+    {
+			printf( "Preloader_BootMode(): invalid arguments!\n");
+			return S_INVALID_ARGUMENTS;
+    }
+    //printf("Preloader_BootMode(): Boot mode entry procedure start...\n");
+   // DumpBootArg(pArg);
+
+
+    PreloaderCmd cCmd;
+    return cCmd.SelectBootMode(pArg);   
+}
\ No newline at end of file
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/brom.h b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/brom.h
new file mode 100755
index 0000000..73ccd20
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/brom.h
@@ -0,0 +1,59 @@
+#ifndef _BROM_H_
+#define _BROM_H_
+
+typedef enum 
+{
+    NORMAL_BOOT         = 0,    
+    FASTBOOT       = 99,
+    UNKNOWN_BOOT
+    
+} BOOT_MODE;
+
+typedef struct 
+{    
+    //New parameters
+    unsigned int m_uTimeout;
+    unsigned int m_uRetryTime;
+    unsigned int m_uInterval;
+    unsigned int m_uBaudrate;
+    int * m_pStopFlag;
+    
+    bool m_bIsUSBEnable;
+    bool m_bIsSymbolicEnable;
+    bool m_bIsCompositeDeviceEnable;
+    BOOT_MODE m_euBootMode;
+    unsigned int m_uPortNumber;
+    char m_szPortSymbolic[256];
+    
+} BOOT_ARG_S;
+
+typedef enum {
+    WHITE_LIST = 0,
+    BLACK_LIST,
+} FILTER_TYPE_E;
+
+typedef struct 
+{
+    unsigned int m_uCount;
+    FILTER_TYPE_E m_eType;
+    char ** m_ppFilterID;
+} COM_FILTER_LIST_S;
+
+typedef struct
+{
+    int m_iFilterIndex;
+    unsigned int m_uNumber;
+    char m_rFriendly[512];
+    char m_rInstanceID[512];
+    char m_rSymbolic[512];
+    
+} COM_PROPERTY_S;
+
+typedef enum
+{
+	PreloaderUSB = 0,
+	BootROMUSB
+}BOOTTYPE;
+
+int __stdcall Preloader_BootMode(BOOT_ARG_S * pArg);
+#endif
\ No newline at end of file
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/comscan.cpp b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/comscan.cpp
new file mode 100755
index 0000000..8b09b56
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/comscan.cpp
@@ -0,0 +1,367 @@
+#include "windows.h"
+#include <initguid.h>
+#include <setupapi.h>
+#include <objbase.h>
+#include <vector>
+
+#include "brom.h"
+#include "status.h"
+using namespace std;
+
+//System lib
+#pragma   comment(lib,   "Setupapi.lib")  //for   SetupDiGetClassDevs
+
+//DEFINE_GUID is recognized by compiler, objbase.h/initguid.h must be included!!!
+
+/*  
+*  GUID of device interface class
+*  Copy from usbiodef.h in WinDDK
+*/
+DEFINE_GUID(GUID_DEVINTERFACE_USB_DEVICE, 0xA5DCBF10L, 0x6530, 0x11D2, 0x90, 0x1F, 0x00, 0xC0, 0x4F, 0xB9, 0x51, 0xED);
+
+/*  
+*  GUID of device setup class
+*  Copy from devguid.h in WinDDK
+*/
+DEFINE_GUID( GUID_DEVCLASS_PORTS,  0x4d36e978L, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );
+//DEFINE_GUID( GUID_DEVCLASS_USB,  0x36fc9e60L, 0xc465, 0x11cf, 0x80, 0x56, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 );
+
+
+
+
+static HANDLE BeginEnumerateDevice(const GUID * pGuid, bool bDeviceInterface, bool bPresentOnly)
+{
+	HDEVINFO DeviceInfoSet;
+	DWORD dwFlags = 0;
+
+
+	dwFlags = (bDeviceInterface) ? (dwFlags | DIGCF_DEVICEINTERFACE) : (dwFlags);
+	dwFlags = (bPresentOnly) ? (dwFlags | DIGCF_PRESENT) : (dwFlags);
+
+	DeviceInfoSet = SetupDiGetClassDevs(
+		pGuid, 
+		0, 0,  
+		dwFlags);
+	return DeviceInfoSet;
+}
+
+
+static void EndEnumerateDevice(HANDLE DeviceInfoSet)
+{
+	SetupDiDestroyDeviceInfoList(DeviceInfoSet);
+}
+
+static void GetNumFromFriendly(char * pFriendly, unsigned int & iNum)
+{
+	char * pIndex = NULL;
+
+	pIndex = strstr(pFriendly, "(COM");
+	if(NULL != pIndex)
+	{
+		sscanf(pIndex, "(COM%u)", &iNum);
+	}
+	else
+	{
+		iNum = -1;
+	}
+}
+
+static int EnumerateDevice(HANDLE hDevInfoSet, const GUID * pGuid, bool bDeviceInterface, int iIndex, COM_PROPERTY_S & stProp)
+{
+	SP_DEVINFO_DATA devInfoData = {0};
+
+	//Enum device interfaces
+	devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
+	if(!SetupDiEnumDeviceInfo(hDevInfoSet, iIndex, &devInfoData))
+	{
+		if (ERROR_NO_MORE_ITEMS != GetLastError())
+		{
+			printf("ERROR_NO_MORE_ITEMS != GetLastError()");
+		}
+		return -1;
+	}
+
+	//Get instance ID of device
+	if(!SetupDiGetDeviceInstanceId(
+		hDevInfoSet,
+		&devInfoData,
+		(PTSTR)stProp.m_rInstanceID,
+		sizeof(stProp.m_rInstanceID) - 1,
+		NULL))
+	{
+
+		sprintf(stProp.m_rInstanceID, "Unknown");
+	}
+
+	// Get friendly name of device
+	if(!SetupDiGetDeviceRegistryProperty(
+		hDevInfoSet,
+		&devInfoData,
+		SPDRP_FRIENDLYNAME,
+		NULL,
+		(PBYTE)stProp.m_rFriendly,
+		sizeof(stProp.m_rFriendly) - 1,
+		NULL))
+	{       
+		sprintf(stProp.m_rFriendly, "Unknown");
+		stProp.m_uNumber = 0;
+	}
+	else
+	{
+		GetNumFromFriendly(stProp.m_rFriendly, stProp.m_uNumber);
+	}
+
+
+
+	//Get device interface information
+	if(bDeviceInterface)
+	{
+		DWORD i = 0;
+		SP_DEVICE_INTERFACE_DATA devInterfaceData;
+		devInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
+		SP_DEVICE_INTERFACE_DETAIL_DATA * pDetData = NULL;
+		DWORD ReqLen = 0;
+
+		while(1)
+		{
+			if(SetupDiEnumDeviceInterfaces(hDevInfoSet,  &devInfoData, pGuid, i++, &devInterfaceData))
+			{
+				// Get size of symbolic link name 		
+				SetupDiGetDeviceInterfaceDetail(hDevInfoSet, &devInterfaceData, NULL, 0, &ReqLen, NULL);
+				char* pData = new char[ReqLen];
+				pDetData = (PSP_INTERFACE_DEVICE_DETAIL_DATA)(pData);
+				pDetData->cbSize = sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);
+
+				// Get symbolic link name
+				if(!SetupDiGetDeviceInterfaceDetail(hDevInfoSet, &devInterfaceData, pDetData, ReqLen, NULL, &devInfoData)) 
+				{                    
+					sprintf(stProp.m_rSymbolic,"Unknown");
+					delete [] pData;
+				}
+				else
+				{
+					strncpy(stProp.m_rSymbolic, pDetData->DevicePath, (strlen(pDetData->DevicePath)+1));
+
+					delete [] pData;
+					break;
+				}
+			}
+			else
+			{
+				sprintf(stProp.m_rSymbolic,"Unknown");            
+
+				break;
+			}
+		}
+		pDetData = NULL;
+	}
+	else
+	{
+		sprintf(stProp.m_rSymbolic,"Unsupported");
+	}
+
+	return 0;
+}
+
+static void GetPresentDeviceInfo(const GUID * pGuid, bool bDeviceInterface, vector<COM_PROPERTY_S> & vtCOM)
+{
+	HANDLE hDevInfoSet;
+	COM_PROPERTY_S stProp;
+	int iIndex = 0;
+
+
+	hDevInfoSet = BeginEnumerateDevice(pGuid, bDeviceInterface, true);
+
+	while(1)
+	{
+		memset(stProp.m_rFriendly, 0, 512);
+		memset(stProp.m_rInstanceID, 0, 512);
+		memset(stProp.m_rSymbolic, 0, 512);
+
+		int iRet = EnumerateDevice(hDevInfoSet, pGuid, bDeviceInterface, iIndex++, stProp);
+		if(0 != iRet)
+		{
+			break;
+		}
+		else
+		{
+			vtCOM.push_back(stProp);
+		}
+	}
+
+	EndEnumerateDevice(hDevInfoSet);
+}
+static int DumpParameters(COM_FILTER_LIST_S * pCOMFilter, const GUID * pGuid, bool bDeviceInterface, int * pStopFlag, double dTimeout)
+{
+	//printf( "DumpParameters(): ===============\n");
+	//printf( "DumpParameters(): COM filter number(%u)\n", pCOMFilter->m_uCount);
+	//printf( "DumpParameters(): COM filter type(%s)\n", (pCOMFilter->m_eType) ? ("BLACK") : ("WHITE"));
+	if((0 != pCOMFilter->m_uCount) && (NULL == pCOMFilter->m_ppFilterID))
+	{
+		printf(  "DumpParameters(): Filter list is null!\n");
+		return -1;
+	}
+
+	for(unsigned int i = 0; i < pCOMFilter->m_uCount; i++)
+	{
+		if(NULL == pCOMFilter->m_ppFilterID[i])
+		{
+			printf( "DumpParameters(): Filter %u() is null!\n", i+1);
+			return -1;
+		}
+		else
+		{
+			//printf( "DumpParameters(): Filter %u(%s)\n", i+1, pCOMFilter->m_ppFilterID[i]);
+		}
+	}
+
+
+	char buf[512];
+	char tmp[64];
+	memset(buf, 0, 256);
+
+	//GUID structure defined in Guiddef.h
+	sprintf(buf, "0x%08lX-0x%04X-0x%04X", pGuid->Data1, pGuid->Data2, pGuid->Data3);
+	for(int i = 0; i < 8; i++)
+	{
+		sprintf(tmp, "-0x%02X", pGuid->Data4[i]);
+		strcat(buf, tmp);
+	}
+
+	//printf( "DumpParameters(): GUID(%s)\n", buf);
+	//printf( "DumpParameters(): Interface(%d)\n", bDeviceInterface);
+	//printf( "DumpParameters(): StopFlag(0x%p)\n", pStopFlag);
+//	printf( "DumpParameters(): Timeout(%lf)\n", dTimeout);
+	//printf( "DumpParameters(): ===============\n");
+	return 0;
+}
+
+static void FindVectorDiff(vector<COM_PROPERTY_S> & vtFirst, vector<COM_PROPERTY_S> & vtSecond, vector<COM_PROPERTY_S> & vtDiff)
+{
+	vector<COM_PROPERTY_S>::iterator iterFirst;
+	vector<COM_PROPERTY_S>::iterator iterSecond;
+
+	for(iterSecond = vtSecond.begin(); iterSecond != vtSecond.end(); iterSecond++)
+	{
+		for(iterFirst = vtFirst.begin(); iterFirst != vtFirst.end(); iterFirst++)
+		{
+			if(0 == strcmp((*iterFirst).m_rInstanceID, (*iterSecond).m_rInstanceID))
+			{
+				break;
+			}
+		}
+
+		if(iterFirst == vtFirst.end())
+		{
+			vtDiff.push_back(*iterSecond);
+		}
+	}
+
+	//Update second to first
+	vtFirst.clear();
+	for(iterSecond = vtSecond.begin(); iterSecond != vtSecond.end(); iterSecond++)
+	{
+		vtFirst.push_back(*iterSecond);
+	}
+}
+static bool IsValidCOMPort(COM_FILTER_LIST_S * pCOMFilter, char * rInstanceID, int & iIndex)
+{
+	iIndex = -1;
+	//printf("IsValidCOMPort(): Instance ID(%s)\n", rInstanceID);
+
+	if(0 == pCOMFilter->m_uCount)
+	{
+		printf( "IsValidCOMPort(): COM port filter is empty, index(-1)\n");
+		return true;
+	}
+	else
+	{
+		//printf( "IsValidCOMPort(): COM port filter is not empty.\n");
+		strupr(rInstanceID);
+
+		for(unsigned int i = 0; i < pCOMFilter->m_uCount; i++)
+		{
+			strupr(pCOMFilter->m_ppFilterID[i]);
+			if(NULL != strstr(rInstanceID, pCOMFilter->m_ppFilterID[i]))
+			{
+				//printf("IsValidCOMPort(): Match filter(%s), index(%d)\n", pCOMFilter->m_ppFilterID[i], i);
+				iIndex = i;
+				return ((pCOMFilter->m_eType) ? (false) : (true));
+			}
+		}
+
+		return ((pCOMFilter->m_eType) ? (true) : (false));    //IF all filters dismatch, return opposite result
+	}
+}
+
+int __stdcall GetIncrementCOMPortWithFilter(COM_FILTER_LIST_S * pCOMFilter, COM_PROPERTY_S * pCOMPorperty, const void * pGuid, bool bDeviceInterface, int * pStopFlag, unsigned int dTimeout)
+{
+	vector<COM_PROPERTY_S> vtFirst;
+	vector<COM_PROPERTY_S> vtSecond;
+	vector<COM_PROPERTY_S> vtDiff;
+	const GUID * pGuidTmp = NULL;
+
+	if(NULL != pGuid)
+	{
+		pGuidTmp = (const GUID *)pGuid;
+	}
+	else
+	{
+		pGuidTmp = (bDeviceInterface) ? (&GUID_DEVINTERFACE_USB_DEVICE) : (&GUID_DEVCLASS_PORTS);
+	}
+
+	if((NULL == pCOMFilter) ||(NULL == pCOMPorperty) ||DumpParameters(pCOMFilter, pGuidTmp, bDeviceInterface, pStopFlag, dTimeout))
+	{        
+		return S_INVALID_ARGUMENTS;
+	}
+
+
+	vtDiff.clear();
+	vtFirst.clear();
+	GetPresentDeviceInfo(pGuidTmp, bDeviceInterface, vtFirst);
+
+	//timer cTotal;
+	unsigned int clock = GetTickCount();
+	unsigned int dSpan = 0;
+	while(true)
+	{            
+		vtDiff.clear();
+		vtSecond.clear();
+		//timer cOnce;
+		GetPresentDeviceInfo(pGuidTmp, bDeviceInterface, vtSecond);            
+
+		FindVectorDiff(vtFirst, vtSecond, vtDiff);
+		if(0 != vtDiff.size())
+		{
+			for(unsigned int i = 0; i < vtDiff.size(); i++)
+			{
+				if(IsValidCOMPort(pCOMFilter, vtDiff[i].m_rInstanceID, vtDiff[i].m_iFilterIndex))
+				{
+
+
+					pCOMPorperty->m_iFilterIndex = vtDiff[i].m_iFilterIndex;
+					pCOMPorperty->m_uNumber = vtDiff[i].m_uNumber;
+					memcpy(pCOMPorperty->m_rInstanceID, vtDiff[i].m_rInstanceID, 512);
+					memcpy(pCOMPorperty->m_rFriendly, vtDiff[i].m_rFriendly, 512);
+					memcpy(pCOMPorperty->m_rSymbolic, vtDiff[i].m_rSymbolic, 512);
+
+
+					return S_DONE;
+				}
+			}
+		}
+
+		Sleep(50);
+		dSpan = GetTickCount() - clock;
+		if((0 != dTimeout) && (dSpan > dTimeout))
+		{
+
+			return S_TIMEOUT;
+		}
+
+	}
+
+
+	return S_UNDEFINED_ERROR;
+}
+
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/comscan.h b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/comscan.h
new file mode 100755
index 0000000..3d4a12b
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/comscan.h
@@ -0,0 +1,5 @@
+#ifndef _COMSCAN_H_
+#define _COMSCAN_H_
+
+int __stdcall GetIncrementCOMPortWithFilter(COM_FILTER_LIST_S * pCOMFilter, COM_PROPERTY_S * pCOMPorperty, const void * pGuid, bool bDeviceInterface, int * pStopFlag, unsigned int dTimeout);
+#endif
\ No newline at end of file
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/preloadercmd.cpp b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/preloadercmd.cpp
new file mode 100755
index 0000000..aec4917
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/preloadercmd.cpp
@@ -0,0 +1,308 @@
+
+#include "preloadercmd.h"
+#include "brom.h"
+#include "status.h"
+#include "stdio.h"
+
+//Flow config
+const unsigned int kDefTimeout = 20000;
+const unsigned int kDefRetryCount = 1000;
+const unsigned int kDefInterval = 10;
+
+//COM port config
+const unsigned int kInputBufferSize = 0x10000;
+const unsigned int kOutputBufferSize = 0x2000;
+const unsigned int kReadTimeout = 0;
+const unsigned int kWriteTimeout = 1000;
+
+//FBT mode
+const char kStrReady[] = "READY";
+const char kStrFBTReq[] = "FASTBOOT";
+const char kStrFBTSuccess[] = "TOOBTSAF";
+
+
+
+PreloaderCmd::PreloaderCmd()
+{
+	m_uTimeout = kDefTimeout;
+	m_uRetryTime = kDefRetryCount;
+	m_uInterval = kDefInterval;
+	m_pStopFlag = NULL;
+}
+
+
+PreloaderCmd::~PreloaderCmd()
+{
+}
+
+
+int PreloaderCmd::SelectBootMode(BOOT_ARG_S * pArg)
+{
+	switch(pArg->m_euBootMode)
+	{
+	case FASTBOOT:
+		return CMD_BootAsFastboot(pArg);        
+
+	default:
+		return S_PL_MODE_UNSUPPORTED;
+	}
+}
+
+
+void PreloaderCmd::SetParameters(BOOT_ARG_S * pArg)
+{
+	m_uTimeout = pArg->m_uTimeout;
+	m_uRetryTime = pArg->m_uRetryTime;
+	m_uInterval = pArg->m_uInterval;
+	m_pStopFlag = pArg->m_pStopFlag;
+	//printf( "Set parameters completely.\n");
+}
+
+
+int PreloaderCmd::SetPort(BOOT_ARG_S * pArg)
+{
+	char szCOM[32] = {0};
+
+	//Judge if Symbollic name is enabled
+	//printf( "Open COM port...\n");
+	if(pArg->m_bIsSymbolicEnable)
+	{
+		//Open COM port by symbolic name
+		if( m_cPort.Open(pArg->m_szPortSymbolic) ) 
+		{
+
+			printf( "Open COM port fail!, Str(%s), Err(%u).\n", pArg->m_szPortSymbolic, GetLastError());
+
+			return S_COM_PORT_OPEN_FAIL;
+		}
+	}
+	else
+	{            
+		//Open COM port by port number
+		sprintf(szCOM,"\\\\.\\COM%d", pArg->m_uPortNumber);
+		if( m_cPort.Open(szCOM) ) 
+		{
+
+			printf("Open COM port fail!, Str(%s), Err(%u).\n", szCOM, GetLastError());
+
+			return S_COM_PORT_OPEN_FAIL;
+		}
+	}
+
+	//Configure port
+	int iRet = 0;
+	//printf("Configure COM port...\n");
+	iRet = m_cPort.SetupCommBuffer(kInputBufferSize, kOutputBufferSize);
+	iRet = m_cPort.ChangeCommState(pArg->m_uBaudrate);
+	iRet = m_cPort.SetCommTimeout(kReadTimeout, kWriteTimeout);
+
+	return iRet;
+}
+
+
+unsigned int PreloaderCmd::ReadPattern(PATTERN_INFO_S * pPattern, const unsigned int kPatternNum)
+{
+	DWORD  dwReadLen;
+	char szRevBuf[MAX_REVBUF_SIZE];
+	char szFlowPool[MAX_PATTERN_LEN];
+	unsigned int uPoolSize;
+
+	//Check parameters
+	if( (NULL == pPattern) ||(1 > kPatternNum))
+	{
+		printf("Incorrect parameters!(NULL pointer or wrong pattern number)\n");
+		return S_INVALID_ARGUMENTS;
+	}
+
+	uPoolSize = MAX_PATTERN_LEN;
+
+	memset(szRevBuf, 0, MAX_REVBUF_SIZE);
+	memset(szFlowPool, 0, MAX_PATTERN_LEN);
+
+
+	try
+	{    
+		for(unsigned int i = 0; i < m_uRetryTime; i++)
+		{
+			//if(BOOT_STOP == *m_pStopFlag)
+			//{
+			//    printf("PreloaderCmd::ReadPattern(): STOP!");
+			//    return S_STOP;
+			//}
+
+
+			memset(szRevBuf, 0, MAX_REVBUF_SIZE);
+			dwReadLen = 0;
+			if(m_cPort.ReadComm(szRevBuf, MAX_REVBUF_SIZE, &dwReadLen)) 
+			{
+				printf("ReadComm Read fail!\n");
+				return S_PL_READ_FAIL;
+			}
+			else if(0 != dwReadLen)
+			{
+				//printf("PreloaderCmd::ReadPattern(): Dump data: ===%s===\n", szRevBuf);
+				//printf("PreloaderCmd::ReadPattern(): Dump data size: %u\n", dwReadLen);
+
+				for(unsigned int k = 0; k < dwReadLen; k++)
+				{				
+					memcpy(szFlowPool, szFlowPool+1, uPoolSize-1);
+					memcpy(szFlowPool+uPoolSize-1, szRevBuf+k, 1);
+
+					for(unsigned int s = 0; s < kPatternNum; s++ )
+					{
+						if(0 == memcmp(szFlowPool + (uPoolSize - pPattern[s].m_uLen), pPattern[s].m_szPattern, pPattern[s].m_uLen))
+						{
+							//printf("Pattern matched: %s\n", pPattern[s].m_szPattern);
+							return pPattern[s].m_uStatus;
+						}
+					}
+				}
+			}
+
+			Sleep(m_uInterval);
+		}
+
+		printf("Read timeout! Retry time(%u)\n", m_uRetryTime);
+		return S_PL_READ_TIMEOUT;
+	}
+	catch(...)
+	{
+
+		printf( "Unknown exception! Err(%u)\n", GetLastError());
+
+		return S_UNDEFINED_ERROR;
+	}
+}
+
+
+unsigned int PreloaderCmd::WritePattern(const char * pPattern, const int kPatternLen)
+{
+	DWORD dwWritelen = 0;
+
+	// Check parameters
+	if( (NULL== pPattern) ||(0 >= kPatternLen ) )
+	{
+		printf( "Incorrect parameters!(NULL pointer or wrong pattern length)\n");
+		return S_INVALID_ARGUMENTS;
+	}
+
+
+	if(m_cPort.WriteComm(pPattern, kPatternLen, &dwWritelen)) 
+	{
+		printf("WriteComm Write fail!\n");
+		return S_PL_WRITE_FAIL;
+	}
+
+	if(dwWritelen != kPatternLen)
+	{
+		printf("Write incomplete!May be timeout...\n");
+		return S_PL_WRITE_TIMEOUT;
+	}
+
+	return S_DONE;
+}
+
+
+unsigned int PreloaderCmd::CMD_BootAsFastboot(BOOT_ARG_S * pArg)
+{
+	unsigned int iRet = S_DONE;
+
+	//Check parameters
+	if(NULL == pArg)
+	{
+		printf( "Incorrect parameters!(NULL pointer)\n");
+		return S_INVALID_ARGUMENTS;
+	}
+
+	//Set parameters and open/configure port
+	SetParameters(pArg);
+	if(0 != (iRet = SetPort(pArg)))
+	{
+		printf("Set port fail!\n");
+		return iRet;
+	}
+
+
+	//printf("Start handshake with Preloader...\n");
+
+	//Read pattern "READY"
+	PATTERN_INFO_S stPattern;
+	stPattern.m_uStatus = S_DONE;
+	stPattern.m_uLen = strlen(kStrReady);
+	strcpy(stPattern.m_szPattern, kStrReady);
+	iRet = ReadPattern(&stPattern, 1);
+	if(S_DONE == iRet)
+	{
+		//printf("PreloaderCmd::CMD_BootAsFastboot(): Receive READY succeed!\n");
+	}
+	else
+	{
+		printf( "Cannot receive pattern wanted!Ret(%u).\n", iRet);
+		m_cPort.Close();
+		return iRet;
+	}
+
+
+	//Write pattern "FASTBOOT" and its parameters
+	PL_MODE_PARA_S tModePara;
+	PARA_VALUE_S_V1 tValue;
+
+	tValue.m_cKernelUSBType = (pArg->m_bIsCompositeDeviceEnable) ? (0) : (1);
+	tValue.m_cKernelUSBNum= 0;
+	tValue.dummy1= 0;
+	tValue.dummy2= 0;
+
+	memcpy(tModePara.m_aMode, kStrFBTReq, strlen(kStrFBTReq));    
+	tModePara.m_uParaLen = sizeof(PARA_VALUE_S_V1);
+	tModePara.m_uParaVer = 1;
+	tModePara.m_nParaVal.m_tParaV1 = tValue;
+
+
+	//iRet = WritePattern(kStrFBTReq, strlen(kStrFBTReq));
+	iRet = WritePattern((char *)&tModePara, sizeof(PL_MODE_PARA_S));
+	if(S_DONE == iRet)
+	{
+		//printf( "Send Request.\n");
+	}
+	else
+	{
+		printf("Send request fail. Ret(%u).\n", iRet);
+		m_cPort.Close();
+		return iRet;
+	}
+
+	//Read pattern "TOOBTSAF"
+	PATTERN_INFO_S stFBTPattern[1];
+	stFBTPattern[0].m_uStatus = S_DONE;
+	stFBTPattern[0].m_uLen = strlen(kStrFBTSuccess);
+	strcpy(stFBTPattern[0].m_szPattern, kStrFBTSuccess);
+
+	//stFBTPattern[1].m_uStatus = S_PL_MODE_FORBIDDEN;
+	//stFBTPattern[1].m_uLen = strlen(kStrFBTInvalid);
+	//strcpy(stFBTPattern[1].m_szPattern, kStrFBTInvalid);
+	iRet = ReadPattern(stFBTPattern, 1);
+#if 0
+	stPattern.m_uStatus = S_DONE;
+	stPattern.m_uLen = strlen(kStrFBTSuccess);
+	strcpy(stPattern.m_szPattern, kStrFBTSuccess);
+	iRet = ReadPattern(&stPattern, 1);
+#endif
+
+	if(S_DONE == iRet)
+	{
+		//printf("Receive confirm succeed.\n");
+	}   
+	else if(S_PL_MODE_INVALID_ARGUMETS == iRet)
+	{
+		printf("FASTBOOT mode arguments is invalid!\n");
+	}
+	else
+	{
+		printf("Cannot receive pattern wanted!Err(%u).\n", iRet);
+	}
+
+	m_cPort.Close();
+	return iRet;    
+}
+
+
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/preloadercmd.h b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/preloadercmd.h
new file mode 100755
index 0000000..fd1b308
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/preloadercmd.h
@@ -0,0 +1,85 @@
+#ifndef _PRELOADER_CMD_H_
+#define _PRELOADER_CMD_H_
+
+#include "NewCOMUtil.h"
+#include "status.h"
+#include "brom.h"
+
+
+#define MAX_MSG_SIZE  256
+#define MAX_REVBUF_SIZE  256
+#define MAX_PATTERN_LEN 16
+
+
+/* 
+  * The structure definition of mode parameters
+  */
+//*********************************************************
+typedef struct
+{
+    unsigned char m_cKernelUSBType;    //0(Single interface device), 1(Composite device)
+    unsigned char m_cKernelUSBNum;    //The COM port number of Kernel USB
+    unsigned char dummy1;
+    unsigned char dummy2;
+    
+} PARA_VALUE_S_V1;
+
+typedef union
+{
+    PARA_VALUE_S_V1 m_tParaV1;
+    
+} PARA_VALUE_U;
+
+typedef struct
+{
+    unsigned char m_aMode[8];    //Mode magic, such as "METAMETA"
+    unsigned int m_uParaLen;    //The length of mode parameters
+    unsigned int m_uParaVer;    //The version of mode parameters
+    PARA_VALUE_U m_nParaVal;
+    
+} PL_MODE_PARA_S;
+
+//*********************************************************
+
+
+typedef struct
+{
+    unsigned int m_uStatus;
+    unsigned int m_uLen;
+    char m_szPattern[MAX_PATTERN_LEN];
+    
+} PATTERN_INFO_S;
+
+class PreloaderCmd: public NewCOMUtil
+{
+public:
+    PreloaderCmd();
+    ~PreloaderCmd();
+
+    int SelectBootMode(BOOT_ARG_S * pArg);
+    void SetParameters(BOOT_ARG_S * pArg);
+    int SetPort(BOOT_ARG_S * pArg);
+
+    unsigned int ReadPattern(PATTERN_INFO_S * pPattern, const unsigned int kPatternNum);
+    unsigned int WritePattern(const char * pPattern, const int kPatternLen);
+    unsigned int CMD_BootAsFastboot(BOOT_ARG_S * pArg);
+
+    //inline functions
+    inline void SetTimeout(unsigned int uTimeout) { m_uTimeout = uTimeout; }
+    inline void SetRetryCount(unsigned int uRetryTime) { m_uRetryTime = uRetryTime; }
+    inline void SetInterval(unsigned int uInterval) { m_uInterval = uInterval; }
+    inline void SetStopFlagAddr(int * pStopFlag) { m_pStopFlag= pStopFlag; }
+
+
+private:
+    unsigned int m_uTimeout;
+    unsigned int m_uRetryTime;
+    unsigned int m_uInterval;
+    int * m_pStopFlag;
+
+    NewCOMUtil m_cPort;
+};
+
+
+
+#endif //_PRELOADER_CMD_H_
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/status.h b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/status.h
new file mode 100755
index 0000000..09a5cb0
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/autoenter/status.h
@@ -0,0 +1,26 @@
+#ifndef _STATUS_H_
+#define _STATUS_H_
+
+typedef enum {
+
+    S_DONE = 0
+    ,S_UNDEFINED_ERROR
+    ,S_INVALID_ARGUMENTS
+	,S_TIMEOUT
+	,S_STOP
+	,S_COM_PORT_OPEN_FAIL
+    ,S_COM_PORT_SET_TIMEOUT_FAIL
+    ,S_COM_PORT_SET_STATE_FAIL
+    ,S_COM_PORT_PURGE_FAIL
+	   //For Preloader command
+    ,S_PL_MODE_UNSUPPORTED = 10001
+    ,S_PL_MODE_FORBIDDEN
+    ,S_PL_MODE_INVALID_ARGUMETS
+    ,S_PL_READ_FAIL
+    ,S_PL_WRITE_FAIL
+    ,S_PL_READ_TIMEOUT
+    ,S_PL_WRITE_TIMEOUT
+};
+
+
+#endif
\ No newline at end of file
diff --git a/system/core/fastboot/fastboot.c b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/fastboot.c
old mode 100644
new mode 100755
index 3de6d7d..f664d1d
--- a/system/core/fastboot/fastboot.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fastboot/fastboot.c
@@ -54,6 +54,10 @@
 #define O_BINARY 0
 #endif
 
+#ifdef _WIN32
+#include "IEnterFastboot.h"
+#endif
+
 char cur_product[FB_RESPONSE_SZ + 1];
 
 void bootimg_set_cmdline(boot_img_hdr *h, const char *cmdline);
@@ -992,6 +996,15 @@ int main(int argc, char **argv)
             }
             wants_reboot = 1;
         } else if(!strcmp(*argv, "oem")) {
+#ifdef _WIN32
+             if(argc > 1)
+             {
+		if(!strcmp(*(argv+1), "enter"))
+		{
+			return NotifyEnterFastbootMode(0,0);
+		}
+             }
+#endif
             argc = do_oem_command(argc, argv);
         } else {
             usage();
diff --git a/system/core/fs_mgr/include/fs_mgr.h b/gb/12055-master/driveronly_mp_rom/system/core/fs_mgr/include/fs_mgr.h
index 76abb83..df6bdfc 100644
--- a/system/core/fs_mgr/include/fs_mgr.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/fs_mgr/include/fs_mgr.h
@@ -17,11 +17,19 @@
 #ifndef __CORE_FS_MGR_H
 #define __CORE_FS_MGR_H
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 int fs_mgr_mount_all(char *fstab_file);
 int fs_mgr_do_mount(char *fstab_file, char *n_name, char *n_blk_dev, char *tmp_mnt_point);
 int fs_mgr_do_tmpfs_mount(char *n_name);
 int fs_mgr_unmount_all(char *fstab_file);
 int fs_mgr_get_crypt_info(char *fstab_file, char *key_loc, char *real_blk_dev, int size);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __CORE_FS_MGR_H */
 
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/include/arch/mtkNonNDKConfig.h b/gb/12055-master/driveronly_mp_rom/system/core/include/arch/mtkNonNDKConfig.h
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/arch/mtkNonNDKConfig.h
@@ -0,0 +1 @@
+
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/alelog.h b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/alelog.h
new file mode 100644
index 0000000..294c7a9
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/alelog.h
@@ -0,0 +1,59 @@
+#if !defined(__ALE_H__)
+#define __ALE_H__
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#define LOGGER_ALE_MASK         0xf0
+
+#define LOGGER_ALE_MSG_RAW      0x00
+#define LOGGER_ALE_MSG_K        0x10
+#define LOGGER_ALE_MSG_N        0x20
+#define LOGGER_ALE_MSG_J        0x30
+#define LOGGER_ALE_XMSG_K       0x40
+#define LOGGER_ALE_XMSG_N       0x50
+#define LOGGER_ALE_XMSG_J       0x60
+
+#define LOGGER_ALE_MSG_SIZE     768
+
+#define LOGGER_ALE_ARGS_MAX 16
+struct ale_convert {
+    const char *tag_str;
+    const char *fmt_ptr;
+    const char *file;
+    int lineno;
+    unsigned int hash;
+    char params[LOGGER_ALE_ARGS_MAX];
+};
+
+int ale_log_output_binary(int prio, const char *tag, const void *payload, size_t len);
+
+int ale_log_output(int bufid, int prio, const struct ale_convert *convert, ...);
+
+#define ale_log_print(bufid, prio, tag, fmt, ...)			\
+  ({									\
+      if (__builtin_constant_p(tag) && __builtin_constant_p(fmt)) {     \
+          static const struct ale_convert ____ale_rec____ =		\
+	    {								\
+                __builtin_constant_p(tag) ? tag : NULL,			\
+                __builtin_constant_p(fmt) ? fmt : NULL,			\
+                __FILE__,                                               \
+                __builtin_constant_p(prio) ? prio : 0,                  \
+                0,                                                      \
+                "" };                                                   \
+          ale_log_output(bufid, prio, &____ale_rec____, ##__VA_ARGS__);	\
+      }                                                                 \
+      else {                                                            \
+          struct ale_convert ale =                                      \
+              {tag, fmt, NULL,                                          \
+               0, 0, ""};                                               \
+          ale_log_output(bufid, prio, &ale, ##__VA_ARGS__);		\
+      }                                                                 \
+  })
+
+#if defined(__cplusplus)
+};
+#endif
+
+#endif
diff --git a/system/core/include/cutils/list.h b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/list.h
index 3881fc9..03989da 100644
--- a/system/core/include/cutils/list.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/list.h
@@ -45,6 +45,7 @@ struct listnode
     for (node = (list)->prev; node != (list); node = node->prev)
 
 void list_init(struct listnode *list);
+void list_add_head(struct listnode *list, struct listnode *item);
 void list_add_tail(struct listnode *list, struct listnode *item);
 void list_remove(struct listnode *item);
 
diff --git a/system/core/include/cutils/log.h b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/log.h
index 878952e..ed62a10 100644
--- a/system/core/include/cutils/log.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/log.h
@@ -39,6 +39,7 @@
 
 #include <cutils/uio.h>
 #include <cutils/logd.h>
+#include <cutils/alelog.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -353,8 +354,23 @@ extern "C" {
  * Log macro that allows you to specify a number for the priority.
  */
 #ifndef LOG_PRI
-#define LOG_PRI(priority, tag, ...) \
+#ifndef HAVE_ALE_FEATURE
+#define LOG_PRI(priority, tag, ...)		\
     android_printLog(priority, tag, __VA_ARGS__)
+#else
+#define LOG_PRI(priority, tag, ...)		\
+    ale_log_print(LOG_ID_MAIN, priority, tag, __VA_ARGS__)
+#endif
+#endif
+
+#ifndef SLOG_PRI
+#ifndef HAVE_ALE_FEATURE
+#define SLOG_PRI(priority, tag, ...)		\
+    __android_log_buf_print(LOG_ID_SYSTEM, priority, tag, __VA_ARGS__)
+#else
+#define SLOG_PRI(priority, tag, ...)		\
+    ale_log_print(LOG_ID_SYSTEM, priority, tag, __VA_ARGS__)
+#endif
 #endif
 
 /*
diff --git a/system/core/include/cutils/logprint.h b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/logprint.h
index 2b1e1c5..534e8fd 100644
--- a/system/core/include/cutils/logprint.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/logprint.h
@@ -44,6 +44,7 @@ typedef struct AndroidLogEntry_t {
     time_t tv_sec;
     long tv_nsec;
     android_LogPriority priority;
+    int msg_type;
     int32_t pid;
     int32_t tid;
     const char * tag;
diff --git a/system/core/include/cutils/partition_utils.h b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/partition_utils.h
index 597df92..22e17b7 100644
--- a/system/core/include/cutils/partition_utils.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/partition_utils.h
@@ -22,6 +22,18 @@ __BEGIN_DECLS
 int partition_wiped(char *source);
 void erase_footer(const char *dev_path, long long size);
 
+#ifdef MTK_EMMC_SUPPORT
+    #define PHONE_ENCRYPTED (0x4321)
+    #define PHONE_UNCRYPTED (0x0)
+    #define PHONE_ENCRYPT_OFFSET (2048)
+    struct phone_encrypt_state {
+        int state;
+    };
+
+    int misc_set_phone_encrypt_state(const struct phone_encrypt_state *in);
+    int misc_get_phone_encrypt_state(struct phone_encrypt_state *in);
+#endif
+
 __END_DECLS
 
 #endif /* __CUTILS_PARTITION_WIPED_H__ */
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/pmem.h b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/pmem.h
new file mode 100644
index 0000000..d3f2557
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/pmem.h
@@ -0,0 +1,118 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+
+
+#ifndef _CUTILS_PMEM_H
+#define _CUTILS_PMEM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Allocates a memory block which is continuous in physical memory.
+ * @param size  number of bytes to allocate
+ * @param pfd   pointer to associate file descriptor
+ * @return a void pointer to the allocated space, or NULL if there is insufficient
+ *         memory available.
+ */
+void* pmem_alloc(size_t size, int *pfd);
+
+/**
+ * Allocates a sync memory block which is continuous in physical memory.
+ * @param size  number of bytes to allocate
+ * @param pfd   pointer to associate file descriptor
+ * @return a void pointer to the allocated space, or NULL if there is insufficient
+ *         memory available.
+ */
+void* pmem_alloc_sync(size_t size, int *pfd);
+
+/**
+ * Deallocates or frees a memory block which is continuous in physical memory.
+ * @param ptr  pointer to previously allocated memory block which is allocated by pmem_alloc().
+ * @param size size of the memory block which is allocated by pmem_alloc().
+ * @param fd   associated file descriptor of the memory block which is allocated by pmem_alloc().
+ * @return 0 if success, or nagtive value if there is error
+ */
+int  pmem_free(void *ptr, size_t size, int fd);
+
+/**
+ * Convert the address of a memory block from virtual address to physical address.
+ * @param fd       associated file descriptor of the memory block which is allocated by pmem_alloc().
+ * @return a void pointer contains the physical address, or NULL if virPtr is invalid.
+ */
+void* pmem_get_phys(int fd);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _CUTILS_PMEM_H */
+
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/xlog.h b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/xlog.h
new file mode 100644
index 0000000..b4d93b7
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/cutils/xlog.h
@@ -0,0 +1,179 @@
+#if !defined(_XLOG_H)
+#define _XLOG_H
+
+#include <cutils/log.h>
+#include <cutils/alelog.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int xlogf_java_tag_is_on(const char *name, int level);
+int xlogf_native_tag_is_on(const char *name, int level);
+
+int xlogf_java_xtag_is_on(const char *name, int level);
+int xlogf_native_xtag_is_on(const char *name, int level);
+
+#ifndef XLOG_TAG
+#define XLOG_TAG NULL
+#endif
+
+#ifndef SXLOGV
+#define SXLOGV(...) ((void)SXLOG_PRI(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__))
+#endif
+#ifndef SXLOGD
+#define SXLOGD(...) ((void)SXLOG_PRI(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__))
+#endif
+#ifndef SXLOGI
+#define SXLOGI(...) ((void)SXLOG_PRI(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__))
+#endif
+#ifndef SXLOGW
+#define SXLOGW(...) ((void)SXLOG_PRI(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__))
+#endif
+#ifndef SXLOGE
+#define SXLOGE(...) ((void)SXLOG_PRI(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))
+#endif
+#ifndef SXLOGF
+#define SXLOGF(...) ((void)SXLOG_PRI(ANDROID_LOG_FATAL, LOG_TAG, __VA_ARGS__))
+#endif
+#if LOG_NDEBUG
+#define SXLOG_ASSERT(cond, ...)			\
+    ( (CONDITION(cond))				\
+      ? ((void)SXLOGF(LOG_TAG, __VA_ARGS__))	\
+      : (void)0 )
+#else
+#define SXLOG_ASSERT(cond, ...) ((void)0)
+#endif
+
+#define SXLOG_ALWAYS_ASSERT(cond,...)                    \
+  ( (CONDITION(cond))					 \
+    ? ((void)SXLOGF(LOG_TAG, __VA_ARGS__))		 \
+      : (void)0 )
+
+#ifndef XLOGV
+#define XLOGV(...) ((void)XLOG_PRI(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__))
+#endif
+#ifndef XLOGD
+#define XLOGD(...) ((void)XLOG_PRI(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__))
+#endif
+#ifndef XLOGI
+#define XLOGI(...) ((void)XLOG_PRI(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__))
+#endif
+#ifndef XLOGW
+#define XLOGW(...) ((void)XLOG_PRI(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__))
+#endif
+#ifndef XLOGE
+#define XLOGE(...) ((void)XLOG_PRI(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))
+#endif
+#ifndef XLOGF
+#define XLOGF(...) ((void)XLOG_PRI(ANDROID_LOG_FATAL, LOG_TAG, __VA_ARGS__))
+#endif
+
+#if LOG_NDEBUG
+#define XLOG_ASSERT(cond, ...)                  \
+    (!(cond)                                    \
+     ? ((void)XLOGF(__VA_ARGS__))		\
+     : (void)0)
+#else
+#define XLOG_ASSERT(cond, ...) ((void)0)
+#endif
+
+#define XLOG_ALWAY_ASSERT(cond, ...)                    \
+    (!(cond)                                            \
+     ? ((void)XLOGF(__VA_ARGS__))			\
+     : (void)0)
+
+
+#ifndef SXLOGV2
+#define SXLOGV2(...) ((void)SXLOG_PRI(ANDROID_LOG_VERBOSE, XLOG_TAG, __VA_ARGS__))
+#endif
+#ifndef SXLOGD2
+#define SXLOGD2(...) ((void)SXLOG_PRI(ANDROID_LOG_DEBUG, XLOG_TAG, __VA_ARGS__))
+#endif
+#ifndef SXLOGI2
+#define SXLOGI2(...) ((void)SXLOG_PRI(ANDROID_LOG_INFO, XLOG_TAG, __VA_ARGS__))
+#endif
+#ifndef SXLOGW2
+#define SXLOGW2(...) ((void)SXLOG_PRI(ANDROID_LOG_WARN, XLOG_TAG, __VA_ARGS__))
+#endif
+#ifndef SXLOGE2
+#define SXLOGE2(...) ((void)SXLOG_PRI(ANDROID_LOG_ERROR, XLOG_TAG, __VA_ARGS__))
+#endif
+#ifndef SXLOGF2
+#define SXLOGF2(...) ((void)SXLOG_PRI(ANDROID_LOG_FATAL, XLOG_TAG, __VA_ARGS__))
+#endif
+
+#ifndef XLOGV2
+#define XLOGV2(...) ((void)XLOG_PRI(ANDROID_LOG_VERBOSE, XLOG_TAG, __VA_ARGS__))
+#endif
+#ifndef XLOGD2
+#define XLOGD2(...) ((void)XLOG_PRI(ANDROID_LOG_DEBUG, XLOG_TAG, __VA_ARGS__))
+#endif
+#ifndef XLOGI2
+#define XLOGI2(...) ((void)XLOG_PRI(ANDROID_LOG_INFO, XLOG_TAG, __VA_ARGS__))
+#endif
+#ifndef XLOGW2
+#define XLOGW2(...) ((void)XLOG_PRI(ANDROID_LOG_WARN, XLOG_TAG, __VA_ARGS__))
+#endif
+#ifndef XLOGE2
+#define XLOGE2(...) ((void)XLOG_PRI(ANDROID_LOG_ERROR, XLOG_TAG, __VA_ARGS__))
+#endif
+#ifndef XLOGF2
+#define XLOGF2(...) ((void)XLOG_PRI(ANDROID_LOG_FATAL, XLOG_TAG, __VA_ARGS__))
+#endif
+
+struct xlog_record {
+	const char *tag_str;
+	const char *fmt_str;
+	int prio;
+};
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+int __xlog_buf_printf(int bufid, const struct xlog_record *rec, ...);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#if !defined(HAVE_ALE_FEATURE)
+
+#define xlog_buf_printf(bufid, prio, tag, fmt, ...)			\
+	({								\
+		static const struct xlog_record _xlog_rec =		\
+			{tag, fmt, prio};				\
+		__xlog_buf_printf(bufid, &_xlog_rec, ##__VA_ARGS__);	\
+	})
+
+#else
+
+#define xlog_buf_printf(bufid, prio, tag, fmt, ...)			\
+  ({									\
+      static const struct ale_convert ____xlog_ale_rec____ =		\
+          { tag, fmt, __FILE__, prio, 0, "" };				\
+      ale_log_output(bufid, prio, &____xlog_ale_rec____,		\
+                     ##__VA_ARGS__);                                    \
+  })
+
+#endif
+
+#define XLOG_PRI(priority, tag, ...)                            \
+    xlog_buf_printf(LOG_ID_MAIN, priority, tag, __VA_ARGS__)
+
+#define SXLOG_PRI(priority, tag, ...)                           \
+    xlog_buf_printf(LOG_ID_MAIN, priority, tag, __VA_ARGS__)
+
+#define xlog_printf(priority, tag, ...)                         \
+    xlog_buf_printf(LOG_ID_MAIN, priority, tag, __VA_ARGS__)
+
+#define sxlog_printf(priority, tag, ...)                        \
+    xlog_buf_printf(LOG_ID_SYSTEM, priority, tag, __VA_ARGS__)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/system/core/include/ion/ion.h b/gb/12055-master/driveronly_mp_rom/system/core/include/ion/ion.h
index 018c0a1..faaf262 100644
--- a/system/core/include/ion/ion.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/ion/ion.h
@@ -25,18 +25,38 @@
 
 __BEGIN_DECLS
 
+// Open ION device.
 int ion_open();
+// Close ION device.
 int ion_close(int fd);
 int ion_alloc(int fd, size_t len, size_t align, unsigned int heap_mask,
 	      unsigned int flags, struct ion_handle **handle);
 int ion_alloc_fd(int fd, size_t len, size_t align, unsigned int heap_mask,
 		 unsigned int flags, int *handle_fd);
-int ion_sync_fd(int fd, int handle_fd);
+// Allocate buffer from multimedia heap.
+int ion_alloc_mm(int fd, size_t len, size_t align, 
+                 unsigned int flags, struct ion_handle **handle);
+// Allocate buffer from system contiguous heap.
+int ion_alloc_syscontig(int fd, size_t len, size_t align, 
+                        unsigned int flags, struct ion_handle **handle);
+// Free ION buffer
 int ion_free(int fd, struct ion_handle *handle);
+// Map virtual address of ION buffer
+void* ion_mmap(int fd, void *addr, size_t length, int prot, int flags, int share_fd, off_t offset);
+// UnMap virtual address of ION buffer
+int ion_munmap(int fd, void *addr, size_t length);
+// Get share fd of ION buffer.
+int ion_share(int fd, struct ion_handle *handle, int *share_fd);
+int ion_sync_fd(int fd, int handle_fd);
+// Close share fd of ION buffer.
+int ion_share_close(int fd, int share_fd);
 int ion_map(int fd, struct ion_handle *handle, size_t length, int prot,
             int flags, off_t offset, unsigned char **ptr, int *map_fd);
 int ion_share(int fd, struct ion_handle *handle, int *share_fd);
+// Import an ION buffer
 int ion_import(int fd, int share_fd, struct ion_handle **handle);
+// ION custom IOCTL
+int ion_custom_ioctl(int fd, unsigned int cmd, void *arg);
 
 __END_DECLS
 
diff --git a/system/core/include/netutils/dhcp.h b/gb/12055-master/driveronly_mp_rom/system/core/include/netutils/dhcp.h
index d25e58f..1fd66de 100644
--- a/system/core/include/netutils/dhcp.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/netutils/dhcp.h
@@ -35,6 +35,17 @@ extern int dhcp_do_request(const char *ifname,
 extern int dhcp_stop(const char *ifname);
 extern int dhcp_release_lease(const char *ifname);
 extern char *dhcp_get_errmsg();
+extern char *dhcpv6_get_errmsg();
+
+extern int dhcpv6_do_request(const char *interface, char *ipaddr,
+		char *dns1,
+		char *dns2,
+		uint32_t *lease);
+extern int dhcpv6_stop(const char *interface);
+extern int dhcpv6_do_request_renew(const char *interface, char *ipaddr,
+		char *dns1,
+		char *dns2,
+		uint32_t *lease);
 
 __END_DECLS
 
diff --git a/system/core/include/netutils/ifc.h b/gb/12055-master/driveronly_mp_rom/system/core/include/netutils/ifc.h
index 1f5421d..5d29f9c 100644
--- a/system/core/include/netutils/ifc.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/netutils/ifc.h
@@ -20,6 +20,11 @@
 #include <sys/cdefs.h>
 #include <arpa/inet.h>
 
+struct uid_err {
+    int appuid;
+	int errorNum;
+};
+
 __BEGIN_DECLS
 
 extern int ifc_init(void);
@@ -30,14 +35,16 @@ extern int ifc_get_hwaddr(const char *name, void *ptr);
 
 extern int ifc_up(const char *name);
 extern int ifc_down(const char *name);
+extern int ifc_is_up(const char *name, unsigned *isup);
 
 extern int ifc_enable(const char *ifname);
 extern int ifc_disable(const char *ifname);
 
-#define RESET_IPV4_ADDRESSES 0x01
-#define RESET_IPV6_ADDRESSES 0x02
-#define RESET_ALL_ADDRESSES  (RESET_IPV4_ADDRESSES | RESET_IPV6_ADDRESSES)
+extern int ifc_enable_allmc(const char *name);
+extern int ifc_disable_allmc(const char *name);
+
 extern int ifc_reset_connections(const char *ifname, const int reset_mask);
+extern int ifc_reset_connection_by_uid(int uid, int error); 
 
 extern int ifc_get_addr(const char *name, in_addr_t *addr);
 extern int ifc_set_addr(const char *name, in_addr_t addr);
@@ -69,7 +76,7 @@ extern int ifc_configure(const char *ifname, in_addr_t address,
                          uint32_t prefixLength, in_addr_t gateway,
                          in_addr_t dns1, in_addr_t dns2);
 
-extern in_addr_t prefixLengthToIpv4Netmask(int prefix_length);
+extern int ifc_set_throttle(const char *ifname, int rxKbps, int txKbps);
 
 __END_DECLS
 
diff --git a/system/core/include/private/android_filesystem_config.h b/gb/12055-master/driveronly_mp_rom/system/core/include/private/android_filesystem_config.h
index 7e34da8..e352772 100644
--- a/system/core/include/private/android_filesystem_config.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/private/android_filesystem_config.h
@@ -78,6 +78,8 @@
 #define AID_NET_BW_ACCT   3007  /* change bandwidth statistics accounting */
 #define AID_NET_BT_STACK  3008  /* bluetooth: access config files */
 
+#define AID_CCCI          9996
+#define AID_NVRAM         9997
 #define AID_MISC          9998  /* access to misc storage */
 #define AID_NOBODY        9999
 
@@ -138,7 +140,9 @@ static const struct android_id_info android_ids[] = {
     { "net_bw_stats", AID_NET_BW_STATS, },
     { "net_bw_acct", AID_NET_BW_ACCT, },
     { "misc",      AID_MISC, },
+    { "nvram",	   AID_NVRAM,},
     { "nobody",    AID_NOBODY, },
+    { "ccci",      AID_CCCI, },
 };
 
 #define android_id_count \
@@ -192,6 +196,7 @@ static struct fs_path_config android_files[] = {
     { 00550, AID_ROOT,      AID_SHELL,     "system/etc/init.ril" },
     { 00550, AID_ROOT,      AID_SHELL,     "system/etc/init.testmenu" },
     { 00550, AID_DHCP,      AID_SHELL,     "system/etc/dhcpcd/dhcpcd-run-hooks" },
+    { 00550, AID_DHCP,      AID_SHELL,     "system/etc/wide-dhcpv6/dhcp6c.script" },
     { 00440, AID_BLUETOOTH, AID_BLUETOOTH, "system/etc/dbus.conf" },
     { 00444, AID_RADIO,     AID_AUDIO,     "system/etc/AudioPara4.csv" },
     { 00555, AID_ROOT,      AID_ROOT,      "system/etc/ppp/*" },
@@ -210,7 +215,7 @@ static struct fs_path_config android_files[] = {
     { 06755, AID_ROOT,      AID_ROOT,      "system/xbin/librank" },
     { 06755, AID_ROOT,      AID_ROOT,      "system/xbin/procrank" },
     { 06755, AID_ROOT,      AID_ROOT,      "system/xbin/procmem" },
-    { 06755, AID_ROOT,      AID_ROOT,      "system/xbin/tcpdump" },
+    { 00755, AID_ROOT,      AID_ROOT,      "system/xbin/tcpdump" },
     { 04770, AID_ROOT,      AID_RADIO,     "system/bin/pppd-ril" },
 		/* the following file is INTENTIONALLY set-uid, and IS included
 		 * in user builds. */
diff --git a/system/core/include/system/audio.h b/gb/12055-master/driveronly_mp_rom/system/core/include/system/audio.h
index d246070..3758cf8 100644
--- a/system/core/include/system/audio.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/system/audio.h
@@ -46,7 +46,11 @@ typedef enum {
     AUDIO_STREAM_ENFORCED_AUDIBLE = 7, /* Sounds that cannot be muted by user and must be routed to speaker */
     AUDIO_STREAM_DTMF             = 8,
     AUDIO_STREAM_TTS              = 9,
-
+//#ifdef MTK_AUDIO
+    AUDIO_STREAM_FM               = 10,
+    AUDIO_STREAM_MATV             = 11,
+    AUDIO_STREAM_BOOT             = 12, //only used for bootanimation and output from speaker and headset
+//#endif
     AUDIO_STREAM_CNT,
     AUDIO_STREAM_MAX              = AUDIO_STREAM_CNT - 1,
 } audio_stream_type_t;
@@ -67,6 +71,16 @@ typedef enum {
                                           /* An example of remote presentation is Wifi Display */
                                           /*  where a dongle attached to a TV can be used to   */
                                           /*  play the mix captured by this audio source.      */
+#ifndef ANDROID_DEFAULT_CODE
+	AUDIO_SOURCE_VOICE_UNLOCK =80,
+	AUDIO_SOURCE_CUSTOMIZATION1 =81,
+	AUDIO_SOURCE_CUSTOMIZATION2 =82,
+	AUDIO_SOURCE_CUSTOMIZATION3 =83,
+    AUDIO_SOURCE_MATV =98,
+    AUDIO_SOURCE_FM =99,
+//    AUDIO_SOURCE_MAX = AUDIO_SOURCE_FM,
+#endif
+
     AUDIO_SOURCE_CNT,
     AUDIO_SOURCE_MAX                 = AUDIO_SOURCE_CNT - 1,
 } audio_source_t;
@@ -153,6 +167,9 @@ typedef enum {
                                         AUDIO_FORMAT_PCM_SUB_32_BIT),
     AUDIO_FORMAT_PCM_8_24_BIT        = (AUDIO_FORMAT_PCM |
                                         AUDIO_FORMAT_PCM_SUB_8_24_BIT),
+//#ifdef MTK_AUDIO
+    AUDIO_FORMAT_VM_FMT
+//#endif
 } audio_format_t;
 
 enum {
@@ -264,6 +281,9 @@ typedef enum {
     AUDIO_MODE_RINGTONE         = 1,
     AUDIO_MODE_IN_CALL          = 2,
     AUDIO_MODE_IN_COMMUNICATION = 3,
+//#ifdef MTK_AUDIO
+    AUDIO_MODE_IN_CALL_2        = 4,
+//#endif
 
     AUDIO_MODE_CNT,
     AUDIO_MODE_MAX              = AUDIO_MODE_CNT - 1,
@@ -301,6 +321,9 @@ enum {
     AUDIO_DEVICE_OUT_USB_DEVICE                = 0x4000,
     AUDIO_DEVICE_OUT_REMOTE_SUBMIX             = 0x8000,
     AUDIO_DEVICE_OUT_DEFAULT                   = AUDIO_DEVICE_BIT_DEFAULT,
+//#ifdef MTK_AUDIO
+    AUDIO_DEVICE_OUT_FM_TX                     = 0x10000,
+//#endif
     AUDIO_DEVICE_OUT_ALL      = (AUDIO_DEVICE_OUT_EARPIECE |
                                  AUDIO_DEVICE_OUT_SPEAKER |
                                  AUDIO_DEVICE_OUT_WIRED_HEADSET |
@@ -341,6 +364,10 @@ enum {
     AUDIO_DEVICE_IN_DGTL_DOCK_HEADSET     = AUDIO_DEVICE_BIT_IN | 0x400,
     AUDIO_DEVICE_IN_USB_ACCESSORY         = AUDIO_DEVICE_BIT_IN | 0x800,
     AUDIO_DEVICE_IN_USB_DEVICE            = AUDIO_DEVICE_BIT_IN | 0x1000,
+//#ifdef MTK_AUDIO
+    AUDIO_DEVICE_IN_FM                     = AUDIO_DEVICE_BIT_IN |0x1000000,
+    AUDIO_DEVICE_IN_AUX_DIGITAL2      = AUDIO_DEVICE_BIT_IN|0x8000000,
+//#endif
     AUDIO_DEVICE_IN_DEFAULT               = AUDIO_DEVICE_BIT_IN | AUDIO_DEVICE_BIT_DEFAULT,
 
     AUDIO_DEVICE_IN_ALL     = (AUDIO_DEVICE_IN_COMMUNICATION |
@@ -356,6 +383,7 @@ enum {
                                AUDIO_DEVICE_IN_DGTL_DOCK_HEADSET |
                                AUDIO_DEVICE_IN_USB_ACCESSORY |
                                AUDIO_DEVICE_IN_USB_DEVICE |
+                               AUDIO_DEVICE_IN_AUX_DIGITAL2 |
                                AUDIO_DEVICE_IN_DEFAULT),
     AUDIO_DEVICE_IN_ALL_SCO = AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET,
 };
@@ -420,12 +448,31 @@ static inline bool audio_is_a2dp_device(audio_devices_t device)
 
 static inline bool audio_is_bluetooth_sco_device(audio_devices_t device)
 {
+#if 1 ////#ifdef MTK_AUDIO
+    if(audio_is_input_device(device))
+    {
+    device &= ~AUDIO_DEVICE_BIT_IN;
+    if ((popcount(device) == 1) && (device &
+                   (AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET& ~AUDIO_DEVICE_BIT_IN)))
+        return true;
+    else
+        return false;
+    }else//output device
+    {
+        if ((popcount(device) == 1) && (device & AUDIO_DEVICE_OUT_ALL_SCO))
+            return true;
+        else
+            return false;
+
+    }
+#else //Android Error - Cause device checking fail
     device &= ~AUDIO_DEVICE_BIT_IN;
     if ((popcount(device) == 1) && (device & (AUDIO_DEVICE_OUT_ALL_SCO |
                    AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET)))
         return true;
     else
         return false;
+#endif
 }
 
 static inline bool audio_is_usb_device(audio_devices_t device)
diff --git a/system/core/include/system/audio_policy.h b/gb/12055-master/driveronly_mp_rom/system/core/include/system/audio_policy.h
index a6554de..7013e08 100644
--- a/system/core/include/system/audio_policy.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/system/audio_policy.h
@@ -44,6 +44,9 @@ typedef enum {
     AUDIO_POLICY_FORCE_DIGITAL_DOCK,
     AUDIO_POLICY_FORCE_NO_BT_A2DP, /* A2DP sink is not preferred to speaker or wired HS */
     AUDIO_POLICY_FORCE_SYSTEM_ENFORCED,
+#ifndef ANDROID_DEFAULT_CODE
+	AUDIO_POLICY_FORCE_NO_SYSTEM_ENFORCED,
+#endif
 
     AUDIO_POLICY_FORCE_CFG_CNT,
     AUDIO_POLICY_FORCE_CFG_MAX = AUDIO_POLICY_FORCE_CFG_CNT - 1,
@@ -58,6 +61,9 @@ typedef enum {
     AUDIO_POLICY_FORCE_FOR_RECORD,
     AUDIO_POLICY_FORCE_FOR_DOCK,
     AUDIO_POLICY_FORCE_FOR_SYSTEM,
+#ifndef ANDROID_DEFAULT_CODE    
+    AUDIO_POLICY_FORCE_FOR_PROPRIETARY,//HoChi
+#endif    
 
     AUDIO_POLICY_FORCE_USE_CNT,
     AUDIO_POLICY_FORCE_USE_MAX = AUDIO_POLICY_FORCE_USE_CNT - 1,
diff --git a/system/core/include/system/camera.h b/gb/12055-master/driveronly_mp_rom/system/core/include/system/camera.h
index 7a4dd53..3efb904 100644
--- a/system/core/include/system/camera.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/system/camera.h
@@ -88,7 +88,14 @@ enum {
     // Notify on autofocus start and stop. This is useful in continuous
     // autofocus - FOCUS_MODE_CONTINUOUS_VIDEO and FOCUS_MODE_CONTINUOUS_PICTURE.
     CAMERA_MSG_FOCUS_MOVE = 0x0800,       // notifyCallback
+//!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+#ifndef MTK_CAMERA_BSP_SUPPORT
     CAMERA_MSG_ALL_MSGS = 0xFFFF
+#else
+    CAMERA_MSG_ALL_MSGS         = 0xC000FFFF
+#endif
+//!-----------------------------------------------------------------------------
+
 };
 
 /** cmdType in sendCommand functions */
diff --git a/system/core/include/system/graphics.h b/gb/12055-master/driveronly_mp_rom/system/core/include/system/graphics.h
index 82b5fcc..9f8bbed 100644
--- a/system/core/include/system/graphics.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/system/graphics.h
@@ -60,6 +60,9 @@ enum {
      * gralloc buffer of one of these formats must be supported for use with the
      * GL_OES_EGL_image_external OpenGL ES extension.
      */
+    HAL_PIXEL_FORMAT_I420           = 0x00000100,     // MTK I420
+    HAL_PIXEL_FORMAT_NV12_BLK       = 0x00000101,     // MTK NV12 block progressive mode
+    HAL_PIXEL_FORMAT_NV12_BLK_FCM   = 0x00000102,     // MTK NV12 block field mode
 
     /*
      * Android YUV format:
diff --git a/system/core/include/sysutils/NetlinkEvent.h b/gb/12055-master/driveronly_mp_rom/system/core/include/sysutils/NetlinkEvent.h
index 25a56f7..69ae1a1 100644
--- a/system/core/include/sysutils/NetlinkEvent.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/include/sysutils/NetlinkEvent.h
@@ -34,7 +34,9 @@ public:
     const static int NlActionChange;
     const static int NlActionLinkDown;
     const static int NlActionLinkUp;
-
+    const static int NlActionIPv6Enable;
+    const static int NlActionIPv6Disable;
+    
     NetlinkEvent();
     virtual ~NetlinkEvent();
 
diff --git a/system/core/init/Android.mk b/gb/12055-master/driveronly_mp_rom/system/core/init/Android.mk
index a1c1e7a..4680236 100644
--- a/system/core/init/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/system/core/init/Android.mk
@@ -8,6 +8,7 @@ LOCAL_SRC_FILES:= \
 	init.c \
 	devices.c \
 	property_service.c \
+	property_patch.c \
 	util.c \
 	parser.c \
 	logo.c \
@@ -23,8 +24,12 @@ LOCAL_SRC_FILES += bootchart.c
 LOCAL_CFLAGS    += -DBOOTCHART=1
 endif
 
+ifeq ($(strip $(MTK_NAND_UBIFS_SUPPORT)),yes)
+LOCAL_CFLAGS += -DMTK_NAND_UBIFS_SUPPORT
+endif
+
 ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
-LOCAL_CFLAGS += -DALLOW_LOCAL_PROP_OVERRIDE=1
+LOCAL_CFLAGS += -DALLOW_LOCAL_PROP_OVERRIDE=1 -DINIT_ENG_BUILD
 endif
 
 LOCAL_MODULE:= init
@@ -41,6 +46,27 @@ LOCAL_C_INCLUDES += external/libselinux/include
 LOCAL_CFLAGS += -DHAVE_SELINUX
 endif
 
+ifeq ($(PARTIAL_BUILD),true)
+LOCAL_CFLAGS += -DPARTIAL_BUILD
+endif
+ifeq ($(HAVE_AEE_FEATURE),yes)
+LOCAL_CFLAGS += -DHAVE_AEE_FEATURE
+LOCAL_STATIC_LIBRARIES += libaed_static
+endif
+
+ifeq ($(NO_INIT_PERMISSION_CHECK),yes)
+LOCAL_CFLAGS    += -DNO_INIT_PERMISSION_CHECK
+endif
+
+ifeq ($(TARGET_NO_FACTORYIMAGE),true)
+LOCAL_CFLAGS += -DUSE_BUILT_IN_FACTORY
+endif
+
+#INF@MTK, add for KPOC mode {
+ifeq ($(MTK_KERNEL_POWER_OFF_CHARGING),yes)
+LOCAL_CFLAGS += -DMTK_KERNEL_POWER_OFF_CHARGING_SUPPORT
+endif
+
 include $(BUILD_EXECUTABLE)
 
 # Make a symlink from /sbin/ueventd and /sbin/watchdogd to /init
diff --git a/system/core/init/builtins.c b/gb/12055-master/driveronly_mp_rom/system/core/init/builtins.c
index aaf85d9..8c4933b 100644
--- a/system/core/init/builtins.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/init/builtins.c
@@ -34,6 +34,7 @@
 #include <cutils/partition_utils.h>
 #include <sys/system_properties.h>
 #include <fs_mgr.h>
+#include <stdarg.h>
 
 #ifdef HAVE_SELINUX
 #include <selinux/selinux.h>
@@ -49,7 +50,9 @@
 #include "log.h"
 
 #include <private/android_filesystem_config.h>
-
+#ifdef INIT_ENG_BUILD
+#define printf(x...) NOTICE(x)
+#endif
 void add_environment(const char *name, const char *value);
 
 extern int init_module(void *, unsigned long, const char *);
@@ -77,62 +80,68 @@ static int write_file(const char *path, const char *value)
     }
 }
 
-static int _open(const char *path)
-{
-    int fd;
-
-    fd = open(path, O_RDONLY | O_NOFOLLOW);
-    if (fd < 0)
-        fd = open(path, O_WRONLY | O_NOFOLLOW);
-
-    return fd;
-}
 
 static int _chown(const char *path, unsigned int uid, unsigned int gid)
 {
-    int fd;
     int ret;
 
-    fd = _open(path);
-    if (fd < 0) {
+    struct stat p_statbuf;
+
+    ret = lstat(path, &p_statbuf);
+    if (ret < 0) {
         return -1;
     }
 
-    ret = fchown(fd, uid, gid);
-    if (ret < 0) {
-        int errno_copy = errno;
-        close(fd);
-        errno = errno_copy;
+    if (S_ISLNK(p_statbuf.st_mode) == 1) {
+        errno = EINVAL;
         return -1;
     }
 
-    close(fd);
+    ret = chown(path, uid, gid);
 
-    return 0;
+    return ret;
 }
 
 static int _chmod(const char *path, mode_t mode)
 {
-    int fd;
     int ret;
 
-    fd = _open(path);
-    if (fd < 0) {
+    struct stat p_statbuf;
+
+    ret = lstat(path, &p_statbuf);
+    if( ret < 0) {
         return -1;
     }
 
-    ret = fchmod(fd, mode);
-    if (ret < 0) {
-        int errno_copy = errno;
-        close(fd);
-        errno = errno_copy;
+    if (S_ISLNK(p_statbuf.st_mode) == 1) {
+        errno = EINVAL;
         return -1;
     }
 
-    close(fd);
+    ret = chmod(path, mode);
 
-    return 0;
+    return ret;
+}
+
+#ifdef HAVE_AEE_FEATURE
+#define AEE_KE_INSMOD_PATH "/proc/aed/generate-kernel-notify"
+
+static void raise_aed_ke(const char *fmt, ...)
+{
+    FILE *fp = fopen(AEE_KE_INSMOD_PATH, "w");
+    if (fp != NULL) {
+        char *msg = NULL;
+        va_list ap;
+        va_start(ap, fmt);
+        if (vasprintf(&msg, fmt, ap) != -1) {
+            fwrite(msg, strlen(msg) + 1, 1, fp);
+        }
+        fclose(fp);
+        va_end(ap);
+        free(msg);
+    }
 }
+#endif
 
 static int insmod(const char *filename, char *options)
 {
@@ -141,10 +150,31 @@ static int insmod(const char *filename, char *options)
     int ret;
 
     module = read_file(filename, &size);
-    if (!module)
+    if (!module) {
+#ifdef HAVE_AEE_FEATURE
+        raise_aed_ke("W:insmod:Module \"%s\" not found.\n", filename);
+#endif
         return -1;
+    }
 
     ret = init_module(module, size, options);
+#ifdef HAVE_AEE_FEATURE
+    if (ret < 0) {
+        const char *prop;
+
+        prop = property_get("vold.post_fs_data_done");
+        if (! prop) {
+            prop = "notset";
+        }       
+
+        if (EEXIST == errno && *prop == '0') {
+             printf("In encrypt phone, it will trigger_post_fs_data. Threefore skip insmod (File exists) error. \n");
+        }
+        else {
+             raise_aed_ke("W:insmod:Failed to init module \"%s\" (%s), Check kernel log for more info.\n", filename, strerror(errno));
+        }
+    }
+#endif
 
     free(module);
 
@@ -241,7 +271,117 @@ int do_domainname(int nargs, char **args)
 
 int do_exec(int nargs, char **args)
 {
-    return -1;
+    int i;
+    int status;
+    int child_return_val;
+    pid_t pid;
+    pid_t pid_super;
+    pid_t pid_manual;
+
+    for(i = 0; i < nargs; i++)
+    {
+        printf("argv[%d]= %s\n", i, args[i]);
+    }
+    pid = fork();
+    switch (pid){
+        case -1:
+            printf("fork system call failed\n");
+            break;
+        case 0:  /* child */
+            execl(args[1], args[1], args[2], args[3], args[4], NULL);
+            printf("cannot run %s\n", args[1]);
+            _exit(127);
+            break;
+        default: /* parent */
+            /* wait child process end(for e2fsck complete) */
+            while (pid != wait(&status));
+
+            if (WIFEXITED(status)){
+                child_return_val = WEXITSTATUS(status);
+                if (strncmp(args[1], "/sbin/e2fsck", 12)){
+                    if (child_return_val != 0){
+                        printf("%s run failed\n", args[1]);
+                    }
+                    //printf("child_return_val = %s\n", child_return_val);
+                } else {
+                    switch (child_return_val){
+                        case 127:
+                            printf("execl error\n");
+                            break;
+                        case 0:
+                        case 1:
+                            /* e2fsck run ok */
+                            printf("e2fsck run ok!\n");
+                            break;
+                        case 2:
+                            /* e2fsck run ok, but need reboot the system */
+                            printf("e2fsck need reboot!\n");
+                            system("reboot");
+                            break;
+                        case 4:
+                            printf("e2fsck: all say yes!\n");
+                            pid_manual = fork();
+                            switch (pid_manual){
+                                case -1:
+                                    printf("manual check:fork system call failed\n");
+                                    break;
+                                case 0: /* child */
+                                    execl(args[1], args[1], "-y", args[3], NULL);
+                                    printf("manual check:cannot run %s\n", args[1]);
+                                    _exit(127);
+                                    break;
+                                default: /* parent */
+                                    /* wait child process end(for e2fsck complete) */
+                                    while (pid_manual != wait(&status));
+
+                                    if (WIFEXITED(status)){
+                                        child_return_val = WEXITSTATUS(status);
+                                        if (child_return_val != 0 && child_return_val != 1){
+                                            printf("superblock check:canot correct the bad fs\n");
+                                        }
+                                    }
+                                    break;
+                            } 
+                            break;
+                        case 8:
+                        case 16:
+                        case 32:
+                        case 128:
+                            printf("begin superblock check:child_return_val = %d\n", child_return_val);
+                        default:
+                            /* e2fsck need furture work */
+                            pid_super = fork();
+                            switch (pid_super){
+                                case -1:
+                                    printf("superblock check:fork system call failed\n");
+                                    break;
+                                case 0:  /* child */
+                                    /* running /system/bin/e2fsck -p -b 16384 /dev/block/~ */
+                                    execl(args[1], args[1], args[2], "-b 32768", args[3], NULL);
+                                    printf("superblock check:cannot run %s\n", args[1]);
+                                    _exit(127);
+                                    break;
+                                default: /* parent */
+                                    /* wait child process end(for e2fsck complete) */
+                                    while (pid_super != wait(&status));
+
+                                    if (WIFEXITED(status)){
+                                        child_return_val = WEXITSTATUS(status);
+                                        if (child_return_val != 0 && child_return_val != 1){
+                                            printf("superblock check:canot correct the bad fs\n");
+                                        }
+                                    }
+                                    break;
+                            }
+                            break;
+                    }
+                }
+            }
+            break;
+    }
+
+    return 0;
+
 }
 
 int do_export(int nargs, char **args)
@@ -329,12 +469,44 @@ int do_mkdir(int nargs, char **args)
             if (ret == -1) {
                 return -errno;
             }
-        }
+    }
     }
 
     return 0;
 }
 
+int do_mknod(int nargs, char **args)
+{
+    dev_t dev;
+    int major;
+    int minor;
+    int mode;
+
+    /* mknod <path> <type> <major> <minor> */
+
+    if (nargs != 5) {
+        return -1;
+    }
+
+    major = strtoul(args[3], 0, 0);
+    minor = strtoul(args[4], 0, 0);
+    dev = (major << 8) | minor;
+
+    if (strcmp(args[2], "c") == 0) {
+        mode = S_IFCHR;
+    } else {
+        mode = S_IFBLK;
+    }
+
+    if (mknod(args[1], mode, dev)) {
+        ERROR("init: mknod failed");
+        return -1;
+    }
+
+    return 0;
+}
+
+
 static struct {
     const char *name;
     unsigned flag;
@@ -363,11 +535,13 @@ static struct {
 int do_mount(int nargs, char **args)
 {
     char tmp[64];
-    char *source, *target, *system;
+    char *source, *target, *type;
     char *options = NULL;
     unsigned flags = 0;
     int n, i;
     int wait = 0;
+    //add for power loss test
+    struct stat stbuf; 
 
     for (n = 4; n < nargs; n++) {
         for (i = 0; mount_flags[i].name; i++) {
@@ -386,7 +560,7 @@ int do_mount(int nargs, char **args)
         }
     }
 
-    system = args[1];
+    type = args[1];
     source = args[2];
     target = args[3];
 
@@ -400,11 +574,28 @@ int do_mount(int nargs, char **args)
 
         if (wait)
             wait_for_file(tmp, COMMAND_RETRY_TIMEOUT);
-        if (mount(tmp, target, system, flags, options) < 0) {
+        if (mount(tmp, target, type, flags, options) < 0) {
             return -1;
         }
 
         goto exit_success;
+#ifdef MTK_NAND_UBIFS_SUPPORT
+    } else if (!strncmp(source, "ubi@", 4)) {
+        n = ubi_attach_mtd(source + 4);
+        if (n < 0) {
+            return -1;
+        }
+
+        sprintf(tmp, "/dev/ubi%d_0", n);
+
+        if (wait)
+            wait_for_file(tmp, COMMAND_RETRY_TIMEOUT);
+        if (mount(tmp, target, type, flags, options) < 0) {
+            ubi_detach_dev(n);
+            return -1;
+        }
+        goto exit_success;
+#endif
     } else if (!strncmp(source, "loop@", 5)) {
         int mode, loop, fd;
         struct loop_info info;
@@ -428,7 +619,7 @@ int do_mount(int nargs, char **args)
                 if (ioctl(loop, LOOP_SET_FD, fd) >= 0) {
                     close(fd);
 
-                    if (mount(tmp, target, system, flags, options) < 0) {
+                    if (mount(tmp, target, type, flags, options) < 0) {
                         ioctl(loop, LOOP_CLR_FD, 0);
                         close(loop);
                         return -1;
@@ -446,17 +637,233 @@ int do_mount(int nargs, char **args)
         ERROR("out of loopback devices");
         return -1;
     } else {
+
+#ifdef MTK_EMMC_SUPPORT
+         struct phone_encrypt_state ps;  
+         if (!strcmp(target, DATA_MNT_POINT)) {
+             if (misc_get_phone_encrypt_state(&ps) < 0) {
+                 printf("Failed to get encrypted status in MISC\n");
+             }
+             else {
+                 printf("Success: get encrypted status: 0x%x in MISC\n", ps.state);
+             }  
+         }
+#endif
+
         if (wait)
             wait_for_file(source, COMMAND_RETRY_TIMEOUT);
-        if (mount(source, target, system, flags, options) < 0) {
-            return -1;
+        if (mount(source, target, type, flags, options) < 0) {
+
+		/*auto-format the partition when the partition is empty or mount fail*/
+  		if(strcmp(target,"/data")&& strcmp(target,"/cache")&& strcmp(target,"/system")&& strcmp(target,"/system/secro")){
+        				int ret,status;
+        				pid_t pid;
+        				printf("mount  %s  to %s fail, it may be a empty partition\n",source,target);
+        				pid = fork();
+        				if(pid<0){
+        						printf("create process fail\n");	
+        						return -1;
+        				}else if(pid ==0){
+        						printf("create process to generate image\n");
+        						execl("/system/bin/make_ext4fs","-w",source,NULL);
+        						printf("can not run /system/bin/make_ext4fs\n");
+        						return -1;	
+        				}else{
+        					 while (pid != waitpid(pid,&status,0));
+
+        						if(status!=0){
+        								printf("make_ext4fs failed on %s\n",target);
+        								return -1;
+        						}else{
+        								printf("make_ext4fs on %s sucess!!\n",target);	
+        						}
+        						if (mount(source, target, type, flags, options) < 0){
+							  	printf("re-mount %s fail\n",target);
+							  	return -1;	
+        				  		}
+        						
+        				}
+		}
+
+            if (!strcmp(target, DATA_MNT_POINT)) {
+                int fd;
+                if ((fd = open(source, O_RDONLY)) < 0) {
+                     printf("Mount /data fail because source(%s) doesn't exist.", source);
+                     return -1;
+                }
+            }
+
+            if (!strcmp(target, DATA_MNT_POINT) && !partition_wiped(source)) {
+                if (fs_mgr_do_tmpfs_mount(DATA_MNT_POINT)) {
+                    return -1;
+                }
+
+                /* Set the property that triggers the framework to do a minimal
+                           * startup and ask the user for a password
+                           */
+                property_set("ro.crypto.state", "encrypted");
+                property_set("vold.decrypt", "1");
+            } else {
+                return -1;
+            }
+        }
+#ifdef MTK_EMMC_SUPPORT
+        else {
+             if (!strcmp(target, DATA_MNT_POINT)) {
+                    if (ps.state == PHONE_ENCRYPTED) {
+                        ps.state = PHONE_UNCRYPTED;
+                        if (misc_set_phone_encrypt_state(&ps) < 0) {
+                            printf("Failed to set encrypted status to 0x%x in MISC\n", ps.state);
+                        }
+                        else {
+                            printf("Success: Set encrypted status to 0x%x in MISC\n", ps.state);
+                        }
+                    }
+             }
+        }
+#endif
+
+        if (!strcmp(target, DATA_MNT_POINT)) {
+            char fs_flags[32];
+
+            /* Save the original mount options */
+            property_set("ro.crypto.fs_type", type);
+            property_set("ro.crypto.fs_real_blkdev", source);
+            property_set("ro.crypto.fs_mnt_point", target);
+            if (options) {
+                property_set("ro.crypto.fs_options", options);
+            }
+            snprintf(fs_flags, sizeof(fs_flags), "0x%8.8x", flags);
+            property_set("ro.crypto.fs_flags", fs_flags);
         }
+        if (!strncmp(type, "ext4", 4)){
+            if (!strncmp(target, "/data", 5)){
+               printf("delete lost-found in data dir\n");
+               system("/system/bin/rm -r /data/lost+found/*");
+               
+               if (stat("/data/data", &stbuf) < 0){
+                   printf("stat syscall fail\n");
+               }
+               if (S_ISREG(stbuf.st_mode)){
+                   printf("delete /data/data file\n");
+                   system("/system/bin/rm -r /data/data");    
+               }
+
+               if (stat("/data/system", &stbuf) < 0){
+                   printf("stat syscall fail\n");
+               }
+               if (S_ISREG(stbuf.st_mode)){
+                   printf("delete /data/system file\n");
+                   system("/system/bin/rm -r /data/system");    
+               }
+
+               if (stat("/data/misc", &stbuf) < 0){
+                   printf("stat syscall fail\n");
+               }
+               if (S_ISREG(stbuf.st_mode)){
+                   printf("delete /data/misc file\n");
+                   system("/system/bin/rm -r /data/misc");    
+               }
+
+               if (stat("/data/local", &stbuf) < 0){
+                   printf("stat syscall fail\n");
+               }
+               if (S_ISREG(stbuf.st_mode)){
+                   printf("delete /data/local file\n");
+                   system("/system/bin/rm -r /data/local");    
+               }
+
+               if (stat("/data/app-private", &stbuf) < 0){
+                   printf("stat syscall fail\n");
+               }
+               if (S_ISREG(stbuf.st_mode)){
+                   printf("delete /data/app-private file\n");
+                   system("/system/bin/rm -r /data/app-private");    
+               }
+
+               if (stat("/data/dalvik-cache", &stbuf) < 0){
+                   printf("stat syscall fail\n");
+               }
+               if (S_ISREG(stbuf.st_mode)){
+                   printf("delete /data/dalvik-cache file\n");
+                   system("/system/bin/rm -r /data/dalvik-cache");    
+               }
+
+
+               if (stat("/data/property", &stbuf) < 0){
+                   printf("stat syscall fail\n");
+               }
+               if (S_ISREG(stbuf.st_mode)){
+                   printf("delete /data/property file\n");
+                   system("/system/bin/rm -r /data/property");    
+               } 
+
+               if (stat("/data/mvg_root", &stbuf) < 0){
+                   printf("stat syscall fail\n");
+               }
+               if (S_ISREG(stbuf.st_mode)){
+                   printf("delete /data/mvg_root file\n");
+                   system("/system/bin/rm -r /data/mvg_root");    
+               }
+
+               if (stat("/data/anr", &stbuf) < 0){
+                   printf("stat syscall fail\n");
+               }
+               if (S_ISREG(stbuf.st_mode)){
+                   printf("delete /data/anr file\n");
+                   system("/system/bin/rm -r /data/anr");    
+               }
+
+               if (stat("/data/app", &stbuf) < 0){
+                   printf("stat syscall fail\n");
+               }
+               if (S_ISREG(stbuf.st_mode)){
+                   printf("delete /data/app file\n");
+                   system("/system/bin/rm -r /data/app");    
+               }
+
+               if (stat("/data/nvram", &stbuf) < 0){
+                   printf("stat syscall fail\n");
+               }
+               if (S_ISREG(stbuf.st_mode)){
+                   printf("delete /data/nvram file\n");
+                   system("/system/bin/rm -r /data/nvram");    
+               }
+
+               if (stat("/data/secure", &stbuf) < 0){
+                   printf("stat syscall fail\n");
+               }
+               if (S_ISREG(stbuf.st_mode)){
+                   printf("delete /data/secure file\n");
+                   system("/system/bin/rm -r /data/secure");    
+               }
+            }
 
+            if (!strncmp(target, "/cache", 6)){
+               printf("delete lost-found in cache dir\n");
+               system("/system/bin/rm -r /cache/lost+found/*");
+            }
+        }        
     }
 
 exit_success:
-    return 0;
+    /* If not running encrypted, then set the property saying we are
+     * unencrypted, and also trigger the action for a nonencrypted system.
+     */
+    if (!strcmp(target, DATA_MNT_POINT)) {
+        const char *prop;
 
+        prop = property_get("ro.crypto.state");
+        if (! prop) {
+            prop = "notset";
+        }
+        if (strcmp(prop, "encrypted")) {
+            property_set("ro.crypto.state", "unencrypted");
+            action_for_each_trigger("nonencrypted", action_add_queue_tail);
+        }
+    }
+
+    return 0;
 }
 
 int do_mount_all(int nargs, char **args)
@@ -715,6 +1122,8 @@ out:
 }
 
 int do_chown(int nargs, char **args) {
+#if 0
+    //tempararily disable this code section
     /* GID is optional. */
     if (nargs == 3) {
         if (_chown(args[2], decode_uid(args[1]), -1) < 0)
@@ -726,6 +1135,45 @@ int do_chown(int nargs, char **args) {
         return -1;
     }
     return 0;
+#else
+    char tmp[64];
+    char *target;
+    int n;
+    switch (nargs){
+        case 3:
+            target = args[2];
+            break;
+        case 4:
+            target = args[3];
+            break;
+        default:
+            ERROR("invalid args num: %d, It should be 3 or 4\n", nargs);
+            return -1;
+    }
+
+    if (!strncmp(target, "mtd@", 4)) {
+        n = mtd_name_to_number(target + 4);
+            if (n < 0) {
+            return -1;
+        }
+        sprintf(tmp, "/dev/mtd/mtd%d", n);
+        target = tmp;
+
+    }
+
+    //ERROR("do_chown debug: target:%s\n",target);
+    /* GID is optional. */
+    if (nargs == 3) {
+    if (_chown(target, decode_uid(args[1]), -1) < 0)
+            return -errno;
+    } else if (nargs == 4) {
+        if (_chown(target, decode_uid(args[1]), decode_uid(args[2])))
+            return -errno;
+    } else {
+        return -1;
+    }
+    return 0;
+#endif
 }
 
 static mode_t get_mode(const char *s) {
@@ -742,11 +1190,37 @@ static mode_t get_mode(const char *s) {
 }
 
 int do_chmod(int nargs, char **args) {
+#if 0
+    //tempararily disable this code section
     mode_t mode = get_mode(args[1]);
     if (_chmod(args[2], mode) < 0) {
         return -errno;
     }
     return 0;
+#else
+    char tmp[64];
+    char *target;
+    int n;
+    target = args[2];
+
+    if (!strncmp(target, "mtd@", 4)) {
+        n = mtd_name_to_number(target + 4);
+            if (n < 0) {
+            return -1;
+        }
+        sprintf(tmp, "/dev/mtd/mtd%d", n);
+        target = tmp;
+
+    }
+
+    //ERROR("do_chmod debug: target:%s\n",target);
+
+    mode_t mode = get_mode(args[1]);
+    if (_chmod(target, mode) < 0) {
+        return -errno;
+    }
+    return 0;
+#endif
 }
 
 int do_restorecon(int nargs, char **args) {
@@ -755,7 +1229,7 @@ int do_restorecon(int nargs, char **args) {
     for (i = 1; i < nargs; i++) {
         if (restorecon(args[i]) < 0)
             return -errno;
-    }
+        }
     return 0;
 }
 
@@ -816,5 +1290,5 @@ int do_wait(int nargs, char **args)
     } else if (nargs == 3) {
         return wait_for_file(args[1], atoi(args[2]));
     } else
-        return -1;
+    return -1;
 }
diff --git a/system/core/init/init.c b/gb/12055-master/driveronly_mp_rom/system/core/init/init.c
index 1c80d9c..d8a8033 100755
--- a/system/core/init/init.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/init/init.c
@@ -31,7 +31,6 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/un.h>
-#include <sys/personality.h>
 
 #ifdef HAVE_SELINUX
 #include <selinux/selinux.h>
@@ -44,6 +43,7 @@
 #include <cutils/list.h>
 #include <cutils/sockets.h>
 #include <cutils/iosched_policy.h>
+#include <cutils/xlog.h>
 #include <private/android_filesystem_config.h>
 #include <termios.h>
 
@@ -60,7 +60,9 @@
 #include "util.h"
 #include "ueventd.h"
 #include "watchdogd.h"
-
+#ifdef INIT_ENG_BUILD
+#define printf(x...) NOTICE(x)
+#endif
 #ifdef HAVE_SELINUX
 struct selabel_handle *sehandle;
 struct selabel_handle *sehandle_prop;
@@ -80,6 +82,7 @@ static char qemu[32];
 
 #ifdef HAVE_SELINUX
 static int selinux_enabled = 1;
+static int selinux_enforcing = 0;
 #endif
 
 static struct action *cur_action = NULL;
@@ -109,9 +112,16 @@ int add_environment(const char *key, const char *val)
 
     for (n = 0; n < 31; n++) {
         if (!ENV[n]) {
+            char *entry;
+            INFO("add enviorment: [%s:%s]\n", key, val);
             size_t len = strlen(key) + strlen(val) + 2;
-            char *entry = malloc(len);
-            snprintf(entry, len, "%s=%s", key, val);
+            entry = malloc(len);
+            if(entry!=0){
+                snprintf(entry, len, "%s=%s", key, val);
+                INFO("[%s:%s]at entry:0x%x\n", key, val, (unsigned int)entry);
+            }else{
+                INFO("[%s:%s]at entry:0x%x\n", key, val, (unsigned int)entry);
+            }
             ENV[n] = entry;
             return 0;
         }
@@ -239,24 +249,12 @@ void service_start(struct service *svc, const char *dynamic_args)
     if (pid == 0) {
         struct socketinfo *si;
         struct svcenvinfo *ei;
-        char tmp[32];
+        char tmp[48];
         int fd, sz;
-
+#ifndef NO_INIT_PERMISSION_CHECK
         umask(077);
-#ifdef __arm__
-        /*
-         * b/7188322 - Temporarily revert to the compat memory layout
-         * to avoid breaking third party apps.
-         *
-         * THIS WILL GO AWAY IN A FUTURE ANDROID RELEASE.
-         *
-         * http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=7dbaa466
-         * changes the kernel mapping from bottom up to top-down.
-         * This breaks some programs which improperly embed
-         * an out of date copy of Android's linker.
-         */
-        int current = personality(0xffffFFFF);
-        personality(current | ADDR_COMPAT_LAYOUT);
+#else
+        umask(0);
 #endif
         if (properties_inited()) {
             get_property_workspace(&fd, &sz);
@@ -304,10 +302,10 @@ void service_start(struct service *svc, const char *dynamic_args)
 
 #if 0
         for (n = 0; svc->args[n]; n++) {
-            INFO("args[%d] = '%s'\n", n, svc->args[n]);
+            ERROR("args[%d] = '%s'\n", n, svc->args[n]);
         }
         for (n = 0; ENV[n]; n++) {
-            INFO("env[%d] = '%s'\n", n, ENV[n]);
+            ERROR("env[%d] = '%s'\n", n, ENV[n]);
         }
 #endif
 
@@ -344,7 +342,7 @@ void service_start(struct service *svc, const char *dynamic_args)
 
         if (!dynamic_args) {
             if (execve(svc->args[0], (char**) svc->args, (char**) ENV) < 0) {
-                ERROR("cannot execve('%s'): %s\n", svc->args[0], strerror(errno));
+                ERROR("STEN:cannot execve('%s'): %s\n", svc->args[0], strerror(errno));
             }
         } else {
             char *arg_ptrs[INIT_PARSER_MAXARGS+1];
@@ -491,6 +489,7 @@ static void msg_stop(const char *name)
     }
 }
 
+extern void property_show(void);
 void handle_control_message(const char *msg, const char *arg)
 {
     if (!strcmp(msg,"start")) {
@@ -500,6 +499,8 @@ void handle_control_message(const char *msg, const char *arg)
     } else if (!strcmp(msg,"restart")) {
         msg_stop(arg);
         msg_start(arg);
+    } else if (!strcmp(msg,"show")) {
+        property_show();
     } else {
         ERROR("unknown control msg '%s'\n", msg);
     }
@@ -541,7 +542,11 @@ void execute_one_command(void)
         cur_command = NULL;
         if (!cur_action)
             return;
+#ifdef INIT_ENG_BUILD
+        ERROR("processing action %p (%s)\n", cur_action, cur_action->name);
+#else
         INFO("processing action %p (%s)\n", cur_action, cur_action->name);
+#endif
         cur_command = get_first_command(cur_action);
     } else {
         cur_command = get_next_command(cur_action, cur_command);
@@ -551,7 +556,18 @@ void execute_one_command(void)
         return;
 
     ret = cur_command->func(cur_command->nargs, cur_command->args);
+#ifdef INIT_ENG_BUILD
+    if(cur_command->nargs > 3)
+    ERROR("command '%s %s %s %s' r=%d\n", cur_command->args[0], cur_command->args[1], cur_command->args[2], cur_command->args[3], ret);
+    else if(cur_command->nargs > 2)
+    ERROR("command '%s %s %s' r=%d\n", cur_command->args[0], cur_command->args[1], cur_command->args[2], ret);
+    else if(cur_command->nargs > 1)
+    ERROR("command '%s %s' r=%d\n", cur_command->args[0], cur_command->args[1], ret);
+    else
+    ERROR("command '%s' r=%d\n", cur_command->args[0], ret);
+#else
     INFO("command '%s' r=%d\n", cur_command->args[0], ret);
+#endif
 }
 
 static int wait_for_coldboot_done_action(int nargs, char **args)
@@ -611,6 +627,35 @@ static int console_init_action(int nargs, char **args)
     return 0;
 }
 
+static int read_serialno()
+{
+    int fd;
+    char serialno[32];
+    size_t s;
+
+    fd = open("/sys/sys_info/serial_number", O_RDWR);
+    if (fd < 0) {
+        xlog_printf(ANDROID_LOG_WARN, LOG_TAG, "fail to open: %s\n", "/sys/sys_info/serial_number");
+        return 0;
+    }
+    s = read(fd, serialno, sizeof(char)*32);
+
+    serialno[s-1] = '\0';
+
+    close(fd);
+
+    if (s <= 0) {
+	    xlog_printf(ANDROID_LOG_WARN, LOG_TAG, "could not read serial number sys file\n");
+	    return 0;
+	}
+
+    xlog_printf(ANDROID_LOG_WARN, LOG_TAG, "serial number=%s\n",serialno);
+
+    property_set("ro.boot.serialno", serialno);
+
+    return 1;
+}
+
 static void import_kernel_nv(char *name, int for_emulator)
 {
     char *value = strchr(name, '=');
@@ -660,7 +705,7 @@ static void export_kernel_boot_props(void)
         const char *dest_prop;
         const char *def_val;
     } prop_map[] = {
-        { "ro.boot.serialno", "ro.serialno", "", },
+        { "ro.boot.serialno", "ro.serialno", "0123456789ABCDEF", },
         { "ro.boot.mode", "ro.bootmode", "unknown", },
         { "ro.boot.baseband", "ro.baseband", "unknown", },
         { "ro.boot.bootloader", "ro.bootloader", "unknown", },
@@ -710,6 +755,8 @@ static void process_kernel_cmdline(void)
     if (qemu[0])
         import_kernel_cmdline(1, import_kernel_nv);
 
+    read_serialno();
+
     /* now propogate the info given on command line to internal variables
      * used by init as well as the current required properties
      */
@@ -747,7 +794,16 @@ static int check_startup_action(int nargs, char **args)
 
     return 0;
 }
-
+static int queue_early_property_triggers_action()
+{
+    queue_early_property_triggers();
+    return 0;
+}
+static int queue_fs_property_triggers_action()
+{
+    queue_fs_property_triggers();
+    return 0;
+}
 static int queue_property_triggers_action(int nargs, char **args)
 {
     queue_all_property_triggers();
@@ -772,6 +828,129 @@ static int bootchart_init_action(int nargs, char **args)
 }
 #endif
 
+#ifdef USE_BUILT_IN_FACTORY
+static int is_factory_boot(void)
+{
+    int fd;
+    size_t s;
+    char boot_mode;
+
+    fd = open("/sys/class/BOOT/BOOT/boot/boot_mode", O_RDWR);
+    if (fd < 0) {
+        printf("fail to open: %s\n", "/sys/class/BOOT/BOOT/boot/boot_mode");
+        return 0;
+    }
+    s = read(fd, (void *)&boot_mode, sizeof(boot_mode));
+
+    close(fd);
+
+    if(s <= 0){
+	ERROR("could not read boot mode sys file\n");
+    return 0;
+    }
+    // Factory Mode, '4'
+    // ATE Factory Mode, '6'
+    if ((boot_mode != '4') && (boot_mode != '6')){
+	ERROR("Unsupported factory mode\n");
+        return 0;
+    }
+
+    printf("Factory Mode Booting.....\n");
+
+    return 1;
+}
+#endif
+#if defined (MTK_KERNEL_POWER_OFF_CHARGING_SUPPORT)
+static int is_kernel_power_off_charging_boot(void)
+{
+    int fd;
+    size_t s;
+    char boot_mode;
+    fd = open("/sys/class/BOOT/BOOT/boot/boot_mode", O_RDWR);
+    if (fd < 0) {
+        printf("fail to open: %s\n", "/sys/class/BOOT/BOOT/boot/boot_mode");
+        return 0;
+    }
+    s = read(fd, (void *)&boot_mode, sizeof(boot_mode));
+    close(fd);
+    if(s <= 0){
+        ERROR("could not read boot mode sys file\n");
+        return 0;
+    }
+    //KERNEL POWER OFF CHARGING MODE '8' 
+	//LOW POWER OFF CHARGING MODE '9'
+    if ((boot_mode != '8') && (boot_mode != '9')){
+	ERROR("Unsupported Kernel Power Off Charging mode\n");
+        return 0;
+    }
+    printf("Kernel Power Off Charging Mode Booting.....\n");
+    return 1;
+}
+#endif
+static int is_meta_boot(void)
+{
+  int fd;
+  size_t s;
+  char boot_mode;
+
+  fd = open("/sys/class/BOOT/BOOT/boot/boot_mode", O_RDWR);
+  if (fd < 0)
+  {
+    printf("fail to open: %s\n", "/sys/class/BOOT/BOOT/boot/boot_mode");
+    return 0;
+  }
+
+  s = read(fd, (void *)&boot_mode, sizeof(boot_mode));
+  close(fd);
+
+  if(s <= 0)
+  {
+	  ERROR("could not read boot mode sys file\n");
+    return 0;
+  }
+
+  if ((boot_mode != '1'))
+  {
+	  printf("Current boot_mode is Not meta mode\n");
+    return 0;
+  }
+
+  printf("META Mode Booting.....\n");
+  return 1;
+}
+
+static int is_advanced_meta_boot(void)
+{
+  int fd;
+  size_t s;
+  char boot_mode;
+
+  fd = open("/sys/class/BOOT/BOOT/boot/boot_mode", O_RDWR);
+  if (fd < 0)
+  {
+    printf("fail to open: %s\n", "/sys/class/BOOT/BOOT/boot/boot_mode");
+    return 0;
+  }
+
+  s = read(fd, (void *)&boot_mode, sizeof(boot_mode));
+  close(fd);
+
+  if(s <= 0)
+  {
+	  ERROR("could not read boot mode sys file\n");
+    return 0;
+  }
+
+  if ((boot_mode != '5'))
+  {
+	  printf("Current boot_mode is Not advanced meta mode\n");
+    return 0;
+  }
+
+  printf("ADVANCED META Mode Booting.....\n");
+  return 1;
+}
+
 #ifdef HAVE_SELINUX
 static const struct selinux_opt seopts_prop[] = {
         { SELABEL_OPT_PATH, "/data/system/property_contexts" },
@@ -832,6 +1011,169 @@ int audit_callback(void *data, security_class_t cls, char *buf, size_t len)
 }
 
 #endif
+#ifdef MTK_SHARED_SDCARD
+static int is_support_sdcard_share_boot(void)
+{
+  int fd;
+  size_t s;
+  char boot_mode;
+/***************************
+
+    NORMAL_BOOT = 0,
+    META_BOOT = 1,
+    RECOVERY_BOOT = 2,
+    SW_REBOOT = 3,
+    FACTORY_BOOT = 4,
+    ADVMETA_BOOT = 5,
+    ATE_FACTORY_BOOT = 6,
+    ALARM_BOOT = 7,
+    UNKNOWN_BOOT
+****************************/
+
+  fd = open("/sys/class/BOOT/BOOT/boot/boot_mode", O_RDWR);
+  if (fd < 0)
+  {
+    printf("fail to open: %s\n", "/sys/class/BOOT/BOOT/boot/boot_mode");
+    return 0;
+  }
+
+  s = read(fd, (void *)&boot_mode, sizeof(boot_mode));
+  close(fd);
+
+  if(s <= 0)
+  {
+	  ERROR("could not read boot mode sys file\n");
+    return 0;
+  }
+
+  if ((boot_mode == '2') || (boot_mode == '8'))
+  {
+	  printf("Current boot_mode is Not Support sdcard share\n");
+    return 0;
+  }
+
+  printf("The Booting is support sdcard shared, sdcard daemon will start.....\n");
+  return 1;
+}
+#endif
+static int is_support_protected_data_boot(void)
+{
+  int fd;
+  size_t s;
+  char boot_mode;
+/***************************
+
+    NORMAL_BOOT = 0,
+    META_BOOT = 1,
+    RECOVERY_BOOT = 2,    
+    SW_REBOOT = 3,
+    FACTORY_BOOT = 4,
+    ADVMETA_BOOT = 5,
+    ATE_FACTORY_BOOT = 6,
+    ALARM_BOOT = 7,
+    UNKNOWN_BOOT
+****************************/
+  
+  fd = open("/sys/class/BOOT/BOOT/boot/boot_mode", O_RDWR);
+  if (fd < 0) 
+  {
+    printf("fail to open: %s\n", "/sys/class/BOOT/BOOT/boot/boot_mode");
+    return 0;
+  }
+  
+  s = read(fd, (void *)&boot_mode, sizeof(boot_mode));
+  close(fd);
+  
+  if(s <= 0)
+  {
+	  ERROR("could not read boot mode sys file\n");
+    return 0;
+  }
+  
+  if ((boot_mode == '2') || (boot_mode == '8'))
+  {
+	  printf("Current boot_mode is Not Support protected data\n");
+    return 0;
+  }
+
+  printf("The Booting is support protected data......\n");
+  return 1;  
+}
+static int get_boot_mode(void)
+{
+  int fd;
+  size_t s;
+  char boot_mode;
+
+  fd = open("/sys/class/BOOT/BOOT/boot/boot_mode", O_RDWR);
+  if (fd < 0)
+  {
+    ERROR("fail to open: %s\n", "/sys/class/BOOT/BOOT/boot/boot_mode");
+    return 0;
+  }
+
+  s = read(fd, (void *)&boot_mode, sizeof(boot_mode));
+  close(fd);
+
+  if(s <= 0)
+  {
+	ERROR("could not read boot mode sys file\n");
+    return 0;
+  }
+
+  return atoi(&boot_mode);
+}
+
+static int get_meta_com_id(void)
+{
+  int fd;
+  size_t s;
+  char com_id;
+
+  fd = open("/sys/bus/platform/drivers/meta_com_id_info/meta_com_id_info", O_RDWR);
+  if (fd < 0) {
+      ERROR("fail to open: %s\n", "/sys/bus/platform/drivers/meta_com_id_info/meta_com_id_info");
+      return 0;
+  }
+
+  s = read(fd, (void *)&com_id, sizeof(com_id));
+  close(fd);
+
+  if (s <= 0) {
+      ERROR("could not read com id sys file\n");
+      return 0;
+  }
+
+  return atoi(&com_id);
+}
+
+static int queue_com_triggers_action()
+{
+    int boot_mode;
+    int meta_com_id;
+
+    boot_mode = get_boot_mode();
+    meta_com_id = get_meta_com_id();
+
+    /* If enter META mode and met_com_id == 1, enable single com mode
+     * If enter ATE FACTORY mode, enable single com mode
+     * Else andble compostie USB mode
+     * Please refernce meta_inti.rc and init.factory.rc
+     */
+     #ifndef VENDOR_EDIT
+    //if ((boot_mode == 1 && meta_com_id == 1)
+    //    || (boot_mode == 6)) {
+    if(meta_com_id && (boot_mode == 1 || boot_mode == 6 || boot_mode == 4))
+    {
+        property_set("sys.usb.com_config", "1");
+    } else {
+        property_set("sys.usb.com_config", "0");
+    }
+	#else
+	property_set("sys.usb.com_config", "1");
+	#endif
+    return 0;
+}
 
 int main(int argc, char **argv)
 {
@@ -845,6 +1187,7 @@ int main(int argc, char **argv)
     int keychord_fd_init = 0;
     bool is_charger = false;
 
+    klog_set_level(LOG_DEFAULT_LEVEL);
     if (!strcmp(basename(argv[0]), "ueventd"))
         return ueventd_main(argc, argv);
 
@@ -869,6 +1212,9 @@ int main(int argc, char **argv)
     mount("proc", "/proc", "proc", 0, NULL);
     mount("sysfs", "/sys", "sysfs", 0, NULL);
 
+#ifdef INIT_ENG_BUILD
+    mount("debugfs", "/sys/kernel/debug", "debugfs", 0, NULL);
+#endif
         /* indicate that booting is in progress to background fw loaders, etc */
     close(open("/dev/.booting", O_WRONLY | O_CREAT, 0000));
 
@@ -878,7 +1224,7 @@ int main(int argc, char **argv)
          * Now that tmpfs is mounted on /dev, we can actually
          * talk to the outside world.
          */
-    open_devnull_stdio();
+    //open_devnull_stdio();
     klog_init();
     property_init();
 
@@ -919,8 +1265,123 @@ int main(int argc, char **argv)
     if (!is_charger)
         property_load_boot_defaults();
 
+#ifdef HAVE_AEE_FEATURE
+    INFO("reading AEE config file\n");
+#ifndef PARTIAL_BUILD
+	init_parse_config_file("/init.aee.mtk.rc");
+#else
+	init_parse_config_file("/init.aee.customer.rc");
+#endif // PARTIAL_BUILD
+
+#endif // HAVE_AEE_FEATURE
     INFO("reading config file\n");
-    init_parse_config_file("/init.rc");
+
+#ifdef USE_BUILT_IN_FACTORY
+    ERROR("USE_BUILT_IN_FACTORY");
+    if (is_factory_boot())
+    {
+        ERROR("This is factory boot");
+        property_set("sys.mtk.no.factoryimage","1");
+        init_parse_config_file("/factory_init.rc");
+            INFO("reading project config file\n");
+        init_parse_config_file("/factory_init.project.rc");
+    }
+    else
+    {
+        if(is_meta_boot())
+        {
+            ERROR("Parsing meta_init.rc ...\n");
+            init_parse_config_file("/meta_init.rc");
+            INFO("reading project config file\n");
+            init_parse_config_file("/meta_init.project.rc");
+            init_parse_config_file("/meta_init.modem.rc");
+        }
+        else if(is_advanced_meta_boot())
+        {
+            ERROR("Parsing advanced_meta_init.rc ...\n");
+            init_parse_config_file("/advanced_meta_init.rc");
+            INFO("reading project config file\n");
+            init_parse_config_file("/advanced_meta_init.project.rc");
+        }
+        #if defined (MTK_KERNEL_POWER_OFF_CHARGING_SUPPORT)
+	else if (is_kernel_power_off_charging_boot())
+    {
+        ERROR("Parsing init.charging.rc ...\n");
+        if (init_parse_config_file("/init.charging.rc") < 0)
+        {
+            init_parse_config_file("/init.rc");
+            INFO("reading project config file\n");
+            init_parse_config_file("/init.project.rc");
+            init_parse_config_file("/init.modem.rc");
+	    }
+	}
+	#endif
+        else
+        {
+            printf("Parsing init.rc ...\n");
+            init_parse_config_file("/init.rc");
+            INFO("reading project config file\n");
+            init_parse_config_file("/init.project.rc");
+            init_parse_config_file("/init.modem.rc");
+        }
+    }
+#else
+    if(is_meta_boot())
+    {
+        ERROR("Parsing meta_init.rc ...\n");
+        init_parse_config_file("/meta_init.rc");
+        INFO("reading project config file\n");
+        init_parse_config_file("/meta_init.project.rc");
+        init_parse_config_file("/meta_init.modem.rc");
+    }
+    else if(is_advanced_meta_boot())
+    {
+        ERROR("Parsing advanced_meta_init.rc ...\n");
+        init_parse_config_file("/advanced_meta_init.rc");
+        INFO("reading project config file\n");
+        init_parse_config_file("/advanced_meta_init.project.rc");
+    }
+    else
+    {
+        printf("Parsing init.rc ...\n");
+        init_parse_config_file("/init.rc");
+        INFO("reading project config file\n");
+        init_parse_config_file("/init.project.rc");
+        init_parse_config_file("/init.modem.rc");
+    }
+#endif
+#ifdef MTK_SHARED_SDCARD
+    if(is_support_sdcard_share_boot())
+    {
+#ifdef MTK_2SDCARD_SWAP
+        printf("Parsing init.ssd_sdswap.rc ...\n");
+        init_parse_config_file("/init.ssd_nomuser.rc");
+#else
+        printf("Parsing init.ssd.rc ...\n");
+        init_parse_config_file("/init.ssd.rc");
+#endif
+    }
+    else 
+    {
+        printf("Parsing init.no_ssd.rc ...\n");
+        init_parse_config_file("/init.no_ssd.rc");
+    }
+#else 
+    printf("Parsing init.no_ssd.rc ...\n");
+    init_parse_config_file("/init.no_ssd.rc");
+#endif
+
+#ifndef INIT_ENG_BUILD
+    property_set("ro.mtprof.disable", "1");
+#endif
+
+    if(is_support_protected_data_boot())
+    {       	    
+	printf("Parsing init.protect.rc ...\n");  
+        init_parse_config_file("/init.protect.rc");
+    }
+    snprintf(tmp, sizeof(tmp), "/init.%s.rc", hardware);
+    init_parse_config_file(tmp);
 
     action_for_each_trigger("early-init", action_add_queue_tail);
 
@@ -933,6 +1394,7 @@ int main(int argc, char **argv)
 
     /* skip mounting filesystems in charger mode */
     if (!is_charger) {
+        queue_builtin_action(queue_fs_property_triggers_action, "queue_fs_propety_triggers");
         action_for_each_trigger("early-fs", action_add_queue_tail);
         action_for_each_trigger("fs", action_add_queue_tail);
         action_for_each_trigger("post-fs", action_add_queue_tail);
@@ -943,9 +1405,16 @@ int main(int argc, char **argv)
     queue_builtin_action(signal_init_action, "signal_init");
     queue_builtin_action(check_startup_action, "check_startup");
 
+    queue_builtin_action(queue_early_property_triggers_action, "queue_early_propety_triggers");
     if (is_charger) {
         action_for_each_trigger("charger", action_add_queue_tail);
-    } else {
+    }
+#if defined (MTK_KERNEL_POWER_OFF_CHARGING_SUPPORT)
+    else if (is_kernel_power_off_charging_boot()){
+	action_for_each_trigger("ipo", action_add_queue_tail);
+    } 
+#endif
+    else {
         action_for_each_trigger("early-boot", action_add_queue_tail);
         action_for_each_trigger("boot", action_add_queue_tail);
     }
@@ -953,6 +1422,17 @@ int main(int argc, char **argv)
         /* run all property triggers based on current state of the properties */
     queue_builtin_action(queue_property_triggers_action, "queue_property_triggers");
 
+    /* change USB function by meta_com_id */
+#ifdef USE_BUILT_IN_FACTORY
+    if (is_meta_boot() || is_factory_boot()) {
+        queue_builtin_action(queue_com_triggers_action, "queue_com_triggers");
+    }
+#else
+    if (is_meta_boot()) {
+        queue_builtin_action(queue_com_triggers_action, "queue_com_triggers");
+    }
+#endif
+
 
 #if BOOTCHART
     queue_builtin_action(bootchart_init_action, "bootchart_init");
diff --git a/system/core/init/init_parser.c b/gb/12055-master/driveronly_mp_rom/system/core/init/init_parser.c
index 5393e52..2c932bd 100644
--- a/system/core/init/init_parser.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/init/init_parser.c
@@ -35,7 +35,9 @@
 
 #define _REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H_
 #include <sys/_system_properties.h>
-
+#ifdef INIT_ENG_BUILD
+#define printf(x...) NOTICE(x)
+#endif
 static list_declare(service_list);
 static list_declare(action_list);
 static list_declare(action_queue);
@@ -124,6 +126,7 @@ int lookup_keyword(const char *s)
         if (!strcmp(s, "kdir")) return K_mkdir;
         if (!strcmp(s, "ount_all")) return K_mount_all;
         if (!strcmp(s, "ount")) return K_mount;
+        if (!strcmp(s, "knod")) return K_mknod;
         break;
     case 'o':
         if (!strcmp(s, "n")) return K_on;
@@ -529,7 +532,68 @@ void queue_property_triggers(const char *name, const char *value)
         }
     }
 }
+void queue_fs_property_triggers()
+{
+    struct listnode *node;
+    struct action *act;
+    list_for_each(node, &action_list) {
+        act = node_to_item(node, struct action, alist);
+        if (!strncmp(act->name, "fs_property:", strlen("fs_property:"))) {
+            /* parse property name and value
+               syntax is property:<name>=<value> */
+            const char* name = act->name + strlen("fs_property:");
+            const char* equals = strchr(name, '=');
+            if (equals) {
+                char prop_name[PROP_NAME_MAX + 1];
+                const char* value;
+                int length = equals - name;
+                if (length > PROP_NAME_MAX) {
+                    ERROR("property name too long in trigger %s", act->name);
+                } else {
+                    memcpy(prop_name, name, length);
+                    prop_name[length] = 0;
+
+                    /* does the property exist, and match the trigger value? */
+                    value = property_get(prop_name);
+                    if (value && !strcmp(equals + 1, value)) {
+                        action_add_queue_head(act);
+                    }
+                }
+            }
+        }
+    }
+}
+void queue_early_property_triggers()
+{
+    struct listnode *node;
+    struct action *act;
+    list_for_each(node, &action_list) {
+        act = node_to_item(node, struct action, alist);
+        if (!strncmp(act->name, "early_property:", strlen("early_property:"))) {
+            /* parse property name and value
+               syntax is property:<name>=<value> */
+            const char* name = act->name + strlen("early_property:");
+            const char* equals = strchr(name, '=');
+            if (equals) {
+                char prop_name[PROP_NAME_MAX + 1];
+                const char* value;
+                int length = equals - name;
+                if (length > PROP_NAME_MAX) {
+                    ERROR("property name too long in trigger %s", act->name);
+                } else {
+                    memcpy(prop_name, name, length);
+                    prop_name[length] = 0;
 
+                    /* does the property exist, and match the trigger value? */
+                    value = property_get(prop_name);
+                    if (value && !strcmp(equals + 1, value)) {
+                        action_add_queue_head(act);
+                    }
+                }
+            }
+        }
+    }
+}
 void queue_all_property_triggers()
 {
     struct listnode *node;
@@ -583,9 +647,22 @@ void queue_builtin_action(int (*func)(int nargs, char **args), char *name)
 
 void action_add_queue_tail(struct action *act)
 {
-    list_add_tail(&action_queue, &act->qlist);
+    if ((act->qlist.next == NULL) && (act->qlist.prev == NULL)) {
+        list_add_tail(&action_queue, &act->qlist);
+    }
+    else {
+        ERROR("action requeue to tail before execute act %p\n", act);
+    }
+}
+void action_add_queue_head(struct action *act)
+{
+    if ((act->qlist.next == NULL) && (act->qlist.prev == NULL)) {
+        list_add_head(&action_queue, &act->qlist);
+    }
+    else {
+        ERROR("action requeue to head before execute act %p\n", act);
+    }
 }
-
 struct action *action_remove_queue_head(void)
 {
     if (list_empty(&action_queue)) {
@@ -594,6 +671,7 @@ struct action *action_remove_queue_head(void)
         struct listnode *node = list_head(&action_queue);
         struct action *act = node_to_item(node, struct action, qlist);
         list_remove(node);
+        node->next = node->prev = NULL;
         return act;
     }
 }
diff --git a/system/core/init/init_parser.h b/gb/12055-master/driveronly_mp_rom/system/core/init/init_parser.h
index b078cad..f5c6450 100644
--- a/system/core/init/init_parser.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/init/init_parser.h
@@ -23,11 +23,14 @@ struct action;
 
 struct action *action_remove_queue_head(void);
 void action_add_queue_tail(struct action *act);
+void action_add_queue_head(struct action *act);
 void action_for_each_trigger(const char *trigger,
                              void (*func)(struct action *act));
 int action_queue_empty(void);
 void queue_property_triggers(const char *name, const char *value);
 void queue_all_property_triggers();
+void queue_early_property_triggers();
+void queue_fs_property_triggers();
 void queue_builtin_action(int (*func)(int nargs, char **args), char *name);
 
 int init_parse_config_file(const char *fn);
diff --git a/system/core/init/keywords.h b/gb/12055-master/driveronly_mp_rom/system/core/init/keywords.h
index 97d4950..b27bc74 100644
--- a/system/core/init/keywords.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/init/keywords.h
@@ -36,6 +36,7 @@ int do_chmod(int nargs, char **args);
 int do_loglevel(int nargs, char **args);
 int do_load_persist_props(int nargs, char **args);
 int do_wait(int nargs, char **args);
+int do_mknod(int nargs, char **args);
 #define __MAKE_KEYWORD_ENUM__
 #define KEYWORD(symbol, flags, nargs, func) K_##symbol,
 enum {
@@ -92,6 +93,7 @@ enum {
     KEYWORD(chown,       COMMAND, 2, do_chown)
     KEYWORD(chmod,       COMMAND, 2, do_chmod)
     KEYWORD(loglevel,    COMMAND, 1, do_loglevel)
+    KEYWORD(mknod,       COMMAND, 4, do_mknod)
     KEYWORD(load_persist_props,    COMMAND, 0, do_load_persist_props)
     KEYWORD(ioprio,      OPTION,  0, 0)
 #ifdef __MAKE_KEYWORD_ENUM__
diff --git a/system/core/init/log.h b/gb/12055-master/driveronly_mp_rom/system/core/init/log.h
index 4aac3df..395ee62 100644
--- a/system/core/init/log.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/init/log.h
@@ -23,6 +23,7 @@
 #define NOTICE(x...)  KLOG_NOTICE("init", x)
 #define INFO(x...)    KLOG_INFO("init", x)
 
+#define LOG_DEFAULT_LEVEL  6  /* messages <= this level are logged */
 #define LOG_UEVENTS        0  /* log uevent messages if 1. verbose */
 
 #endif
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/init/property_patch.c b/gb/12055-master/driveronly_mp_rom/system/core/init/property_patch.c
new file mode 100644
index 0000000..085d783
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/init/property_patch.c
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <linux/fb.h>
+
+#include "property_service.h"
+#include "log.h"
+
+
+int patch_lcd_density(void)
+{
+    const char FB_DEV[] = "/dev/graphics/fb0";
+    const char LCD_DENSITY_PROP[] = "ro.sf.lcd_density";
+    char value[10];
+    
+    struct fb_var_screeninfo vinfo;
+    unsigned int pixels;
+    unsigned int default_density = 160;
+    int fd = -1;
+    int ret = 0;
+
+    /* check if lcd_density has been defined */
+    if (property_get(LCD_DENSITY_PROP)) goto done;
+
+    if ((fd = open(FB_DEV, O_RDONLY)) < 0) {
+        ERROR("[ERROR] failed to open %s", FB_DEV);
+        ret = -1;
+        goto done;
+    }
+
+    if ((ret = ioctl(fd, FBIOGET_VSCREENINFO, &vinfo)) < 0) {
+        ERROR("[ERROR] failed to get fb_var_screeninfo");
+        goto done;
+    }
+
+    pixels = vinfo.xres * vinfo.yres;
+    if (pixels <= 240 * 432) default_density = 120;         // <= WQVGA432
+    else if ((pixels >= 480 * 800) && (pixels <=1024 * 600)) default_density = 240;    // >= WVGA854
+	else if (pixels > 1024 * 600) default_density = 320;
+
+    
+    sprintf(value, "%d", default_density);
+    if ((ret = property_set(LCD_DENSITY_PROP, value)) < 0) {
+        ERROR("[ERROR] failed to set property %s = %s", LCD_DENSITY_PROP, value);
+        goto done;
+    }
+
+done:
+    close(fd);
+    return ret;
+}
+
+
+int patch_properties(void)
+{
+    int ret = 0;
+
+    if ((ret = patch_lcd_density()) < 0) {
+        ERROR("[ERROR] patch lcd_density property failed");
+        return ret;
+    }
+
+    return ret;
+}
+
diff --git a/system/core/init/property_service.c b/gb/12055-master/driveronly_mp_rom/system/core/init/property_service.c
old mode 100755
new mode 100644
index f58e07d..08f8258
--- a/system/core/init/property_service.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/init/property_service.c
@@ -40,11 +40,6 @@
 #include <sys/atomics.h>
 #include <private/android_filesystem_config.h>
 
-#ifdef HAVE_SELINUX
-#include <selinux/selinux.h>
-#include <selinux/label.h>
-#endif
-
 #include "property_service.h"
 #include "init.h"
 #include "util.h"
@@ -70,6 +65,8 @@ struct {
     { "net.lte",          AID_RADIO,    0 },
     { "net.cdma",         AID_RADIO,    0 },
     { "ril.",             AID_RADIO,    0 },
+    { "ril.cfu.querytype", AID_APP,   0 },
+    { "mux.",             AID_RADIO,    0 },
     { "gsm.",             AID_RADIO,    0 },
     { "persist.radio",    AID_RADIO,    0 },
     { "net.dns",          AID_RADIO,    0 },
@@ -81,8 +78,8 @@ struct {
     { "sys.",             AID_SYSTEM,   0 },
     { "service.",         AID_SYSTEM,   0 },
     { "wlan.",            AID_SYSTEM,   0 },
-    { "bluetooth.",       AID_BLUETOOTH,   0 },
     { "dhcp.",            AID_SYSTEM,   0 },
+    { "bwc.mm.",          AID_SYSTEM,   0 },
     { "dhcp.",            AID_DHCP,     0 },
     { "debug.",           AID_SYSTEM,   0 },
     { "debug.",           AID_SHELL,    0 },
@@ -92,8 +89,26 @@ struct {
     { "persist.sys.",     AID_SYSTEM,   0 },
     { "persist.service.", AID_SYSTEM,   0 },
     { "persist.security.", AID_SYSTEM,   0 },
-    { "persist.service.bdroid.", AID_BLUETOOTH,   0 },
-    { "selinux."         , AID_SYSTEM,   0 },
+    { "gps.",             AID_GPS,     AID_SYSTEM },
+    { "persist.af.",      AID_MEDIA,   0 },
+    { "af.",              AID_MEDIA,   0 },
+    { "a2dp.",            AID_MEDIA,   0 },
+    { "streamin.",        AID_MEDIA,   0 },
+    { "streamout.",       AID_MEDIA,   0 },
+    { "bwc.mm.",          AID_MEDIA,   0 },
+    { "mediatek.",        AID_RADIO,   0 },
+//#ifdef VENDOR_EDIT 
+//#LuoLong@BootAnim, 2013/03/28, added for Boot Animation.
+    { "bootanim.",        AID_GRAPHICS,    0 },
+//#endif /* VENDOR_EDIT */ 
+    { "bt.",        AID_BLUETOOTH,    0 },
+    { "persist.mtk.wcn.combo.",        AID_SYSTEM,    0 },
+    { "nvram_init",      AID_NVRAM,   0 },
+    { "persist.mtklog.",  AID_SHELL,   0 },
+//#ifdef VENDOR_EDIT 
+// #Bingshu.Zhou@SystemSrv.Build, 2013/03/9,add for oppo property
+	{ "persist.oppo.", 	  AID_SYSTEM,    0 },
+//#endif /* VENDOR_EDIT */ 	
     { NULL, 0, 0 }
 };
 
@@ -106,9 +121,12 @@ struct {
     unsigned int uid;
     unsigned int gid;
 } control_perms[] = {
-    { "dumpstate",AID_SHELL, AID_LOG },
-    { "ril-daemon",AID_RADIO, AID_RADIO },
-     {NULL, 0, 0 }
+    { "dumpstate", AID_SHELL, AID_LOG },
+    { "ril-daemon", AID_RADIO, AID_RADIO },
+    { "muxreport-daemon", AID_RADIO, AID_RADIO },
+    { "md_minilog_util", AID_RADIO, AID_RADIO},
+    { "sysctl", AID_SHELL, AID_SHELL},
+    {NULL, 0, 0 }
 };
 
 typedef struct {
@@ -157,9 +175,15 @@ out:
 /* (8 header words + 247 toc words) = 1020 bytes */
 /* 1024 bytes header and toc + 247 prop_infos @ 128 bytes = 32640 bytes */
 
-#define PA_COUNT_MAX  247
-#define PA_INFO_START 1024
-#define PA_SIZE       32768
+/* System property area = [pa part|pi part] */
+
+//#define PA_COUNT_MAX  247
+#define PA_COUNT_MAX 375
+#define PA_INFO_START (4*(8 + PA_COUNT_MAX+1))
+#define PA_SIZE (PA_INFO_START + PA_COUNT_MAX*128 + 128)
+
+#define PA_COUNT_WARN ((PA_COUNT_MAX*9)/10) 
+
 
 static workspace pa_workspace;
 static prop_info *pa_info_array;
@@ -199,77 +223,23 @@ static void update_prop_info(prop_info *pi, const char *value, unsigned len)
     __futex_wake(&pi->serial, INT32_MAX);
 }
 
-static int check_mac_perms(const char *name, char *sctx)
-{
-#ifdef HAVE_SELINUX
-    if (is_selinux_enabled() <= 0)
-        return 1;
-
-    char *tctx = NULL;
-    const char *class = "property_service";
-    const char *perm = "set";
-    int result = 0;
-
-    if (!sctx)
-        goto err;
-
-    if (!sehandle_prop)
-        goto err;
-
-    if (selabel_lookup(sehandle_prop, &tctx, name, 1) != 0)
-        goto err;
-
-    if (selinux_check_access(sctx, tctx, class, perm, name) == 0)
-        result = 1;
-
-    freecon(tctx);
- err:
-    return result;
-
-#endif
-    return 1;
-}
-
-static int check_control_mac_perms(const char *name, char *sctx)
-{
-#ifdef HAVE_SELINUX
-
-    /*
-     *  Create a name prefix out of ctl.<service name>
-     *  The new prefix allows the use of the existing
-     *  property service backend labeling while avoiding
-     *  mislabels based on true property prefixes.
-     */
-    char ctl_name[PROP_VALUE_MAX+4];
-    int ret = snprintf(ctl_name, sizeof(ctl_name), "ctl.%s", name);
-
-    if (ret < 0 || (size_t) ret >= sizeof(ctl_name))
-        return 0;
-
-    return check_mac_perms(ctl_name, sctx);
-
-#endif
-    return 1;
-}
-
 /*
  * Checks permissions for starting/stoping system services.
  * AID_SYSTEM and AID_ROOT are always allowed.
  *
  * Returns 1 if uid allowed, 0 otherwise.
  */
-static int check_control_perms(const char *name, unsigned int uid, unsigned int gid, char *sctx) {
-
+static int check_control_perms(const char *name, unsigned int uid, unsigned int gid) {
     int i;
     if (uid == AID_SYSTEM || uid == AID_ROOT)
-      return check_control_mac_perms(name, sctx);
+        return 1;
 
     /* Search the ACL */
     for (i = 0; control_perms[i].service; i++) {
         if (strcmp(control_perms[i].service, name) == 0) {
             if ((uid && control_perms[i].uid == uid) ||
                 (gid && control_perms[i].gid == gid)) {
-                return check_control_mac_perms(name, sctx);
+                return 1;
             }
         }
     }
@@ -280,22 +250,28 @@ static int check_control_perms(const char *name, unsigned int uid, unsigned int
  * Checks permissions for setting system properties.
  * Returns 1 if uid allowed, 0 otherwise.
  */
-static int check_perms(const char *name, unsigned int uid, unsigned int gid, char *sctx)
+static int check_perms(const char *name, unsigned int uid, unsigned int gid)
 {
     int i;
+    if (uid == 0)
+        return 1;
+    //#ifdef VENDOR_EDIT
+    //Bingshu.Zhou@SystemSrv.Build, 2013/03/8, Add for enable set oppo property        
+	if (!strncmp(name, "oppo.", 5)){
+		return 1;
+	}
+    //#endif /* VENDOR_EDIT */
+
     if(!strncmp(name, "ro.", 3))
         name +=3;
 
-    if (uid == 0)
-        return check_mac_perms(name, sctx);
-
     for (i = 0; property_perms[i].prefix; i++) {
+        int tmp;
         if (strncmp(property_perms[i].prefix, name,
                     strlen(property_perms[i].prefix)) == 0) {
             if ((uid && property_perms[i].uid == uid) ||
                 (gid && property_perms[i].gid == gid)) {
-
-                return check_mac_perms(name, sctx);
+                return 1;
             }
         }
     }
@@ -324,6 +300,7 @@ static void write_persistent_property(const char *name, const char *value)
     char path[PATH_MAX];
     int fd, length;
 
+    NOTICE("Sync Persist[%s:%s] Start\n", name, value);
     snprintf(path, sizeof(path), "%s/%s", PERSISTENT_PROPERTY_DIR, name);
 
     fd = open(tempPath, O_WRONLY|O_CREAT|O_TRUNC, 0600);
@@ -332,14 +309,28 @@ static void write_persistent_property(const char *name, const char *value)
         return;
     }
     write(fd, value, strlen(value));
+    fsync(fd);
     close(fd);
 
     if (rename(tempPath, path)) {
         unlink(tempPath);
         ERROR("Unable to rename persistent property file %s to %s\n", tempPath, path);
     }
+    NOTICE("Sync Persist[%s:%s] Done\n", name, value);
+}
+void property_show(void)
+{
+    prop_area *pa = __system_property_area__;
+    unsigned count = pa->count;
+    unsigned *toc = pa->toc;
+    prop_info *pi;
+    unsigned i;
+    for(i = 0; i< count; i++){
+        unsigned entry = *toc++;
+        pi = TOC_TO_INFO(pa, entry);
+        klog_write(4, "<4> #%3d[+%2d]%-32s = %s\n", i+1, (pi->serial) & 0xffffff, pi->name, pi->value);
+    }
 }
-
 int property_set(const char *name, const char *value)
 {
     prop_area *pa;
@@ -348,15 +339,28 @@ int property_set(const char *name, const char *value)
     int namelen = strlen(name);
     int valuelen = strlen(value);
 
-    if(namelen >= PROP_NAME_MAX) return -1;
-    if(valuelen >= PROP_VALUE_MAX) return -1;
-    if(namelen < 1) return -1;
+    INFO("PropSet[%s:%s] Start\n", name, value);
+    if(namelen >= PROP_NAME_MAX){
+        ERROR("PropSet Error:[%s:%s] namelen >= %d\n", name, value, PROP_NAME_MAX);
+        return -1;
+    }
+    if(valuelen >= PROP_VALUE_MAX){
+        ERROR("PropSet Error:[%s:%s] valuelen >= %d\n", name, value, PROP_NAME_MAX);
+        return -1;
+    }
+    if(namelen < 1){
+        ERROR("PropSet Error:[%s:%s] namelen < 1\n", name, value);
+        return -1;
+    }
 
     pi = (prop_info*) __system_property_find(name);
 
     if(pi != 0) {
         /* ro.* properties may NEVER be modified once set */
-        if(!strncmp(name, "ro.", 3)) return -1;
+        if(!strncmp(name, "ro.", 3)){
+            ERROR("PropSet Error:[%s:%s]  ro.* properties may NEVER be modified once set\n", name, value);
+            return -1;
+        }
 
         pa = __system_property_area__;
         update_prop_info(pi, value, valuelen);
@@ -364,7 +368,15 @@ int property_set(const char *name, const char *value)
         __futex_wake(&pa->serial, INT32_MAX);
     } else {
         pa = __system_property_area__;
-        if(pa->count == PA_COUNT_MAX) return -1;
+        if(pa->count == PA_COUNT_WARN){
+            ERROR("[Property warning] limit would be arrived:%d (Max:%d). Use getprop to review your properties!\n", PA_COUNT_WARN, PA_COUNT_MAX);
+            property_show();
+        }
+        if(pa->count == PA_COUNT_MAX){
+            ERROR("Unable to set Property. Property limit has arrived: %d\n", pa->count);
+            property_show();
+            return -1;
+        }
 
         pi = pa_info_array + pa->count;
         pi->serial = (valuelen << 24);
@@ -396,11 +408,6 @@ int property_set(const char *name, const char *value)
          * to prevent them from being overwritten by default values.
          */
         write_persistent_property(name, value);
-#ifdef HAVE_SELINUX
-    } else if (strcmp("selinux.reload_policy", name) == 0 &&
-               strcmp("1", value) == 0) {
-        selinux_reload_policy();
-#endif
     }
     property_changed(name, value);
     return 0;
@@ -416,7 +423,6 @@ void handle_property_set_fd()
     struct sockaddr_un addr;
     socklen_t addr_size = sizeof(addr);
     socklen_t cr_size = sizeof(cr);
-    char * source_ctx = NULL;
 
     if ((s = accept(property_set_fd, (struct sockaddr *) &addr, &addr_size)) < 0) {
         return;
@@ -442,22 +448,18 @@ void handle_property_set_fd()
         msg.name[PROP_NAME_MAX-1] = 0;
         msg.value[PROP_VALUE_MAX-1] = 0;
 
-#ifdef HAVE_SELINUX
-        getpeercon(s, &source_ctx);
-#endif
-
         if(memcmp(msg.name,"ctl.",4) == 0) {
             // Keep the old close-socket-early behavior when handling
             // ctl.* properties.
             close(s);
-            if (check_control_perms(msg.value, cr.uid, cr.gid, source_ctx)) {
+            if (check_control_perms(msg.value, cr.uid, cr.gid)) {
                 handle_control_message((char*) msg.name + 4, (char*) msg.value);
             } else {
                 ERROR("sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\n",
                         msg.name + 4, msg.value, cr.uid, cr.gid, cr.pid);
             }
         } else {
-            if (check_perms(msg.name, cr.uid, cr.gid, source_ctx)) {
+            if (check_perms(msg.name, cr.uid, cr.gid)) {
                 property_set((char*) msg.name, (char*) msg.value);
             } else {
                 ERROR("sys_prop: permission denied uid:%d  name:%s\n",
@@ -469,10 +471,6 @@ void handle_property_set_fd()
             // the property is written to memory.
             close(s);
         }
-#ifdef HAVE_SELINUX
-        freecon(source_ctx);
-#endif
-
         break;
 
     default:
@@ -582,16 +580,6 @@ int properties_inited(void)
     return property_area_inited;
 }
 
-static void load_override_properties() {
-#ifdef ALLOW_LOCAL_PROP_OVERRIDE
-    const char *debuggable = property_get("ro.debuggable");
-    if (debuggable && (strcmp(debuggable, "1") == 0)) {
-        load_properties_from_file(PROP_PATH_LOCAL_OVERRIDE);
-    }
-#endif /* ALLOW_LOCAL_PROP_OVERRIDE */
-}
-
-
 /* When booting an encrypted system, /data is not mounted when the
  * property service is started, so any properties stored there are
  * not loaded.  Vold triggers init to load these properties once it
@@ -599,7 +587,9 @@ static void load_override_properties() {
  */
 void load_persist_props(void)
 {
-    load_override_properties();
+#ifdef ALLOW_LOCAL_PROP_OVERRIDE
+    load_properties_from_file(PROP_PATH_LOCAL_OVERRIDE);
+#endif /* ALLOW_LOCAL_PROP_OVERRIDE */
     /* Read persistent properties after all default values have been loaded. */
     load_persistent_properties();
 }
@@ -610,10 +600,14 @@ void start_property_service(void)
 
     load_properties_from_file(PROP_PATH_SYSTEM_BUILD);
     load_properties_from_file(PROP_PATH_SYSTEM_DEFAULT);
-    load_override_properties();
+#ifdef ALLOW_LOCAL_PROP_OVERRIDE
+    load_properties_from_file(PROP_PATH_LOCAL_OVERRIDE);
+#endif /* ALLOW_LOCAL_PROP_OVERRIDE */
     /* Read persistent properties after all default values have been loaded. */
     load_persistent_properties();
 
+    patch_properties(); // added by MTK
+
     fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM, 0666, 0, 0);
     if(fd < 0) return;
     fcntl(fd, F_SETFD, FD_CLOEXEC);
diff --git a/system/core/init/property_service.h b/gb/12055-master/driveronly_mp_rom/system/core/init/property_service.h
index b9d1bf6..653af04 100644
--- a/system/core/init/property_service.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/init/property_service.h
@@ -30,4 +30,6 @@ extern int property_set(const char *name, const char *value);
 extern int properties_inited();
 int get_property_set_fd(void);
 
+extern int patch_properties(void);  // added by MTK
+
 #endif	/* _INIT_PROPERTY_H */
diff --git a/system/core/init/util.c b/gb/12055-master/driveronly_mp_rom/system/core/init/util.c
index 743748b..ddecb8b 100755
--- a/system/core/init/util.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/init/util.c
@@ -302,12 +302,12 @@ int mkdir_recursive(const char *pathname, mode_t mode)
         memcpy(buf, pathname, width);
         buf[width] = 0;
         if (stat(buf, &info) != 0) {
-            ret = make_dir(buf, mode);
+            ret = mkdir(buf, mode);
             if (ret && errno != EEXIST)
                 return ret;
         }
     }
-    ret = make_dir(pathname, mode);
+    ret = mkdir(pathname, mode);
     if (ret && errno != EEXIST)
         return ret;
     return 0;
@@ -512,3 +512,150 @@ int restorecon(const char *pathname)
 #endif
     return 0;
 }
+#ifdef MTK_NAND_UBIFS_SUPPORT
+#define UBI_CTRL_DEV "/dev/ubi_ctrl"
+#define UBI_SYS_PATH "/sys/class/ubi"
+static int ubi_dev_read_int(int dev, const char *file, int def)
+{
+    int fd, val = def;
+    char path[128], buf[64];
+
+    sprintf(path, UBI_SYS_PATH "/ubi%d/%s", dev, file);
+    wait_for_file(path, 5);
+    fd = open(path, O_RDONLY);
+    if (fd == -1) {
+        return val;
+    }
+
+    if (read(fd, buf, 64) > 0) {
+        val = atoi(buf);
+    }
+
+    close(fd);
+    return val;
+}
+
+// Should include kernel header include/mtd/ubi-user.h
+#include <linux/types.h>
+#include <asm/ioctl.h>
+#define UBI_CTRL_IOC_MAGIC 'o'
+#define UBI_IOC_MAGIC 'o'
+#define UBI_VOL_NUM_AUTO (-1)
+#define UBI_DEV_NUM_AUTO (-1)
+#define UBI_IOCATT _IOW(UBI_CTRL_IOC_MAGIC, 64, struct ubi_attach_req)
+#define UBI_IOCDET _IOW(UBI_CTRL_IOC_MAGIC, 65, __s32)
+#define UBI_IOCMKVOL _IOW(UBI_IOC_MAGIC, 0, struct ubi_mkvol_req)
+#define UBI_MAX_VOLUME_NAME 127
+
+struct ubi_attach_req {
+	__s32 ubi_num;
+	__s32 mtd_num;
+	__s32 vid_hdr_offset;
+	__s8 padding[12];
+};
+
+struct ubi_mkvol_req {
+	__s32 vol_id;
+	__s32 alignment;
+	__s64 bytes;
+	__s8 vol_type;
+	__s8 padding1;
+	__s16 name_len;
+	__s8 padding2[4];
+	char name[UBI_MAX_VOLUME_NAME + 1];
+} __packed;
+
+enum {
+	UBI_DYNAMIC_VOLUME = 3,
+	UBI_STATIC_VOLUME  = 4,
+};
+
+// Should include kernel header include/mtd/ubi-user.h
+
+int ubi_attach_mtd(const char *name)
+{
+    int ret;
+    int mtd_num, ubi_num;
+    int ubi_ctrl, ubi_dev;
+    int vols, avail_lebs, leb_size;
+    char path[128];
+    struct ubi_attach_req attach_req;
+    struct ubi_mkvol_req mkvol_req;
+   
+    mtd_num = mtd_name_to_number(name);
+    if (mtd_num == -1) {
+        return -1;
+    }
+
+    for (ubi_num = 0; ubi_num < 4; ubi_num++)
+    {
+      sprintf(path, "/sys/class/ubi/ubi%d/mtd_num", ubi_num);
+      ubi_dev = open(path, O_RDONLY);
+      if (ubi_dev != -1)
+      {
+        ret = read(ubi_dev, path, sizeof(path));
+        close(ubi_dev);
+        if (ret > 0 && mtd_num == atoi(path))
+          return ubi_num;
+      }
+    }
+
+    ubi_ctrl = open(UBI_CTRL_DEV, O_RDONLY);
+    if (ubi_ctrl == -1) {
+        return -1;
+    }
+
+    memset(&attach_req, 0, sizeof(struct ubi_attach_req));
+    attach_req.ubi_num = UBI_DEV_NUM_AUTO;
+    attach_req.mtd_num = mtd_num;
+    attach_req.vid_hdr_offset = 4096;  // for page and VID is 4096, but sub-page is 2048  (KF94G16Q4X-AEB)
+
+    ret = ioctl(ubi_ctrl, UBI_IOCATT, &attach_req);
+    if (ret == -1) {
+        close(ubi_ctrl);
+        return -1;
+    }
+
+    ubi_num = attach_req.ubi_num;
+   
+    vols = ubi_dev_read_int(ubi_num, "volumes_count", -1);
+    if (vols == 0) {
+        sprintf(path, "/dev/ubi%d", ubi_num);
+        ubi_dev = open(path, O_RDONLY);
+        if (ubi_dev == -1) {
+            close(ubi_ctrl);
+            return ubi_num;
+        }
+       
+        avail_lebs = ubi_dev_read_int(ubi_num, "avail_eraseblocks", 0);
+        leb_size = ubi_dev_read_int(ubi_num, "eraseblock_size", 0);
+
+        memset(&mkvol_req, 0, sizeof(struct ubi_mkvol_req));
+        mkvol_req.vol_id = UBI_VOL_NUM_AUTO;
+        mkvol_req.alignment = 1;
+        mkvol_req.bytes = (long long)avail_lebs * leb_size;
+        mkvol_req.vol_type = UBI_DYNAMIC_VOLUME;
+        ret = snprintf(mkvol_req.name, UBI_MAX_VOLUME_NAME + 1, "%s", name);
+        mkvol_req.name_len = ret;
+        ioctl(ubi_dev, UBI_IOCMKVOL, &mkvol_req);
+        close(ubi_dev);
+    }
+
+    close(ubi_ctrl);
+    return ubi_num;
+}
+
+int ubi_detach_dev(int dev)
+{
+    int ret, ubi_ctrl;
+
+    ubi_ctrl = open(UBI_CTRL_DEV, O_RDONLY);
+    if (ubi_ctrl == -1) {
+        return -1;
+    }
+
+    ret = ioctl(ubi_ctrl, UBI_IOCDET, &dev);
+    close(ubi_ctrl);
+    return ret;
+}
+#endif
diff --git a/system/core/init/util.h b/gb/12055-master/driveronly_mp_rom/system/core/init/util.h
index 45905b6..c920838 100644
--- a/system/core/init/util.h
+++ b/gb/12055-master/driveronly_mp_rom/system/core/init/util.h
@@ -41,4 +41,8 @@ void get_hardware_name(char *hardware, unsigned int *revision);
 void import_kernel_cmdline(int in_qemu, void (*import_kernel_nv)(char *name, int in_qemu));
 int make_dir(const char *path, mode_t mode);
 int restorecon(const char *pathname);
+#ifdef MTK_NAND_UBIFS_SUPPORT
+int ubi_attach_mtd(const char *name);
+int ubi_detach_dev(int dev);
+#endif
 #endif
diff --git a/system/core/libcorkscrew/arch-arm/ptrace-arm.c b/gb/12055-master/driveronly_mp_rom/system/core/libcorkscrew/arch-arm/ptrace-arm.c
index 868230c..d77d915 100644
--- a/system/core/libcorkscrew/arch-arm/ptrace-arm.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libcorkscrew/arch-arm/ptrace-arm.c
@@ -29,12 +29,15 @@
 static void load_exidx_header(pid_t pid, map_info_t* mi,
         uintptr_t* out_exidx_start, size_t* out_exidx_size) {
     uint32_t elf_phoff;
-    uint32_t elf_phentsize_phnum;
+    uint32_t elf_shentsize_phnum;
+    uint32_t elf_phentsize_ehsize;
     if (try_get_word_ptrace(pid, mi->start + offsetof(Elf32_Ehdr, e_phoff), &elf_phoff)
             && try_get_word_ptrace(pid, mi->start + offsetof(Elf32_Ehdr, e_phnum),
-                    &elf_phentsize_phnum)) {
-        uint32_t elf_phentsize = elf_phentsize_phnum >> 16;
-        uint32_t elf_phnum = elf_phentsize_phnum & 0xffff;
+                    &elf_shentsize_phnum)
+            && try_get_word_ptrace(pid, mi->start + offsetof(Elf32_Ehdr, e_ehsize),
+                    &elf_phentsize_ehsize)) {
+        uint32_t elf_phentsize = elf_phentsize_ehsize >> 16;
+        uint32_t elf_phnum = elf_shentsize_phnum & 0xffff;
         for (uint32_t i = 0; i < elf_phnum; i++) {
             uintptr_t elf_phdr = mi->start + elf_phoff + i * elf_phentsize;
             uint32_t elf_phdr_type;
diff --git a/system/core/libcutils/Android.mk b/gb/12055-master/driveronly_mp_rom/system/core/libcutils/Android.mk
index d9bd8d8..058b450 100644
--- a/system/core/libcutils/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libcutils/Android.mk
@@ -92,7 +92,16 @@ LOCAL_MODULE := libcutils
 LOCAL_SRC_FILES := $(commonSources) $(commonHostSources) dlmalloc_stubs.c
 LOCAL_LDLIBS := -lpthread
 LOCAL_STATIC_LIBRARIES := liblog
-LOCAL_CFLAGS += $(hostSmpFlag)
+ifneq ($(TARGET_BUILD_VARIANT),user)
+LOCAL_CFLAGS += $(hostSmpFlag) \
+                -DLIBC_STATIC \
+                -DHOST_LIBCUTILS_STATIC \
+		-DDLMALLOC_DEBUG
+else
+LOCAL_CFLAGS += $(hostSmpFlag) \
+	-DHOST_LIBCUTILS_STATIC \
+	-DLIBC_STATIC
+endif
 include $(BUILD_HOST_STATIC_LIBRARY)
 
 
@@ -103,7 +112,9 @@ LOCAL_MODULE := lib64cutils
 LOCAL_SRC_FILES := $(commonSources) $(commonHostSources) dlmalloc_stubs.c
 LOCAL_LDLIBS := -lpthread
 LOCAL_STATIC_LIBRARIES := lib64log
-LOCAL_CFLAGS += $(hostSmpFlag) -m64
+LOCAL_CFLAGS += $(hostSmpFlag) \
+		-m64 \
+		-DHOST_LIBCUTILS_STATIC
 include $(BUILD_HOST_STATIC_LIBRARY)
 
 
@@ -120,15 +131,25 @@ LOCAL_MODULE := libcutils
 LOCAL_SRC_FILES := $(commonSources) \
         android_reboot.c \
         ashmem-dev.c \
+        pmem-dev.cpp \
         debugger.c \
         klog.c \
         mq.c \
         partition_utils.c \
         qtaguid.c \
         uevent.c
-
+ifneq ($(TARGET_BUILD_VARIANT),user)
+LOCAL_CFLAGS += -DDLMALLOC_DEBUG
+endif
 ifeq ($(TARGET_ARCH),arm)
 LOCAL_SRC_FILES += arch-arm/memset32.S
+ifeq ($(TARGET_BUILD_VARIANT),eng)
+ifeq ($(filter banyan_addon banyan_addon_x86,$(TARGET_PRODUCT)),)
+LOCAL_CFLAGS += \
+		-fno-omit-frame-pointer \
+		-mapcs	
+endif
+endif
 else  # !arm
 ifeq ($(TARGET_ARCH_VARIANT),x86-atom)
 LOCAL_CFLAGS += -DHAVE_MEMSET16 -DHAVE_MEMSET32
@@ -140,10 +161,15 @@ endif # !arm
 
 LOCAL_C_INCLUDES := $(libcutils_c_includes) $(KERNEL_HEADERS)
 LOCAL_STATIC_LIBRARIES := liblog
-LOCAL_CFLAGS += $(targetSmpFlag)
+LOCAL_CFLAGS += $(targetSmpFlag) \
+		-DLIBC_STATIC
 include $(BUILD_STATIC_LIBRARY)
 
 include $(CLEAR_VARS)
+
+# mtk04376: Force to ARM build for debug15 memory debugging
+LOCAL_ARM_MODE := arm
+
 LOCAL_MODULE := libcutils
 LOCAL_WHOLE_STATIC_LIBRARIES := libcutils
 LOCAL_SHARED_LIBRARIES := liblog
diff --git a/system/core/libcutils/fs.c b/gb/12055-master/driveronly_mp_rom/system/core/libcutils/fs.c
index 1226d44..02c9311 100644
--- a/system/core/libcutils/fs.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libcutils/fs.c
@@ -66,11 +66,14 @@ fixup:
         ALOGE("Failed to chmod(%s, %d): %s", path, mode, strerror(errno));
         return -1;
     }
+
+    ALOGE("to chown(%s, %d, %d)", path, uid, gid);
+#if 1 //ccyeh
     if (TEMP_FAILURE_RETRY(chown(path, uid, gid)) == -1) {
-        ALOGE("Failed to chown(%s, %d, %d): %s", path, uid, gid, strerror(errno));
-        return -1;
+        ALOGE("Failed to chown(%s, %d, %d): %s %d", path, uid, gid, strerror(errno), errno);
+        return 0;
     }
-
+#endif
     return 0;
 }
 
diff --git a/system/core/libcutils/list.c b/gb/12055-master/driveronly_mp_rom/system/core/libcutils/list.c
index e13452d..2d12f65 100644
--- a/system/core/libcutils/list.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libcutils/list.c
@@ -30,6 +30,14 @@ void list_add_tail(struct listnode *head, struct listnode *item)
     head->prev = item;
 }
 
+void list_add_head(struct listnode *head, struct listnode *item)
+{
+    item->next = head->next;
+    item->prev = head->next->prev;
+    head->next->prev = item;
+    head->next = item;
+}
+
 void list_remove(struct listnode *item)
 {
     item->next->prev = item->prev;
diff --git a/system/core/libcutils/partition_utils.c b/gb/12055-master/driveronly_mp_rom/system/core/libcutils/partition_utils.c
index 10539fa..862dfc8 100644
--- a/system/core/libcutils/partition_utils.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libcutils/partition_utils.c
@@ -22,6 +22,9 @@
 #include <sys/mount.h> /* for BLKGETSIZE */
 #include <cutils/properties.h>
 
+#include <errno.h>
+#include <cutils/partition_utils.h>
+
 static int only_one_char(char *buf, int len, char c)
 {
     int i, ret;
@@ -65,3 +68,100 @@ int partition_wiped(char *source)
     return 0;
 }
 
+#ifdef MTK_EMMC_SUPPORT
+int misc_set_phone_encrypt_state(const struct phone_encrypt_state *in) {
+    int dev = -1;
+    char dev_name[32];
+    int count;
+
+    strcpy(dev_name, "/dev/misc");
+
+    dev = open(dev_name, O_WRONLY);
+    if (dev < 0)  {
+        printf("Can't open %s\n(%s)\n", dev_name, strerror(errno));
+        return -1;
+    }
+
+    if (lseek(dev, PHONE_ENCRYPT_OFFSET, SEEK_SET) == -1) {
+        printf("Failed seeking %s\n(%s)\n", dev_name, strerror(errno));
+        close(dev);
+        return -1;
+    }
+
+    count = write(dev, in, sizeof(*in));
+    if (count != sizeof(*in)) {
+        printf("Failed writing %s\n(%s)\n", dev_name, strerror(errno));
+        return -1;
+    }
+    if (close(dev) != 0) {
+        printf("Failed closing %s\n(%s)\n", dev_name, strerror(errno));
+        return -1;
+    }
+    return 0;
+}
+
+int misc_get_phone_encrypt_state(struct phone_encrypt_state *in) {
+
+    int dev = -1;
+    char dev_name[32];
+    int count;
+
+    strcpy(dev_name, "/dev/misc");
+
+    dev = open(dev_name, O_RDONLY);
+    if (dev < 0)  {
+        printf("Can't open %s\n(%s)\n", dev_name, strerror(errno));
+        return -1;
+    }
+
+    if (lseek(dev, PHONE_ENCRYPT_OFFSET, SEEK_SET) == -1) {
+        printf("Failed seeking %s\n(%s)\n", dev_name, strerror(errno));
+        close(dev);
+        return -1;
+    }
+
+    count = read(dev, in, sizeof(*in));
+    if (count != sizeof(*in)) {
+        printf("Failed reading %s\n(%s)\n", dev_name, strerror(errno));
+        return -1;
+    }
+    if (close(dev) != 0) {
+        printf("Failed closing %s\n(%s)\n", dev_name, strerror(errno));
+        return -1;
+    }
+    return 0;
+
+}
+
+
+int misc_test(int argc, char **argv)
+{
+
+    struct phone_encrypt_state ps;
+
+    if (argc == 1) {
+
+        misc_get_phone_encrypt_state(&ps);
+
+        if (ps.state == PHONE_ENCRYPTED) {
+            printf("Phone is encrypted (%x)\n", ps.state);
+        } else {
+            printf("Phone is not encrypted (%x)\n", ps.state);
+        }
+
+        return 0;
+    }
+
+    if (atoi(argv[1]) == 0) {
+        ps.state = 0;
+    } else {
+        ps.state = PHONE_ENCRYPTED;
+    }
+
+    misc_set_phone_encrypt_state(&ps);
+    sync();
+
+    return 0;
+}
+#endif
+
diff --git a/gb/12055-master/driveronly_mp_rom/system/core/libcutils/pmem-dev.cpp b/gb/12055-master/driveronly_mp_rom/system/core/libcutils/pmem-dev.cpp
new file mode 100644
index 0000000..5897dbd
--- /dev/null
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libcutils/pmem-dev.cpp
@@ -0,0 +1,407 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <linux/android_pmem.h>
+#include <cutils/pmem.h>
+#include <utils/Log.h>
+
+#define LOGE    ALOGE
+
+#undef  LOG_TAG
+#define LOG_TAG "utils_pmem"
+
+#include <unwind.h>
+#include <stdlib.h>
+#include <cutils/properties.h>
+
+#define PMEM_DEVICE_NAME "/dev/pmem_multimedia"
+#define IOCTL_FAILED      -1
+#define UNMAP_FAILED      -1
+#define CLOSE_FAILED      -1
+#define INVALID_FD        -1
+//#define PAGE_SIZE       4096
+
+
+static char p_value[PROPERTY_VALUE_MAX] = "";
+static bool p_res = 0;
+
+    
+static size_t align_size(size_t size)
+{
+	return ((size + PAGE_SIZE-1) & ~(PAGE_SIZE-1));
+}
+
+// =============================================================================
+// stack trace functions
+// =============================================================================
+//
+// The statck related function is copy from bionic
+// 
+
+typedef struct
+{
+    size_t count;
+    intptr_t* addrs;
+} stack_crawl_state_t;
+
+/* depends how the system includes define this */
+#ifdef HAVE_UNWIND_CONTEXT_STRUCT
+typedef struct _Unwind_Context __unwind_context;
+#else
+typedef _Unwind_Context __unwind_context;
+#endif
+
+static _Unwind_Reason_Code trace_function(__unwind_context *context, void *arg)
+{
+    stack_crawl_state_t* state = (stack_crawl_state_t*)arg;
+    if (state->count) {
+        intptr_t ip = (intptr_t)_Unwind_GetIP(context);
+        if (ip) {
+            state->addrs[0] = ip;
+            state->addrs++;
+            state->count--;
+            return _URC_NO_REASON;
+        }
+    }
+    /*
+     * If we run out of space to record the address or 0 has been seen, stop
+     * unwinding the stack.
+     */
+    return _URC_END_OF_STACK;
+}
+
+static inline
+int get_backtrace(intptr_t* addrs, size_t max_entries)
+{
+    stack_crawl_state_t state;
+    state.count = max_entries;
+    state.addrs = (intptr_t*)addrs;
+    _Unwind_Backtrace(trace_function, (void*)&state);
+    return max_entries - state.count;
+}
+
+static void dump_stack_trace()
+{
+    intptr_t addrs[20];
+    int c = get_backtrace(addrs, 20);
+    char buf[21];
+    char tmp[21*20];
+    int i;
+
+    tmp[0] = 0; // Need to initialize tmp[0] for the first strcat
+    for (i=0 ; i<c; i++) {
+        snprintf(buf, sizeof buf, "[PMEM]%2d: %08x\n", i, addrs[i]);
+        strlcat(tmp, buf, sizeof tmp);
+    }
+    //__libc_android_log_print(ANDROID_LOG_ERROR, "libc", "call stack:\n%s", tmp);
+    LOGE("[PMEM] call stack:\n%s", tmp);
+}
+
+void* pmem_alloc(size_t size, int *pfd)
+{
+    int         fd;
+    size_t      aligned_size;
+    void*       base;
+    pmem_region region = { 0, 0 };
+    int         err;
+
+    if (NULL == pfd)
+    {
+        return NULL;
+    }
+
+    *pfd = -1;
+    
+    fd = open(PMEM_DEVICE_NAME, (O_RDWR | O_SYNC));
+    if (INVALID_FD == fd)
+    {
+        LOGE("[PMEM] open %s failed!", PMEM_DEVICE_NAME);
+        goto open_failed;
+    }
+
+    aligned_size = align_size(size);
+    base = mmap(0, aligned_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+    if (MAP_FAILED == base) 
+    {
+        LOGE("[PMEM] mmap size %d failed!", aligned_size);
+        goto mmap_failed;
+    }
+    
+    region.len = aligned_size;
+    err = ioctl(fd, PMEM_MAP, &region);
+    if (IOCTL_FAILED == err)
+    {
+        LOGE("[PMEM] PMEM_MAP size %d failed!", aligned_size);
+        goto pmem_map_failed;
+    }
+
+    property_get("pm.dumpstack", p_value, "0"); //if not set, disable by default 
+    p_res = atoi(p_value);
+    if (p_res) 
+    {
+        LOGE("[PMEM] pmem_alloc: base: 0x%08x, size: %d\n", (int)base, aligned_size);
+        dump_stack_trace();
+    }
+
+    *pfd = fd;
+    
+    return base;
+
+
+insert_failed:
+    ioctl(fd, PMEM_UNMAP, &region);
+pmem_map_failed:
+    munmap(base, aligned_size);
+mmap_failed:
+    close(fd);
+open_failed:
+    return NULL;    
+}
+
+
+void* pmem_alloc_sync(size_t size, int *pfd)
+{
+    int         fd;
+    size_t      aligned_size;
+    void*       base;
+    pmem_region region = { 0, 0 };
+    int         err;
+
+	if (NULL == pfd)
+	{
+		return NULL;
+	}
+
+	*pfd = -1;
+    
+    fd = open(PMEM_DEVICE_NAME, O_RDWR|O_SYNC);
+    if (INVALID_FD == fd)
+    {
+        LOGE("[PMEM] open %s failed!", PMEM_DEVICE_NAME);
+        goto open_failed;
+    }
+
+    aligned_size = align_size(size);
+    base = mmap(0, aligned_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+    if (MAP_FAILED == base) 
+    {
+        LOGE("[PMEM] mmap size %d failed!", aligned_size);
+        goto mmap_failed;
+    }
+    
+    region.len = aligned_size;
+    err = ioctl(fd, PMEM_MAP, &region);
+    if (IOCTL_FAILED == err)
+    {
+        LOGE("[PMEM] PMEM_MAP size %d failed!", aligned_size);
+        goto pmem_map_failed;
+    }
+
+    property_get("pm.dumpstack", p_value, "0"); //if not set, disable by default 
+    p_res = atoi(p_value);
+    if (p_res) 
+    {
+        LOGE("[PMEM] pmem_alloc_sync: base: 0x%08x, size: %d\n", (int)base, aligned_size);
+        dump_stack_trace();
+    }
+
+    *pfd = fd;
+    return base;
+
+
+insert_failed:
+    ioctl(fd, PMEM_UNMAP, &region);
+pmem_map_failed:
+    munmap(base, aligned_size);
+mmap_failed:
+    close(fd);
+open_failed:
+    return NULL;    
+}
+
+
+int  pmem_free(void *ptr, size_t size, int fd)
+{
+    int err, ret = 0;
+    size_t aligned_size = align_size(size);    
+
+    pmem_region region = { 0, aligned_size };
+    err = ioctl(fd, PMEM_UNMAP, &region);
+    if (IOCTL_FAILED == err)
+    {
+        LOGE("PMEM_UNMAP size %d failed!", size);
+        ret = err;
+    }
+    
+    err = munmap(ptr, aligned_size);
+    if (UNMAP_FAILED == err)
+    {
+        LOGE("mumap size %d failed!", size);
+        ret = err;
+    }    
+
+    err = close(fd);
+    if (CLOSE_FAILED == err)
+    {
+        LOGE("Close file %d failed!", fd);
+        ret = err;
+    }
+
+
+    property_get("pm.dumpstack", p_value, "0"); //if not set, disable by default 
+    p_res = atoi(p_value);
+    if (p_res) 
+    {
+        LOGE("[PMEM] pmem_free: base: 0x%08x, size: %d\n", (int)ptr, aligned_size);
+        dump_stack_trace();
+    }
+
+    
+    return ret;
+}
+
+
+void* pmem_get_phys(int fd)
+{
+    pmem_region pmem_reg;
+    int err = ioctl(fd, PMEM_GET_PHYS, &pmem_reg);
+    if (IOCTL_FAILED == err)
+    {
+        LOGE("PMEM_GET_PHYS failed: 0x%X !", fd);
+        return NULL;
+    }
+
+    return (void*)(pmem_reg.offset);
+}
+
+void pmem_cache_flush(int fd, unsigned int offset, unsigned int length) {
+    pmem_region region = { 0, 0 };
+    int         err = -1; 
+
+    if (fd < 0 || offset == 0 || length == 0) {
+        LOGE("pmem_cache_flush: invalide argument\n");
+        return;
+    }   
+
+    region.offset = offset;
+    region.len = length;
+    err = ioctl(fd, PMEM_CACHE_FLUSH, &region);
+    if (IOCTL_FAILED == err)
+    {   
+        LOGE("PMEM_CACHE_FLUSH offset 0x%08x, size %d failed!\n", offset, length);
+    }
+}
+
+
+
+/* No clean & INV function in ICS */
+#if 0
+void pmem_cache_clean(int fd, unsigned int offset, unsigned int length) {
+    pmem_region region = { 0, 0 };
+    int         err = -1; 
+
+    if (fd < 0 || offset == 0 || length == 0) {
+        LOGE("pmem_cache_clean: invalide argument\n");
+        return;
+    }   
+
+    region.offset = offset;
+    region.len = length;
+    err = ioctl(fd, PMEM_CACHE_CLEAN, &region);
+    if (IOCTL_FAILED == err)
+    {   
+        LOGE("PMEM_CACHE_CLEAN offset 0x%08x, size %d failed!\n", offset, length);
+    }
+}
+
+
+void pmem_cache_inv(int fd, unsigned int offset, unsigned int length) {
+    pmem_region region = { 0, 0 };
+    int         err = -1; 
+
+    if (fd < 0 || offset == 0 || length == 0) {
+        LOGE("pmem_cache_inv: invalide argument\n");
+        return;
+    }   
+
+    region.offset = offset;
+    region.len = length;
+    err = ioctl(fd, PMEM_CACHE_INV, &region);
+    if (IOCTL_FAILED == err)
+    {   
+        LOGE("PMEM_CACHE_INV offset 0x%08x, size %d failed!\n", offset, length);
+    }
+}
+#endif
diff --git a/system/core/libcutils/sched_policy.c b/gb/12055-master/driveronly_mp_rom/system/core/libcutils/sched_policy.c
index d20d217..0d9a815 100644
--- a/system/core/libcutils/sched_policy.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libcutils/sched_policy.c
@@ -49,6 +49,9 @@ static inline SchedPolicy _policy(SchedPolicy p)
   #define SCHED_BATCH 3
 #endif
 
+#ifndef ERTGROUP
+#define ERTGROUP 199
+#endif
 #define POLICY_DEBUG 0
 
 #define CAN_SET_SP_SYSTEM 0 // non-zero means to implement set_sched_policy(tid, SP_SYSTEM)
@@ -99,6 +102,10 @@ static int add_tid_to_cgroup(int tid, SchedPolicy policy)
     char *ptr = end;
     *ptr = '\0';
     while (tid > 0) {
+        if(ptr < text){// to prevent from stack corruption
+            SLOGE("add_tid_to_cgroup failed; tid is wild\n");
+            return -1;
+        }
         *--ptr = '0' + (tid % 10);
         tid = tid / 10;
     }
@@ -108,8 +115,12 @@ static int add_tid_to_cgroup(int tid, SchedPolicy policy)
          * If the thread is in the process of exiting,
          * don't flag an error
          */
+        SLOGW("add_tid_to_cgroup failed to write '%s', len = %d, fd = %d, err = %d\n", 
+                ptr, end-ptr, fd, errno); // debug purpose
         if (errno == ESRCH)
                 return 0;
+         if(errno == ERTGROUP)	/* set rt group error*/
+                return 0;
         SLOGW("add_tid_to_cgroup failed to write '%s' (%s); policy=%d\n",
               ptr, strerror(errno), policy);
         return -1;
@@ -311,8 +322,10 @@ int set_sched_policy(int tid, SchedPolicy policy)
 
     if (__sys_supports_schedgroups) {
         if (add_tid_to_cgroup(tid, policy)) {
-            if (errno != ESRCH && errno != ENOENT)
+            if (errno != ESRCH && errno != ENOENT) {
+                SLOGE("add_tid_to_cgroup failed, err = %d\n", errno); // debug purpose
                 return -errno;
+            }
         }
     } else {
         struct sched_param param;
diff --git a/system/core/libdiskconfig/config_mbr.c b/gb/12055-master/driveronly_mp_rom/system/core/libdiskconfig/config_mbr.c
index b89d382..2829fb8 100644
--- a/system/core/libdiskconfig/config_mbr.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libdiskconfig/config_mbr.c
@@ -31,6 +31,7 @@ static void
 cfg_pentry(struct pc_partition *pentry, uint8_t status, uint8_t type,
            uint32_t start, uint32_t len)
 {
+   ALOGI("Enter cfg_pentry()") ;
     if (len > 0) {
         /* seems that somes BIOSens can get wedged on boot while verifying
          * the mbr if these are 0 */
@@ -74,15 +75,19 @@ mk_pri_pentry(struct disk_info *dinfo, struct part_info *pinfo, int pnum,
     struct write_list *item;
     struct pc_partition *pentry;
 
+	ALOGI("Enter mk_pri_entry()") ;
+
     if (pnum >= PC_NUM_BOOT_RECORD_PARTS) {
         ALOGE("Maximum number of primary partition exceeded.");
         return NULL;
     }
 
+	ALOGI("mk_pri_entry() : calls alloc_wl()") ;
     if (!(item = alloc_wl(sizeof(struct pc_partition)))) {
         ALOGE("Unable to allocate memory for partition entry.");
         return NULL;
     }
+	ALOGI("mk_pri_entry() : exits alloc_wl()") ;
 
     {
         /* DO NOT DEREFERENCE */
@@ -109,29 +114,35 @@ mk_pri_pentry(struct disk_info *dinfo, struct part_info *pinfo, int pnum,
             len_lba = dinfo->num_lba - *lba;
         }
 
+		ALOGI("mk_pri_entry() : calls cfg_pentry(PC_PART_ACTIVE)") ;
         cfg_pentry(pentry, ((pinfo->flags & PART_ACTIVE_FLAG) ?
                             PC_PART_ACTIVE : PC_PART_NORMAL),
                    pinfo->type, *lba, (uint32_t)len_lba);
+		ALOGI("mk_pri_entry() : calls cfg_pentry(PC_PART_ACTIVE)") ;
 
         pinfo->start_lba = *lba;
         *lba += (uint32_t)len_lba;
     } else {
         /* this should be made an extended partition, and should take
          * up the rest of the disk as a primary partition */
+        ALOGI("mk_pri_entry() : calls cfg_pentry(PC_PART_TYPE_EXTENDED)") ;
         cfg_pentry(pentry, PC_PART_NORMAL, PC_PART_TYPE_EXTENDED,
                    *lba, dinfo->num_lba - *lba);
+	    ALOGI("mk_pri_entry() : exits cfg_pentry(PC_PART_TYPE_EXTENDED)") ;
 
         /* note that we do not update the *lba because we now have to
          * create a chain of extended partition tables, and first one is at
          * *lba */
     }
 
+	ALOGI("Exit mk_pri_entry()") ;
+
     return item;
 }
 
 
 /* This function configures an extended boot record at the beginning of an
- * extended partition. This creates a logical partition and a pointer to
+ * extended partition. This creates a ALOGIcal partition and a pointer to
  * the next EBR.
  *
  * ext_lba == The start of the toplevel extended partition (pointed to by the
@@ -145,13 +156,15 @@ mk_ext_pentry(struct disk_info *dinfo, struct part_info *pinfo, uint32_t *lba,
     struct pc_boot_record *ebr;
     uint32_t len; /* in lba units */
 
+   ALOGI("mk_ext_pentry() : calls alloc_wl()") ;
     if (!(item = alloc_wl(sizeof(struct pc_boot_record)))) {
         ALOGE("Unable to allocate memory for EBR.");
         return NULL;
     }
+	ALOGI("mk_ext_pentry() : exit alloc_wl()") ;
 
     /* we are going to write the ebr at the current LBA, and then bump the
-     * lba counter since that is where the logical data partition will start */
+     * lba counter since that is where the ALOGIcal data partition will start */
     item->offset = ((loff_t)(*lba)) * dinfo->sect_size;
     (*lba)++;
 
@@ -159,9 +172,13 @@ mk_ext_pentry(struct disk_info *dinfo, struct part_info *pinfo, uint32_t *lba,
     memset(ebr, 0, sizeof(struct pc_boot_record));
     ebr->mbr_sig = PC_BIOS_BOOT_SIG;
 
-    if (pinfo->len_kb != (uint32_t)-1)
+    if (pinfo->len_kb != (uint32_t)-1) {
+	  ALOGI("mk_ext_pentry() : calls kb_to_lba(pinfo->len_kb, dinfo->sect_size)") ;
         len = kb_to_lba(pinfo->len_kb, dinfo->sect_size);
-    else {
+		ALOGI("mk_ext_pentry() : exits kb_to_lba(pinfo->len_kb, dinfo->sect_size)") ;
+    }
+	else {
+		ALOGI("mk_ext_pentry() : pinfo->len_kb == (uint32_t)-1") ;
         if (pnext) {
             ALOGE("Only the last partition can be specified to fill the disk "
                  "(name = '%s')", pinfo->name);
@@ -175,8 +192,10 @@ mk_ext_pentry(struct disk_info *dinfo, struct part_info *pinfo, uint32_t *lba,
                        ((uint64_t)1024));
     }
 
+	ALOGI("mk_ext_pentry() : calls cfg_pentry(pinfo->type)") ;
     cfg_pentry(&ebr->ptable[PC_EBR_LOGICAL_PART], PC_PART_NORMAL,
                pinfo->type, 1, len);
+	ALOGI("mk_ext_pentry() : exits cfg_pentry(pinfo->type)") ;
 
     pinfo->start_lba = *lba;
     *lba += len;
@@ -192,12 +211,18 @@ mk_ext_pentry(struct disk_info *dinfo, struct part_info *pinfo, uint32_t *lba,
          * of the top-level extended partition */
         uint32_t next_start_lba = *lba - ext_lba;
         uint32_t next_len_lba;
-        if (pnext->len_kb != (uint32_t)-1)
+        if (pnext->len_kb != (uint32_t)-1) {
+			ALOGI("mk_ext_pentry() : calls kb_to_lba(pnext->len)") ;
             next_len_lba = 1 + kb_to_lba(pnext->len_kb, dinfo->sect_size);
+			ALOGI("mk_ext_pentry() : exits kb_to_lba(pnext->len)") ;
+        }
         else
             next_len_lba = dinfo->num_lba - *lba;
+
+		ALOGI("mk_ext_pentry() : calls cfg_pentry(PC_PART_TYPE_EXTENDED)") ;
         cfg_pentry(&ebr->ptable[PC_EBR_NEXT_PTR_PART], PC_PART_NORMAL,
                    PC_PART_TYPE_EXTENDED, next_start_lba, next_len_lba);
+		ALOGI("mk_ext_pentry() : exits cfg_pentry(PC_PART_TYPE_EXTENDED)") ;
     }
 
     return item;
@@ -219,6 +244,8 @@ config_mbr(struct disk_info *dinfo)
     int cnt = 0;
     int extended = 0;
 
+	ALOGI("Enter config_mbr()");
+
     if (!dinfo->part_lst)
         return NULL;
 
@@ -230,12 +257,17 @@ config_mbr(struct disk_info *dinfo)
             if (cnt + 1 < dinfo->num_parts) {
                 extended = 1;
                 ext_lba = cur_lba;
-                if ((temp_wr = mk_pri_pentry(dinfo, NULL, cnt, &cur_lba)))
+				ALOGI("config_mbr() : call mk_pri_pentry(dinfo, NULL...)") ;
+                if ((temp_wr = mk_pri_pentry(dinfo, NULL, cnt, &cur_lba))) {
+					ALOGI("config_mbr() : call mk_pri_pentry(dinfo, NULL...) : calls wlist_add()") ;
                     wlist_add(&wr_list, temp_wr);
-                else {
+					ALOGI("config_mbr() : call mk_pri_pentry(dinfo, NULL...) : exit wlist_add()") ;
+                }
+				else {
                     ALOGE("Cannot create primary extended partition.");
                     goto fail;
                 }
+				ALOGI("config_mbr() : exit mk_pri_pentry(dinfo, NULL...)") ;
             }
         }
 
@@ -248,16 +280,25 @@ config_mbr(struct disk_info *dinfo)
                 goto nospace;
         }
 
-        if (!extended)
+        if (!extended) {
+			ALOGI("config_mbr() : !extended") ;
+			ALOGI("config_mbr() : call mk_pri_pentry(dinfo, pinfo, cnt, ..)") ;
             temp_wr = mk_pri_pentry(dinfo, pinfo, cnt, &cur_lba);
+			ALOGI("config_mbr() : exit mk_pri_pentry(dinfo, pinfo, cnt, ..)") ;
+        }
         else {
             struct part_info *pnext;
             pnext = cnt + 1 < dinfo->num_parts ? &dinfo->part_lst[cnt+1] : NULL;
+			ALOGI("config_mbr() : calls mk_ext_pentry(dinfo, pinfo, &cur_lba, ext_lba, pnext)") ;
             temp_wr = mk_ext_pentry(dinfo, pinfo, &cur_lba, ext_lba, pnext);
+			ALOGI("config_mbr() : exits mk_ext_pentry(dinfo, pinfo, &cur_lba, ext_lba, pnext)") ;
         }
 
-        if (temp_wr)
+        if (temp_wr) {
+ 		    ALOGI("config_mbr() : calls wlist_add()") ;
             wlist_add(&wr_list, temp_wr);
+			ALOGI("config_mbr() : exits wlist_add()") ;
+        }
         else {
             ALOGE("Cannot create partition %d (%s).", cnt, pinfo->name);
             goto fail;
@@ -269,10 +310,12 @@ config_mbr(struct disk_info *dinfo)
         struct part_info blank;
         cur_lba = 0;
         memset(&blank, 0, sizeof(struct part_info));
+		ALOGI("config_mbr() : for loop calls mk_pri_pentry()") ;
         if (!(temp_wr = mk_pri_pentry(dinfo, &blank, cnt, &cur_lba))) {
             ALOGE("Cannot create blank partition %d.", cnt);
             goto fail;
         }
+		ALOGI("config_mbr() : calls wlist_add()") ;
         wlist_add(&wr_list, temp_wr);
     }
 
diff --git a/system/core/libdiskconfig/diskconfig.c b/gb/12055-master/driveronly_mp_rom/system/core/libdiskconfig/diskconfig.c
index d5425de..13cb975 100644
--- a/system/core/libdiskconfig/diskconfig.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libdiskconfig/diskconfig.c
@@ -248,10 +248,15 @@ sync_ptable(int fd)
        return -1;
     }
 
-    if (S_ISBLK(stat.st_mode) && ((rv = ioctl(fd, BLKRRPART, NULL)) < 0)) {
-        ALOGE("Could not re-read partition table. REBOOT!. (errno=%d)", errno);
-        return -1;
+	ALOGI("sync_ptable() : S_ISBLK") ;
+    if (S_ISBLK(stat.st_mode)) {
+		ALOGI("sync_ptable() : ioctl(BLKRRPART)") ;
+		if((rv = ioctl(fd, BLKRRPART, NULL)) < 0) {
+        	ALOGE("Could not re-read partition table. REBOOT!. (errno=%d)", errno);
+        	return -1;
+		}
     }
+	ALOGI("sync_ptable() : after ioctl(BLKRRPART)") ;
 
     return 0;
 }
@@ -277,31 +282,39 @@ validate(struct disk_info *dinfo)
     int cnt;
     struct stat stat;
 
+	ALOGI("Enter validate()");
+
     if (!dinfo)
         return -1;
 
+	ALOGI("Enter validate() : open dinfo->device");
     if ((fd = open(dinfo->device, O_RDWR)) < 0) {
         ALOGE("Cannot open device '%s' (errno=%d)", dinfo->device, errno);
         return -1;
     }
+	ALOGI("Enter validate() : after open");
 
+	ALOGI("Enter validate() : fstat(fd..)");
     if (fstat(fd, &stat)) {
         ALOGE("Cannot stat file '%s', errno=%d.", dinfo->device, errno);
         goto fail;
     }
-
+	ALOGI("Enter validate() : after fstat(..)");
 
     /* XXX: Some of the code below is kind of redundant and should probably
      * be refactored a little, but it will do for now. */
 
     /* Verify that we can operate on the device that was requested.
      * We presently only support block devices and regular file images. */
+    ALOGI("Enter validate() : call S_ISBLK()");
     if (S_ISBLK(stat.st_mode)) {
         /* get the sector size and make sure we agree */
+		ALOGI("Enter validate() : calls ioctl(BLKSSZGET)");
         if (ioctl(fd, BLKSSZGET, &sect_sz) < 0) {
             ALOGE("Cannot get sector size (errno=%d)", errno);
             goto fail;
         }
+		ALOGI("Enter validate() : after ioctl(BLKSSZET)");
 
         if (!sect_sz || sect_sz != dinfo->sect_size) {
             ALOGE("Device sector size is zero or sector sizes do not match!");
@@ -310,10 +323,12 @@ validate(struct disk_info *dinfo)
 
         /* allow the user override the "disk size" if they provided num_lba */
         if (!dinfo->num_lba) {
+			ALOGI("Enter validate() : calls ioctl(BLKGETSIZE64)");
             if (ioctl(fd, BLKGETSIZE64, &disk_size) < 0) {
                 ALOGE("Could not get block device size (errno=%d)", errno);
                 goto fail;
             }
+			ALOGI("Enter validate() : after ioctl(BLKGETSIZE64)");
             /* XXX: we assume that the disk has < 2^32 sectors :-) */
             dinfo->num_lba = (uint32_t)(disk_size / (uint64_t)dinfo->sect_size);
         } else
@@ -370,15 +385,18 @@ validate(struct disk_info *dinfo)
     }
 
     /* only matters for disks, not files */
+	ALOGI("Enter validate() : calls S_ISBLK(stat.st_mode())");
     if (S_ISBLK(stat.st_mode) && total_size > disk_size) {
         ALOGE("Total requested size of partitions (%llu) is greater than disk "
              "size (%llu).", total_size, disk_size);
         goto fail;
     }
+	ALOGI("Enter validate() : after calls S_ISBLK(stat.st_mode())");
 
     return fd;
 
 fail:
+	ALOGI("Exit validate()");
     close(fd);
     return -1;
 }
@@ -389,12 +407,16 @@ validate_and_config(struct disk_info *dinfo, int *fd, struct write_list **lst)
     *lst = NULL;
     *fd = -1;
 
+	ALOGE("validate_and_config() : calls validate()");
     if ((*fd = validate(dinfo)) < 0)
         return 1;
+	ALOGE("validate_and_config() : exit validate()");
 
     switch (dinfo->scheme) {
         case PART_SCHEME_MBR:
+			ALOGE("validate_and_config() : calls config_mbr()");
             *lst = config_mbr(dinfo);
+			ALOGE("validate_and_config() : exit config_mbr()");
             return *lst == NULL;
         case PART_SCHEME_GPT:
             /* not supported yet */
@@ -403,6 +425,7 @@ validate_and_config(struct disk_info *dinfo, int *fd, struct write_list **lst)
             break;
     }
 
+	ALOGE("validate_and_config() : close fd");
     close(*fd);
     *lst = NULL;
     return 1;
@@ -437,22 +460,31 @@ apply_disk_config(struct disk_info *dinfo, int test)
     struct write_list *wr_lst = NULL;
     int rv;
 
+	ALOGI("Call validate_and_config()");
     if (validate_and_config(dinfo, &fd, &wr_lst) != 0) {
         ALOGE("Configuration is invalid.");
         goto fail;
     }
+	ALOGI("Exit validate_and_config()");
 
+	ALOGI("Call wlist_commit()");
     if ((rv = wlist_commit(fd, wr_lst, test)) >= 0)
         rv = test ? 0 : sync_ptable(fd);
+	ALOGI("Exit wlist_commit()");
 
+	ALOGI("apply_disk_config() : close fd");
     close(fd);
+	ALOGI("apply_disk_config() : calls wlist_free()");
     wlist_free(wr_lst);
     return rv;
 
 fail:
+	ALOGI("apply_disk_config() : fail exit, calls close(fd)");	
     close(fd);
-    if (wr_lst)
+    if (wr_lst) {
+		ALOGI("apply_disk_config() : fail exit, calls wlist_free()");	
         wlist_free(wr_lst);
+    }
     return 1;
 }
 
diff --git a/system/core/libion/Android.mk b/gb/12055-master/driveronly_mp_rom/system/core/libion/Android.mk
index 5121fee..85f7320 100644
--- a/system/core/libion/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libion/Android.mk
@@ -7,9 +7,9 @@ LOCAL_MODULE_TAGS := optional
 LOCAL_SHARED_LIBRARIES := liblog
 include $(BUILD_SHARED_LIBRARY)
 
-include $(CLEAR_VARS)
-LOCAL_SRC_FILES := ion.c ion_test.c
-LOCAL_MODULE := iontest
-LOCAL_MODULE_TAGS := optional tests
-LOCAL_SHARED_LIBRARIES := liblog
-include $(BUILD_EXECUTABLE)
+#include $(CLEAR_VARS)
+#LOCAL_SRC_FILES := ion.c ion_test.c
+#LOCAL_MODULE := iontest
+#LOCAL_MODULE_TAGS := optional tests
+#LOCAL_SHARED_LIBRARIES := liblog
+#include $(BUILD_EXECUTABLE)
diff --git a/system/core/libion/ion.c b/gb/12055-master/driveronly_mp_rom/system/core/libion/ion.c
index 020c35b..ff9bf16 100644
--- a/system/core/libion/ion.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libion/ion.c
@@ -32,7 +32,7 @@
 
 int ion_open()
 {
-        int fd = open("/dev/ion", O_RDWR);
+        int fd = open("/dev/ion", O_RDONLY);
         if (fd < 0)
                 ALOGE("open /dev/ion failed!\n");
         return fd;
@@ -72,6 +72,41 @@ int ion_alloc(int fd, size_t len, size_t align, unsigned int heap_mask,
         return ret;
 }
 
+int ion_alloc_mm(int fd, size_t len, size_t align, unsigned int flags,
+              struct ion_handle **handle)
+{
+        int ret;
+        struct ion_allocation_data data = {
+                .len = len,
+                .align = align,
+                .flags = flags,
+                .heap_mask = ION_HEAP_MULTIMEDIA_MASK
+        };
+
+        ret = ion_ioctl(fd, ION_IOC_ALLOC, &data);
+        if (ret < 0)
+                return ret;
+        *handle = data.handle;
+        return ret;
+}
+
+int ion_alloc_syscontig(int fd, size_t len, size_t align, unsigned int flags, struct ion_handle **handle)
+{
+        int ret;
+        struct ion_allocation_data data = {
+                .len = len,
+                .align = align,
+                .flags = flags,
+                .heap_mask = ION_HEAP_SYSTEM_CONTIG_MASK
+        };
+
+        ret = ion_ioctl(fd, ION_IOC_ALLOC, &data);
+        if (ret < 0)
+                return ret;
+        *handle = data.handle;
+        return ret;
+}
+
 int ion_free(int fd, struct ion_handle *handle)
 {
         struct ion_handle_data data = {
@@ -87,7 +122,7 @@ int ion_map(int fd, struct ion_handle *handle, size_t length, int prot,
                 .handle = handle,
         };
 
-        int ret = ion_ioctl(fd, ION_IOC_MAP, &data);
+        int ret = ion_ioctl(fd, ION_IOC_SHARE, &data);
         if (ret < 0)
                 return ret;
         *map_fd = data.fd;
@@ -103,6 +138,16 @@ int ion_map(int fd, struct ion_handle *handle, size_t length, int prot,
         return ret;
 }
 
+void* ion_mmap(int fd, void *addr, size_t length, int prot, int flags, int share_fd, off_t offset)
+{
+    return mmap(addr, length, prot, flags, share_fd, offset);
+}
+
+int ion_munmap(int fd, void *addr, size_t length)
+{
+    return munmap(addr, length);
+}
+
 int ion_share(int fd, struct ion_handle *handle, int *share_fd)
 {
         int map_fd;
@@ -134,6 +179,11 @@ int ion_alloc_fd(int fd, size_t len, size_t align, unsigned int heap_mask,
 	return ret;
 }
 
+int ion_share_close(int fd, int share_fd)
+{
+    return close(share_fd);
+}
+
 int ion_import(int fd, int share_fd, struct ion_handle **handle)
 {
         struct ion_fd_data data = {
@@ -147,6 +197,14 @@ int ion_import(int fd, int share_fd, struct ion_handle **handle)
         return ret;
 }
 
+int ion_custom_ioctl(int fd, unsigned int cmd, void* arg)
+{
+    struct ion_custom_data custom_data;
+    custom_data.cmd = cmd;
+    custom_data.arg = (unsigned long) arg;
+    return ioctl(fd, ION_IOC_CUSTOM, &custom_data);
+}
+
 int ion_sync_fd(int fd, int handle_fd)
 {
     struct ion_fd_data data = {
diff --git a/system/core/liblog/Android.mk b/gb/12055-master/driveronly_mp_rom/system/core/liblog/Android.mk
index be5cec2..b3310ab 100644
--- a/system/core/liblog/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/system/core/liblog/Android.mk
@@ -47,6 +47,7 @@ LOCAL_MODULE := liblog
 LOCAL_SRC_FILES := $(liblog_host_sources)
 LOCAL_LDLIBS := -lpthread
 LOCAL_CFLAGS := -DFAKE_LOG_DEVICE=1
+LOCAL_WHOLE_STATIC_LIBRARIES := libxlog
 include $(BUILD_HOST_STATIC_LIBRARY)
 
 include $(CLEAR_VARS)
@@ -62,6 +63,7 @@ LOCAL_MODULE := lib64log
 LOCAL_SRC_FILES := $(liblog_host_sources)
 LOCAL_LDLIBS := -lpthread
 LOCAL_CFLAGS := -DFAKE_LOG_DEVICE=1 -m64
+LOCAL_WHOLE_STATIC_LIBRARIES := libxlog
 include $(BUILD_HOST_STATIC_LIBRARY)
 
 
@@ -70,6 +72,7 @@ include $(BUILD_HOST_STATIC_LIBRARY)
 include $(CLEAR_VARS)
 LOCAL_MODULE := liblog
 LOCAL_SRC_FILES := $(liblog_sources)
+LOCAL_WHOLE_STATIC_LIBRARIES := libxlog
 include $(BUILD_STATIC_LIBRARY)
 
 include $(CLEAR_VARS)
diff --git a/system/core/liblog/logd_write.c b/gb/12055-master/driveronly_mp_rom/system/core/liblog/logd_write.c
index b91de52..a7ead9f 100644
--- a/system/core/liblog/logd_write.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/liblog/logd_write.c
@@ -28,6 +28,8 @@
 #include <cutils/logger.h>
 #include <cutils/logd.h>
 #include <cutils/log.h>
+#include <cutils/alelog.h>
+#include <cutils/xlog.h>
 
 #define LOG_BUF_SIZE	1024
 
@@ -43,7 +45,7 @@
 #endif
 
 static int __write_to_log_init(log_id_t, struct iovec *vec, size_t nr);
-static int (*write_to_log)(log_id_t, struct iovec *vec, size_t nr) = __write_to_log_init;
+int (*write_to_log)(log_id_t, struct iovec *vec, size_t nr) __attribute__((visibility ("hidden"))) = __write_to_log_init;
 #ifdef HAVE_PTHREADS
 static pthread_mutex_t log_init_lock = PTHREAD_MUTEX_INITIALIZER;
 #endif
@@ -140,9 +142,24 @@ int __android_log_write(int prio, const char *tag, const char *msg)
 
     /* XXX: This needs to go! */
     if (!strcmp(tag, "HTC_RIL") ||
+        #ifdef MTK_DT_SUPPORT
+        !strncmp(tag, "RIL3", 4) ||
+        !strcmp(tag, "AT3") ||
+        !strcmp(tag, "MUXD3") || 
+        #endif
+        #ifdef EVDO_DT_SUPPORT
+        !strcmp(tag, "VIA_RIL") ||
+        !strcmp(tag, "VIA_AT") ||
+        !strcmp(tag, "VIA_RILC") || 
+        !strcmp(tag, "VIA_RILD") || 
+        #endif /* EVDO_DT_SUPPORT */
+        !strcmp(tag, "RILMD2") ||
+        !strcmp(tag, "ATMD2") ||
+        !strcmp(tag, "MUXDMD2") || 
         !strncmp(tag, "RIL", 3) || /* Any log tag with "RIL" as the prefix */
         !strncmp(tag, "IMS", 3) || /* Any log tag with "IMS" as the prefix */
         !strcmp(tag, "AT") ||
+        !strcmp(tag, "MUXD") || 
         !strcmp(tag, "GSM") ||
         !strcmp(tag, "STK") ||
         !strcmp(tag, "CDMA") ||
@@ -203,6 +220,11 @@ int __android_log_print(int prio, const char *tag, const char *fmt, ...)
     va_list ap;
     char buf[LOG_BUF_SIZE];
 
+#if !defined(FAKE_LOG_DEVICE)
+    if(!xlogf_native_tag_is_on(tag, prio)) 
+        return -1;
+#endif
+
     va_start(ap, fmt);
     vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);
     va_end(ap);
@@ -215,6 +237,11 @@ int __android_log_buf_print(int bufID, int prio, const char *tag, const char *fm
     va_list ap;
     char buf[LOG_BUF_SIZE];
 
+#if !defined(FAKE_LOG_DEVICE)
+    if(!xlogf_native_tag_is_on(tag, prio)) 
+        return -1;
+#endif
+
     va_start(ap, fmt);
     vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);
     va_end(ap);
diff --git a/system/core/liblog/logprint.c b/gb/12055-master/driveronly_mp_rom/system/core/liblog/logprint.c
index 6fac84b..0dc0eec 100644
--- a/system/core/liblog/logprint.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/liblog/logprint.c
@@ -29,6 +29,10 @@
 #include <cutils/logd.h>
 #include <cutils/logprint.h>
 
+int g_log_ts = 0;
+
+extern int ale_b64_encode(unsigned char const *src, int srclength, char *target, int targsize);
+
 typedef struct FilterInfo_t {
     char *mTag;
     android_LogPriority mPri;
@@ -350,11 +354,37 @@ static inline char * strip_end(char *str)
 int android_log_processLogBuffer(struct logger_entry *buf,
                                  AndroidLogEntry *entry)
 {
+    size_t tag_len;
     entry->tv_sec = buf->sec;
     entry->tv_nsec = buf->nsec;
+    entry->priority = (buf->msg[0] & (~LOGGER_ALE_MASK));
+    entry->msg_type = (buf->msg[0] & LOGGER_ALE_MASK);
     entry->pid = buf->pid;
     entry->tid = buf->tid;
 
+    switch (entry->msg_type) {
+    case LOGGER_ALE_MSG_K:
+        entry->tag = "ALEK";
+        tag_len = 3;
+	entry->messageLen = buf->len - 1;
+	entry->message = buf->msg + 1;
+        break;
+
+    case LOGGER_ALE_MSG_J:
+        entry->tag = "ALEJ";
+        tag_len = 3;
+	entry->messageLen = buf->len - 1;
+	entry->message = buf->msg + 1;
+        break;
+
+    case LOGGER_ALE_MSG_N:
+        entry->tag = "ALEN";
+        tag_len = 3;
+	entry->messageLen = buf->len - 1;
+	entry->message = buf->msg + 1;
+        break;
+
+    default: {
     /*
      * format: <priority:1><tag:N>\0<message:N>\0
      *
@@ -398,11 +428,14 @@ int android_log_processLogBuffer(struct logger_entry *buf,
         buf->msg[msgEnd] = '\0';
     }
 
-    entry->priority = buf->msg[0];
+		    //entry->priority = buf->msg[0];
     entry->tag = buf->msg + 1;
     entry->message = buf->msg + msgStart;
-    entry->messageLen = msgEnd - msgStart;
+		    entry->messageLen = msgEnd - msgStart + 1;
+        break;
+    }
 
+    }
     return 0;
 }
 
@@ -604,6 +637,7 @@ int android_log_processBinaryLogBuffer(struct logger_entry *buf,
     unsigned int tagIndex;
     const unsigned char* eventData;
 
+    entry->msg_type = LOGGER_ALE_MSG_RAW;
     entry->tv_sec = buf->sec;
     entry->tv_nsec = buf->nsec;
     entry->priority = ANDROID_LOG_INFO;
@@ -680,9 +714,9 @@ int android_log_processBinaryLogBuffer(struct logger_entry *buf,
      * Terminate the buffer.  The NUL byte does not count as part of
      * entry->messageLen.
      */
-    *outBuf = '\0';
+    *outBuf++ = '\0';
     entry->messageLen = outBuf - messageBuf;
-    assert(entry->messageLen == (messageBufLen-1) - outRemaining);
+    assert(entry->messageLen == messageBufLen - outRemaining);
 
     entry->message = messageBuf;
 
@@ -717,6 +751,9 @@ char *android_log_formatLogLine (
 
     priChar = filterPriToChar(entry->priority);
 
+/* make android log timestamp same with printk { */
+	char time_suffix_buf[16];
+
     /*
      * Get the current date/time in pretty form
      *
@@ -726,6 +763,7 @@ char *android_log_formatLogLine (
      * in the time stamp.  Don't use forward slashes, parenthesis,
      * brackets, asterisks, or other special chars here.
      */
+     if(g_log_ts == 0) {
 #if defined(HAVE_LOCALTIME_R)
     ptm = localtime_r(&(entry->tv_sec), &tmBuf);
 #else
@@ -733,7 +771,13 @@ char *android_log_formatLogLine (
 #endif
     //strftime(timeBuf, sizeof(timeBuf), "%Y-%m-%d %H:%M:%S", ptm);
     strftime(timeBuf, sizeof(timeBuf), "%m-%d %H:%M:%S", ptm);
+	 	sprintf(time_suffix_buf, ".%03ld", entry->tv_nsec / 1000000);
+	 } else if(g_log_ts == 1) {
+	 	sprintf(timeBuf, "%5lu.%06lu", entry->tv_sec, entry->tv_nsec / 1000);
+		time_suffix_buf[0] = 0;
+	 }
 
+/* } */
     /*
      * Construct a buffer containing the log header and log message.
      */
@@ -765,22 +809,22 @@ char *android_log_formatLogLine (
             break;
         case FORMAT_TIME:
             prefixLen = snprintf(prefixBuf, sizeof(prefixBuf),
-                "%s.%03ld %c/%-8s(%5d): ", timeBuf, entry->tv_nsec / 1000000,
+                "%s%s %c/%-8.64s(%5d): ", timeBuf, time_suffix_buf,
                 priChar, entry->tag, entry->pid);
             strcpy(suffixBuf, "\n");
             suffixLen = 1;
             break;
         case FORMAT_THREADTIME:
             prefixLen = snprintf(prefixBuf, sizeof(prefixBuf),
-                "%s.%03ld %5d %5d %c %-8s: ", timeBuf, entry->tv_nsec / 1000000,
+                "%s%s %5d %5d %c %-8.64s: ", timeBuf, time_suffix_buf,
                 entry->pid, entry->tid, priChar, entry->tag);
             strcpy(suffixBuf, "\n");
             suffixLen = 1;
             break;
         case FORMAT_LONG:
             prefixLen = snprintf(prefixBuf, sizeof(prefixBuf),
-                "[ %s.%03ld %5d:%5d %c/%-8s ]\n",
-                timeBuf, entry->tv_nsec / 1000000, entry->pid,
+                "[ %s%s %5d:%p %c/%-8.64s ]\n",
+                timeBuf, time_suffix_buf, entry->pid,
                 entry->tid, priChar, entry->tag);
             strcpy(suffixBuf, "\n\n");
             suffixLen = 2;
@@ -805,6 +849,31 @@ char *android_log_formatLogLine (
     if(suffixLen >= sizeof(suffixBuf))
         suffixLen = sizeof(suffixBuf) - 1;
 
+    /* Process ALE message type */
+    const char *msg = NULL;
+    size_t msg_len = 0;
+    char msg_buf[LOGGER_ALE_MSG_SIZE * 2];
+
+    switch (entry->msg_type) {
+    case LOGGER_ALE_MSG_RAW:
+        msg = entry->message;
+        msg_len = entry->messageLen - 1;
+        break;
+
+    case LOGGER_ALE_MSG_K:
+    case LOGGER_ALE_MSG_J:
+    case LOGGER_ALE_MSG_N:
+        msg = msg_buf;
+	msg_len = ale_b64_encode((u_char *)entry->message, entry->messageLen, msg_buf, sizeof(msg_buf));
+        break;
+
+    default:
+        strcpy(msg_buf, "Bug, Unknown message type");
+        msg = msg_buf;
+        msg_len = strlen(msg_buf);
+        break;
+    }
+
     /* the following code is tragically unreadable */
 
     size_t numLines;
@@ -817,21 +886,21 @@ char *android_log_formatLogLine (
         // we're just wrapping message with a header/footer
         numLines = 1;
     } else {
-        pm = entry->message;
+        pm = msg;
         numLines = 0;
 
         // The line-end finding here must match the line-end finding
         // in for ( ... numLines...) loop below
-        while (pm < (entry->message + entry->messageLen)) {
+        while (pm < (msg + msg_len)) {
             if (*pm++ == '\n') numLines++;
         }
         // plus one line for anything not newline-terminated at the end
-        if (pm > entry->message && *(pm-1) != '\n') numLines++;
+        if (pm > msg && *(pm-1) != '\n') numLines++;
     }
 
     // this is an upper bound--newlines in message may be counted
     // extraneously
-    bufferSize = (numLines * (prefixLen + suffixLen)) + entry->messageLen + 1;
+    bufferSize = (numLines * (prefixLen + suffixLen)) + msg_len + 1;
 
     if (defaultBufferSize >= bufferSize) {
         ret = defaultBuffer;
@@ -846,23 +915,23 @@ char *android_log_formatLogLine (
     ret[0] = '\0';       /* to start strcat off */
 
     p = ret;
-    pm = entry->message;
+    pm = msg;
 
     if (prefixSuffixIsHeaderFooter) {
         strcat(p, prefixBuf);
         p += prefixLen;
-        strncat(p, entry->message, entry->messageLen);
-        p += entry->messageLen;
+        strncat(p, msg, msg_len);
+        p += msg_len;
         strcat(p, suffixBuf);
         p += suffixLen;
     } else {
-        while(pm < (entry->message + entry->messageLen)) {
+        while(pm < (msg + msg_len)) {
             const char *lineStart;
             size_t lineLen;
             lineStart = pm;
 
             // Find the next end-of-line in message
-            while (pm < (entry->message + entry->messageLen)
+            while (pm < (msg + msg_len)
                     && *pm != '\n') pm++;
             lineLen = pm - lineStart;
 
diff --git a/system/core/libnetutils/dhcp_utils.c b/gb/12055-master/driveronly_mp_rom/system/core/libnetutils/dhcp_utils.c
index d0ca90a..f73354e 100644
--- a/system/core/libnetutils/dhcp_utils.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libnetutils/dhcp_utils.c
@@ -24,6 +24,18 @@
 #include <netinet/in.h>
 
 #include <cutils/properties.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#ifdef ANDROID
+#define LOG_TAG "DhcpUtils"
+#include <cutils/log.h>
+#else
+#include <stdio.h>
+#include <string.h>
+#define ALOGD printf
+#define ALOGE printf
+#endif
 
 static const char DAEMON_NAME[]        = "dhcpcd";
 static const char DAEMON_PROP_NAME[]   = "init.svc.dhcpcd";
@@ -34,6 +46,16 @@ static const int NAP_TIME = 200;   /* wait for 200ms at a time */
                                   /* when polling for property values */
 static const char DAEMON_NAME_RENEW[]  = "iprenew";
 static char errmsg[100];
+static char errmsgv6[100];
+
+
+static const char DHCPv6_DAEMON_NAME[]        = "dhcp6c";
+static const char DHCPv6DNS_DAEMON_NAME[]        = "dhcp6cDNS";
+static const char DHCPv6_DAEMON_PROP_NAME[]   = "init.svc.dhcp6c";
+static const char DHCPv6DNS_DAEMON_PROP_NAME[]   = "init.svc.dhcp6cDNS";
+static const char DHCPv6_PROP_NAME_PREFIX[]  = "dhcp.ipv6";
+
+
 /* interface length for dhcpcd daemon start (dhcpcd_<interface> as defined in init.rc file)
  * or for filling up system properties dhcpcd.<interface>.ipaddress, dhcpcd.<interface>.dns1
  * and other properties on a successful bind
@@ -57,6 +79,59 @@ void get_p2p_interface_replacement(const char *interface, char *p2p_interface) {
     }
 }
 
+
+/*
+ * read the value of ra_info_flag.
+ * return 1 for other config; return 2 for managed.
+ * Note: return 0 if no RA is received.
+ */
+enum GET_RA_RET {ERR=0, O_SET=1, M_SET=2};
+enum GET_RA_RET ra_flag;
+
+static enum GET_RA_RET getMbitFromRA(const char * iface, int maxwait)
+{
+	char ch;
+    char filename[64];
+	snprintf(filename, sizeof(filename), "/proc/sys/net/ipv6/conf/%s/ra_info_flag", iface);
+
+	if (maxwait < 1)
+	{
+		maxwait = 1;
+	}
+
+	while (maxwait-- > 0)
+	{
+        usleep(1000*1000); /*1s*/
+		int fd = open(filename, O_RDONLY);
+
+		if (fd < 0) {
+			ALOGE("Can't open %s: %s", filename, strerror(errno));
+			/*if open fail, retry after 1s*/
+			continue;
+		}
+
+		int len = read(fd, &ch, 1);
+		close(fd);
+
+		if (len < 0) {
+			ALOGE("Can't read %s: %s", filename, strerror(errno));
+			continue;
+		}
+
+		ALOGD("read:ra_info_flag=%c\n", ch);
+		if (ch == '2') 
+		{
+			return M_SET;
+		}
+		else if (ch == '1')
+		{
+			return O_SET;
+		}
+	}
+
+	return ERR;
+}
+
 /*
  * Wait for a system property to be assigned a specified value.
  * If desired_value is NULL, then just wait for the property to
@@ -156,6 +231,81 @@ static int fill_ip_info(const char *interface,
     return 0;
 }
 
+/* get value of ipaddr, dns1, dns2 and lease on the interface.
+ * ipaddr is the ipv6 address assigned by the DHCP server.
+ * dns1, dns2 and lease also got from DHCP server.
+ * */
+static int fill_ip6_info(const char *interface,
+		char *ipaddr,
+		char *dns1,
+		char *dns2,
+		uint32_t *lease)
+{
+    char prop_name[PROPERTY_KEY_MAX];
+    char prop_value[PROPERTY_VALUE_MAX];
+
+	snprintf(prop_name, sizeof(prop_name), "%s.%s.ipaddress", DHCPv6_PROP_NAME_PREFIX, interface);
+    property_get(prop_name, ipaddr, NULL);
+
+	snprintf(prop_name, sizeof(prop_name), "%s.%s.dns1", DHCPv6_PROP_NAME_PREFIX, interface);
+    property_get(prop_name, dns1, NULL);
+
+	snprintf(prop_name, sizeof(prop_name), "%s.%s.dns2", DHCPv6_PROP_NAME_PREFIX, interface);
+    property_get(prop_name, dns2, NULL);
+
+	snprintf(prop_name, sizeof(prop_name), "%s.%s.leasetime", DHCPv6_PROP_NAME_PREFIX, interface);
+    if (property_get(prop_name, prop_value, NULL))
+	{
+		*lease = atol(prop_value);
+	}
+	else /*when RA flag is 'O', no need to do renew, so set lease time to a very big number.*/
+	{
+		*lease = 0x7FFFFFFF - 1;
+	}
+
+	ALOGD("(int)leasetime=%d\n", *lease);
+	
+	return 0;
+}
+
+static void clear_ip6_info(const char *interface)
+{
+    char prop_name[PROPERTY_KEY_MAX];
+    char prop_value[PROPERTY_VALUE_MAX];
+
+	snprintf(prop_name, sizeof(prop_name), "%s.%s.ipaddress", DHCPv6_PROP_NAME_PREFIX, interface);
+    property_set(prop_name, "");
+
+	snprintf(prop_name, sizeof(prop_name), "%s.%s.dns1", DHCPv6_PROP_NAME_PREFIX, interface);
+    property_set(prop_name, "");
+
+	snprintf(prop_name, sizeof(prop_name), "%s.%s.dns2", DHCPv6_PROP_NAME_PREFIX, interface);
+    property_set(prop_name, "");
+
+	snprintf(prop_name, sizeof(prop_name), "%s.%s.leasetime", DHCPv6_PROP_NAME_PREFIX, interface);
+    property_set(prop_name, "");
+}
+
+static int clear_RAflag(const char *interface)
+{
+	char proc[64];
+	snprintf(proc, sizeof(proc), "/proc/sys/net/ipv6/conf/%s/ra_info_flag", interface);
+
+	int fd = open(proc, O_WRONLY);
+	if (fd < 0) {
+		ALOGE("Failed to open ra_info_flag (%s)", strerror(errno));
+		return -1;
+	}
+
+	if (write(fd, "0", 1) != 1) {
+		ALOGE("Failed to write ra_info_flag (%s)", strerror(errno));
+		close(fd);
+		return -1;
+	}
+	close(fd);
+	return 0;		
+}
+
 static const char *ipaddr_to_string(in_addr_t addr)
 {
     struct in_addr in_addr;
@@ -250,6 +400,86 @@ int dhcp_do_request(const char *interface,
     }
 }
 
+
+/*
+ * Start the dhcpv6 client daemon, and wait for it to finish
+ * configuring the interface.
+ *
+ * The device init.rc file needs a corresponding entry for this work.
+ *
+ * Example:
+ * service dhcp6c_<interface> /system/bin/dhcp6c -Df
+ */
+int dhcpv6_do_request(const char *interface, char *ipaddr,
+		char *dns1,
+		char *dns2,
+		uint32_t *lease)
+{
+    char result_prop_name[PROPERTY_KEY_MAX];
+    char daemon_prop_name[PROPERTY_KEY_MAX];
+    char prop_value[PROPERTY_VALUE_MAX] = {'\0'};
+    char daemon_cmd[PROPERTY_VALUE_MAX * 2];
+    const char *ctrl_prop = "ctl.start";
+    const char *desired_status = "running";
+
+	// clear information, such as dns1, dns2, leasetime, ipaddress
+	clear_ip6_info(interface);
+
+    snprintf(result_prop_name, sizeof(result_prop_name), "%s.%s.result",
+            DHCPv6_PROP_NAME_PREFIX,
+            interface);
+
+
+    /* Erase any previous setting of the dhcp result property */
+    property_set(result_prop_name, "");
+
+    /* Start the daemon and wait until it's ready */
+	ra_flag = getMbitFromRA("wlan0", 10);
+
+	if (ra_flag == M_SET)	
+	{
+		snprintf(daemon_prop_name, sizeof(daemon_prop_name), "%s_%s",
+				DHCPv6_DAEMON_PROP_NAME,
+				interface);
+		snprintf(daemon_cmd, sizeof(daemon_cmd), "%s_%s", DHCPv6_DAEMON_NAME, interface);
+	}
+	else
+	{
+		snprintf(daemon_prop_name, sizeof(daemon_prop_name), "%s_%s",
+				DHCPv6DNS_DAEMON_PROP_NAME,
+				interface);
+		snprintf(daemon_cmd, sizeof(daemon_cmd), "%s_%s", DHCPv6DNS_DAEMON_NAME, interface);
+	}
+
+    memset(prop_value, '\0', PROPERTY_VALUE_MAX);
+    property_set(ctrl_prop, daemon_cmd);
+    if (wait_for_property(daemon_prop_name, desired_status, 10) < 0) {
+        snprintf(errmsgv6, sizeof(errmsgv6), "%s", "Timed out waiting for dhcp6c to start");
+
+        return -1;
+    }
+
+    /* Wait for the daemon to return a result */
+    if (wait_for_property(result_prop_name, NULL, 30) < 0) {
+        snprintf(errmsgv6, sizeof(errmsgv6), "%s", "Timed out waiting for DHCPv6 to finish");
+        return -1;
+    }
+
+    if (!property_get(result_prop_name, prop_value, NULL)) {
+        /* shouldn't ever happen, given the success of wait_for_property() */
+        snprintf(errmsgv6, sizeof(errmsgv6), "%s", "DHCPv6 result property was not set");
+        return -1;
+    }
+    if (strcmp(prop_value, "ok") == 0) {
+        /* fill_ip_info(interface, ipaddr, gateway, mask, dns1, dns2, server, lease); */
+		fill_ip6_info(interface, ipaddr, dns1, dns2, lease);
+        return 0;
+    } else {
+        snprintf(errmsgv6, sizeof(errmsgv6), "DHCPv6 result was %s", prop_value);
+        return -1;
+    }
+}
+
 /**
  * Stop the DHCP client daemon.
  */
@@ -285,6 +515,80 @@ int dhcp_stop(const char *interface)
 }
 
 /**
+ * Stop the DHCPv6 client daemon.
+ */
+int dhcpv6_stop(const char *interface)
+{
+#if 1
+    char result_prop_name[PROPERTY_KEY_MAX];
+    char daemon_prop_name[PROPERTY_KEY_MAX];
+    char daemon_cmd[PROPERTY_VALUE_MAX * 2];
+    const char *ctrl_prop = "ctl.stop";
+    const char *desired_status = "stopped";
+
+    snprintf(result_prop_name, sizeof(result_prop_name), "%s.%s.result",
+            DHCPv6_PROP_NAME_PREFIX,
+            interface);
+
+	if (ra_flag == M_SET)	
+	{
+		snprintf(daemon_prop_name, sizeof(daemon_prop_name), "%s_%s",
+				DHCPv6_DAEMON_PROP_NAME,
+				interface);
+		snprintf(daemon_cmd, sizeof(daemon_cmd), "%s_%s", DHCPv6_DAEMON_NAME, interface);
+	}
+	else
+	{
+		snprintf(daemon_prop_name, sizeof(daemon_prop_name), "%s_%s",
+				DHCPv6DNS_DAEMON_PROP_NAME,
+				interface);
+		snprintf(daemon_cmd, sizeof(daemon_cmd), "%s_%s", DHCPv6DNS_DAEMON_NAME, interface);
+	}
+
+    /* Stop the daemon and wait until it's reported to be stopped */
+    property_set(ctrl_prop, daemon_cmd);
+    if (wait_for_property(daemon_prop_name, desired_status, 5) < 0) {
+        return -1;
+    }
+    property_set(result_prop_name, "released");
+
+	// clear information, such as dns1, dns2, leasetime, ipaddress
+	clear_ip6_info(interface);
+	clear_RAflag("wlan0");
+    return 0;
+#else
+    char result_prop_name[PROPERTY_KEY_MAX];
+    char daemon_prop_name[PROPERTY_KEY_MAX];
+    char daemon_cmd[PROPERTY_VALUE_MAX * 2];
+    const char *desired_status = "stopped";
+
+    snprintf(result_prop_name, sizeof(result_prop_name), "%s.%s.result",
+            DHCPv6_PROP_NAME_PREFIX,
+            interface);
+
+    snprintf(daemon_prop_name, sizeof(daemon_prop_name), "%s_%s",
+            DHCPv6_DAEMON_PROP_NAME,
+            interface);
+
+
+    /* Stop the daemon and wait until it's reported to be stopped */
+	system("dhcp6ctl stop");
+
+    if (wait_for_property(daemon_prop_name, desired_status, 5) < 0) {
+        return -1;
+    }
+    property_set(result_prop_name, "released");
+
+	// clear information, such as dns1, dns2, leasetime, ipaddress
+	clear_ip6_info(interface);
+	
+    return 0;
+#endif
+}
+
+
+
+/**
  * Release the current DHCP client lease.
  */
 int dhcp_release_lease(const char *interface)
@@ -316,6 +620,10 @@ char *dhcp_get_errmsg() {
     return errmsg;
 }
 
+char *dhcpv6_get_errmsg() {
+    return errmsgv6;
+}
+
 /**
  * The device init.rc file needs a corresponding entry.
  *
@@ -375,3 +683,49 @@ int dhcp_do_request_renew(const char *interface,
         return -1;
     }
 }
+/* the dhcpv6 client deamon can automatically update these properties,
+ * so, renew operation only need to read these properties again.
+ * */
+int dhcpv6_do_request_renew(const char *interface, char *ipaddr,
+		char *dns1,
+		char *dns2,
+		uint32_t *lease)
+{
+	int ret;
+    char result_prop_name[PROPERTY_KEY_MAX];
+    char prop_value[PROPERTY_VALUE_MAX] = {'\0'};
+
+    snprintf(result_prop_name, sizeof(result_prop_name), "%s.%s.renewresult",
+            DHCPv6_PROP_NAME_PREFIX,
+            interface);
+
+    /* send renew to the dhcp6c */
+	if ((ret = system("dhcp6ctl renew")) < 0)
+	{
+        snprintf(errmsgv6, sizeof(errmsgv6), "%s:%d\n", "execute renew command, got error return code:", ret);
+		return -1;
+	}
+
+	/* Wait for the daemon to return a result */
+	if (wait_for_property(result_prop_name, NULL, 30) < 0) {
+		snprintf(errmsgv6, sizeof(errmsgv6), "%s", "Timed out waiting for DHCPv6 renew to finish");
+		return -1;
+	}
+
+	if (!property_get(result_prop_name, prop_value, NULL)) {
+		/* shouldn't ever happen, given the success of wait_for_property() */
+		snprintf(errmsgv6, sizeof(errmsgv6), "%s", "DHCPv6 renew result property was not set");
+		return -1;
+	}
+	if (strcmp(prop_value, "ok") == 0) {
+		/* Erase any previous setting of the dhcp result property */
+		property_set(result_prop_name, "");
+
+		/* fill_ip_info(interface, ipaddr, gateway, mask, dns1, dns2, server, lease); */
+		fill_ip6_info(interface, ipaddr, dns1, dns2, lease);
+		return 0;
+	} else {
+		snprintf(errmsgv6, sizeof(errmsgv6), "DHCPv6 renew result was %s", prop_value);
+		return -1;
+	}
+}
diff --git a/system/core/libnetutils/dhcpclient.c b/gb/12055-master/driveronly_mp_rom/system/core/libnetutils/dhcpclient.c
index 34500e7..9213eaa 100644
--- a/system/core/libnetutils/dhcpclient.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libnetutils/dhcpclient.c
@@ -31,7 +31,7 @@
 #include <netinet/in.h>
 
 #include <cutils/properties.h>
-#define LOG_TAG "DHCP"
+#define LOG_TAG "NetUtils"
 #include <cutils/log.h>
 
 #include <dirent.h>
diff --git a/system/core/libnetutils/ifc_utils.c b/gb/12055-master/driveronly_mp_rom/system/core/libnetutils/ifc_utils.c
index eb33d06..3ec9bd9 100644
--- a/system/core/libnetutils/ifc_utils.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libnetutils/ifc_utils.c
@@ -36,6 +36,7 @@
 #include <linux/ipv6_route.h>
 #include <linux/rtnetlink.h>
 #include <linux/sockios.h>
+#include <linux/un.h>
 
 #include "netutils/ifc.h"
 
@@ -52,9 +53,10 @@
 
 static int ifc_ctl_sock = -1;
 static int ifc_ctl_sock6 = -1;
+static int ifc_netd_sock = -1;
 void printerr(char *fmt, ...);
 
-#define DBG 0
+#define DBG 1
 #define INET_ADDRLEN 4
 #define INET6_ADDRLEN 16
 
@@ -125,7 +127,7 @@ int ifc_init(void)
     }
 
     ret = ifc_ctl_sock < 0 ? -1 : 0;
-    if (DBG) printerr("ifc_init_returning %d", ret);
+    if (0) printerr("ifc_init_returning %d", ret);
     return ret;
 }
 
@@ -142,7 +144,7 @@ int ifc_init6(void)
 
 void ifc_close(void)
 {
-    if (DBG) printerr("ifc_close");
+    if (0) printerr("ifc_close");
     if (ifc_ctl_sock != -1) {
         (void)close(ifc_ctl_sock);
         ifc_ctl_sock = -1;
@@ -214,6 +216,46 @@ int ifc_down(const char *name)
     return ret;
 }
 
+int ifc_enable_allmc(const char *ifname)
+{
+	int result;
+	
+	ifc_init();
+	result = ifc_set_flags(ifname, IFF_ALLMULTI, 0);
+	ifc_close();
+
+	ALOGD("ifc_enable_allmc(%s) = %d", ifname, result);
+	return result;
+}
+
+int ifc_disable_allmc(const char *ifname)
+{
+	int result;
+	
+	ifc_init();
+	result = ifc_set_flags(ifname, 0, IFF_ALLMULTI);
+	ifc_close();
+
+	ALOGD("ifc_disable_allmc(%s) = %d", ifname, result);
+	return result;
+}
+int ifc_is_up(const char *name, unsigned *isup)
+{
+    struct ifreq ifr;
+    ifc_init_ifr(name, &ifr);
+
+    if(ioctl(ifc_ctl_sock, SIOCGIFFLAGS, &ifr) < 0) {
+        printerr("ifc_is_up get flags error:%d(%s)", errno, strerror(errno));
+        return -1;
+    }
+    if(ifr.ifr_flags & IFF_UP)
+        *isup = 1;
+    else
+        *isup = 0;
+  
+    return 0;
+}
+
 static void init_sockaddr_in(struct sockaddr *sa, in_addr_t addr)
 {
     struct sockaddr_in *sin = (struct sockaddr_in *) sa;
@@ -388,6 +430,7 @@ int ifc_clear_ipv6_addresses(const char *name) {
     }
 
     fclose(f);
+	ALOGD("ifc_clear_ipv6_addresses return %d", lasterror);
     return lasterror;
 }
 
@@ -404,6 +447,7 @@ void ifc_clear_ipv4_addresses(const char *name) {
             ifc_set_addr(name, 0);
     }
     ifc_close();
+	ALOGD("ifc_clear_ipv4_addresses return");
 }
 
 /*
@@ -599,6 +643,48 @@ int ifc_disable(const char *ifname)
     return result;
 }
 
+
+int ifc_reset_connection_by_uid(int uid, int error)
+{
+#ifdef HAVE_ANDROID_OS
+
+    int tcp_ctl_sock;
+
+    int result = -1;
+    struct uid_err uid_e;
+
+	uid_e.appuid = uid;
+	uid_e.errorNum = error;
+    
+    tcp_ctl_sock = socket(AF_INET, SOCK_STREAM, 0);
+    if (tcp_ctl_sock < 0) {
+        printerr("socket() failed: %s\n", strerror(errno));
+        return -1;
+    }
+    
+    if(uid_e.appuid < 0){
+        ALOGE("ifc_reset_connection_by_uid, invalide uid: %d", uid_e.appuid);
+        return -1;
+    }
+    
+    ALOGD("ifc_reset_connection_by_uid, appuid = %d, error = %d ",
+		      uid_e.appuid, uid_e.errorNum);
+    result = ioctl(tcp_ctl_sock, SIOCKILLSOCK, &uid_e);
+    if(result < 0)
+        ALOGE("ifc_reset_connection_by_uid, result= %d, error =%s ", result, strerror(errno));
+
+	close(tcp_ctl_sock);
+    ALOGD("ifc_reset_connection_by_uid, result= %d ",result);
+    return result;
+#else
+    return 0;
+#endif
+}
+
+#define RESET_IPV4_ADDRESSES 0x01
+#define RESET_IPV6_ADDRESSES 0x02
+#define RESET_ALL_ADDRESSES  (RESET_IPV4_ADDRESSES | RESET_IPV6_ADDRESSES)
+
 int ifc_reset_connections(const char *ifname, const int reset_mask)
 {
 #ifdef HAVE_ANDROID_OS
@@ -964,3 +1050,83 @@ int ifc_remove_route(const char *ifname, const char*dst, int prefix_length, cons
 {
     return ifc_act_on_route(SIOCDELRT, ifname, dst, prefix_length, gw);
 }
+
+static int ifc_netd_sock_init(void)
+{
+    int ret;
+    const int one = 1;
+    struct sockaddr_un netd_addr;
+  
+    if(ifc_netd_sock == -1){
+        ifc_netd_sock = socket(AF_UNIX, SOCK_STREAM, 0);
+        if (ifc_netd_sock < 0) {
+            printerr("ifc_netd_sock_init: create socket failed");
+            return -1;
+        }
+  
+        setsockopt(ifc_netd_sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
+        memset(&netd_addr, 0, sizeof(netd_addr));
+        netd_addr.sun_family = AF_UNIX;
+        strlcpy(netd_addr.sun_path, "/dev/socket/netd",
+            sizeof(netd_addr.sun_path));
+        if (TEMP_FAILURE_RETRY(connect(ifc_netd_sock,
+                     (const struct sockaddr*) &netd_addr,
+                     sizeof(netd_addr))) != 0) {
+            printerr("ifc_netd_sock_init: connect to netd failed, err: %d(%s)", 
+                errno, strerror(errno));
+            return -1;
+        }
+    }
+  
+    ret = ifc_netd_sock < 0 ? -1 : 0;
+    if (DBG) printerr("ifc_netd_sock_init return %d", ret);
+    return ret;
+}
+
+static void ifc_netd_sock_close(void)
+{
+    if (DBG) printerr("ifc_netd_sock_close");
+    if (ifc_netd_sock != -1) {
+        (void)close(ifc_netd_sock);
+        ifc_netd_sock = -1;
+    }
+}
+
+/*do not call this function in netd*/
+int ifc_set_throttle(const char *ifname, int rxKbps, int txKbps)
+{
+    FILE* fnetd = NULL;
+    int ret = -1;
+    int seq = 1;
+    char rcv_buf[24];
+	int nread = 0;
+    ALOGD("enter ifc_set_throttle: ifname = %s, rx = %d kbs, tx = %d kbs", ifname, rxKbps, txKbps);
+
+    if(ifc_netd_sock_init() != 0)
+        goto exit;
+    
+    // Send the request.
+    fnetd = fdopen(ifc_netd_sock, "r+");
+    if (fprintf(fnetd, "%d interface setthrottle %s %d %d", seq, ifname, rxKbps, txKbps) < 0) {
+        goto exit;
+    }
+    // literal NULL byte at end, required by FrameworkListener
+    if (fputc(0, fnetd) == EOF ||
+        fflush(fnetd) != 0) {
+        goto exit;
+    }
+    ret = 0;
+
+	//Todo: read the whole response from netd
+	nread = fread(rcv_buf, 1, 20, fnetd);
+	rcv_buf[23] = 0;
+	ALOGD("response: %s", rcv_buf);
+exit:
+    if (fnetd != NULL) {
+        fclose(fnetd);
+    }
+    ifc_netd_sock_close();
+  
+    return ret;
+}
+
diff --git a/system/core/libnl_2/.gitignore b/system/core/libnl_2/.gitignore
deleted file mode 100644
index d4ca744..0000000
--- a/system/core/libnl_2/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-include/netlink/version.h.in
-cscope.*
diff --git a/system/core/libpixelflinger/Android.mk b/gb/12055-master/driveronly_mp_rom/system/core/libpixelflinger/Android.mk
index 488003f..b4b8087 100644
--- a/system/core/libpixelflinger/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libpixelflinger/Android.mk
@@ -73,6 +73,10 @@ ifneq ($(BUILD_TINY_ANDROID),true)
 LOCAL_SHARED_LIBRARIES += libhardware_legacy
 LOCAL_CFLAGS += -DWITH_LIB_HARDWARE
 endif
+ifneq ($(TARGET_BUILD_VARIANT),user)
+LOCAL_CFLAGS += -DDLMALLOC_DEBUG
+LOCAL_SHARED_LIBRARIES += libdl
+endif
 include $(BUILD_SHARED_LIBRARY)
 
 #
diff --git a/system/core/libpixelflinger/codeflinger/CodeCache.cpp b/gb/12055-master/driveronly_mp_rom/system/core/libpixelflinger/codeflinger/CodeCache.cpp
index f9ae00a..4b7534a 100644
--- a/system/core/libpixelflinger/codeflinger/CodeCache.cpp
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libpixelflinger/codeflinger/CodeCache.cpp
@@ -55,6 +55,7 @@ namespace android {
 #define MSPACES 1
 #define NO_MALLINFO 1
 #define ONLY_MSPACES 1
+#define IN_MSPACE 1
 // Custom heap error handling.
 #define PROCEED_ON_ERROR 0
 static void heap_error(const char* msg, const char* function, void* p);
diff --git a/system/core/libsuspend/Android.mk b/gb/12055-master/driveronly_mp_rom/system/core/libsuspend/Android.mk
index a2fa3e0..45cb701 100644
--- a/system/core/libsuspend/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libsuspend/Android.mk
@@ -12,6 +12,7 @@ libsuspend_libraries := \
 	liblog libcutils
 
 include $(CLEAR_VARS)
+
 LOCAL_SRC_FILES := $(libsuspend_src_files)
 LOCAL_MODULE := libsuspend
 LOCAL_MODULE_TAGS := optional
@@ -20,12 +21,3 @@ LOCAL_C_INCLUDES += $(LOCAL_PATH)/include
 LOCAL_SHARED_LIBRARIES := $(libsuspend_libraries)
 #LOCAL_CFLAGS += -DLOG_NDEBUG=0
 include $(BUILD_SHARED_LIBRARY)
-
-include $(CLEAR_VARS)
-LOCAL_SRC_FILES := $(libsuspend_src_files)
-LOCAL_MODULE := libsuspend
-LOCAL_MODULE_TAGS := optional
-LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include
-LOCAL_C_INCLUDES += $(LOCAL_PATH)/include
-#LOCAL_CFLAGS += -DLOG_NDEBUG=0
-include $(BUILD_STATIC_LIBRARY)
diff --git a/system/core/libsysutils/src/FrameworkListener.cpp b/gb/12055-master/driveronly_mp_rom/system/core/libsysutils/src/FrameworkListener.cpp
index 6731cf1..2cf8b0c 100644
--- a/system/core/libsysutils/src/FrameworkListener.cpp
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libsysutils/src/FrameworkListener.cpp
@@ -82,6 +82,7 @@ void FrameworkListener::dispatchCommand(SocketClient *cli, char *data) {
     bool quote = false;
     int k;
     bool haveCmdNum = !mWithSeq;
+	  SLOGD("dispatchCommand data = (%s)", data);
 
     memset(argv, 0, sizeof(argv));
     memset(tmp, 0, sizeof(tmp));
diff --git a/system/core/libsysutils/src/NetlinkEvent.cpp b/gb/12055-master/driveronly_mp_rom/system/core/libsysutils/src/NetlinkEvent.cpp
index 4beebb7..6a392cc 100644
--- a/system/core/libsysutils/src/NetlinkEvent.cpp
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libsysutils/src/NetlinkEvent.cpp
@@ -20,6 +20,7 @@
 #include <cutils/log.h>
 
 #include <sysutils/NetlinkEvent.h>
+#include <cutils/properties.h>
 
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -31,6 +32,8 @@ const int QLOG_NL_EVENT  = 112;
 
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
+#include <arpa/inet.h>
+#include <net/if.h>
 
 const int NetlinkEvent::NlActionUnknown = 0;
 const int NetlinkEvent::NlActionAdd = 1;
@@ -38,6 +41,8 @@ const int NetlinkEvent::NlActionRemove = 2;
 const int NetlinkEvent::NlActionChange = 3;
 const int NetlinkEvent::NlActionLinkUp = 4;
 const int NetlinkEvent::NlActionLinkDown = 5;
+const int NetlinkEvent::NlActionIPv6Enable = 6;
+const int NetlinkEvent::NlActionIPv6Disable = 7;
 
 NetlinkEvent::NetlinkEvent() {
     mAction = NlActionUnknown;
@@ -61,6 +66,8 @@ NetlinkEvent::~NetlinkEvent() {
 
 void NetlinkEvent::dump() {
     int i;
+	SLOGD("NL action '%d'\n", mAction);
+	SLOGD("NL subsystem '%s'\n", mSubsystem);
 
     for (i = 0; i < NL_PARAMS_MAX; i++) {
         if (!mParams[i])
@@ -106,6 +113,36 @@ bool NetlinkEvent::parseBinaryNetlinkMessage(char *buffer, int size) {
                     mAction = (ifi->ifi_flags & IFF_LOWER_UP) ?
                       NlActionLinkUp : NlActionLinkDown;
                     mSubsystem = strdup("net");
+
+					/*mtk80842 for IPv6 tethering*/					
+					if(mAction == NlActionLinkDown){	
+						char prefix_prop_name[PROPERTY_KEY_MAX];	
+						char plen_prop_name[PROPERTY_KEY_MAX];	
+						char prop_value[PROPERTY_VALUE_MAX] = {'\0'};	
+						snprintf(prefix_prop_name, sizeof(prefix_prop_name), 
+							"net.ipv6.%s.prefix", (char *) RTA_DATA(rta));	
+						
+						if (property_get("net.ipv6.tether", prop_value, NULL)) {	
+							if(0 == strcmp(prop_value, ((char *)RTA_DATA(rta)))){		
+								if (property_get(prefix_prop_name, prop_value, NULL)) {	
+							        property_set("net.ipv6.lastprefix", prop_value);
+									SLOGD("set last prefix as %s\n", prop_value);
+							    }
+							} else	{
+								SLOGW("%s is not a tether interface\n", (char *)RTA_DATA(rta));
+							}	
+						}
+
+						if (property_get(prefix_prop_name, prop_value, NULL)) {	
+							property_set(prefix_prop_name, "");	
+						}	
+						snprintf(plen_prop_name, sizeof(plen_prop_name), 
+							"net.ipv6.%s.plen", (char *) RTA_DATA(rta));	
+						if (property_get(plen_prop_name, prop_value, NULL)) {	
+							property_set(plen_prop_name, "");	
+							}					
+						}
+					
                     break;
                 }
 
@@ -127,6 +164,91 @@ bool NetlinkEvent::parseBinaryNetlinkMessage(char *buffer, int size) {
             mSubsystem = strdup("qlog");
             mAction = NlActionChange;
 
+        } else if(nh->nlmsg_type == RTM_NEWPREFIX){
+
+				struct prefixmsg *prefix = (prefixmsg *)NLMSG_DATA(nh);
+				int len = nh->nlmsg_len;
+				struct rtattr * tb[RTA_MAX+1];
+				char if_name[IFNAMSIZ] = "";
+				
+				if (nh->nlmsg_type != RTM_NEWPREFIX) {
+					SLOGE("Not a prefix: %08x %08x %08x\n",
+						nh->nlmsg_len, nh->nlmsg_type, nh->nlmsg_flags);
+					continue;
+				}
+			
+				len -= NLMSG_LENGTH(sizeof(*prefix));
+				if (len < 0) {
+					SLOGE("BUG: wrong nlmsg len %d\n", len);
+					continue;
+				}
+					
+				if (prefix->prefix_family != AF_INET6) {
+					SLOGE("wrong family %d\n", prefix->prefix_family);
+					continue;
+				}
+				if (prefix->prefix_type != 3 /*prefix opt*/) {
+					SLOGE( "wrong ND type %d\n", prefix->prefix_type);
+					continue;
+				}
+				if_indextoname(prefix->prefix_ifindex, if_name);
+				
+				{ 
+					int max = RTA_MAX;
+				    struct rtattr *rta = RTM_RTA(prefix);
+					memset(tb, 0, sizeof(struct rtattr *) * (max + 1));
+					while (RTA_OK(rta, len)) {
+						if ((rta->rta_type <= max) && (!tb[rta->rta_type]))
+							tb[rta->rta_type] = rta;
+						rta = RTA_NEXT(rta,len);
+					}
+					if (len)
+						SLOGE("!!!Deficit %d, rta_len=%d\n", len, rta->rta_len);
+				}
+				if (tb[PREFIX_ADDRESS] && (0 == strncmp(if_name, "ccmni", 2))) {
+					struct in6_addr *pfx;
+					char abuf[256];
+					char prefix_prop_name[PROPERTY_KEY_MAX];
+					char plen_prop_name[PROPERTY_KEY_MAX];
+					char prefix_value[PROPERTY_VALUE_MAX] = {'\0'};
+					char plen_value[4]; 
+					
+					pfx = (struct in6_addr *)RTA_DATA(tb[PREFIX_ADDRESS]);
+			
+					memset(abuf, '\0', sizeof(abuf));
+					const char* addrStr = inet_ntop(AF_INET6, pfx, abuf, sizeof(abuf));
+
+					snprintf(prefix_prop_name, sizeof(prefix_prop_name), 
+						"net.ipv6.%s.prefix", if_name);
+					property_get(prefix_prop_name, prefix_value, NULL);
+					if(NULL != addrStr && strcmp(addrStr, prefix_value)){
+						SLOGI("%s new prefix: %s, len=%d\n", if_name, addrStr, prefix->prefix_len);  
+
+						property_set(prefix_prop_name, addrStr);
+						snprintf(plen_prop_name, sizeof(plen_prop_name), 
+								"net.ipv6.%s.plen", if_name);
+						snprintf(plen_value, sizeof(plen_value), 
+								"%d", prefix->prefix_len);						
+						property_set(plen_prop_name, plen_value);
+						{
+			                char buffer[16 + IFNAMSIZ];
+			                snprintf(buffer, sizeof(buffer), "INTERFACE=%s", if_name);
+			                mParams[0] = strdup(buffer);							
+						    mAction = NlActionIPv6Enable;
+							mSubsystem = strdup("net");
+						}
+					} else {
+						SLOGD("get an exist prefix: = %s\n", addrStr);
+					} 					
+				}else{
+					SLOGD("ignore prefix of %s\n", if_name);
+				}
+	/*		
+				if (prefix->prefix_flags & IF_PREFIX_ONLINK)
+					;
+				if (prefix->prefix_flags & IF_PREFIX_AUTOCONF)
+					;
+	*/	
         } else {
                 SLOGD("Unexpected netlink message. type=0x%x\n", nh->nlmsg_type);
         }
diff --git a/system/core/libsysutils/src/SocketClient.cpp b/gb/12055-master/driveronly_mp_rom/system/core/libsysutils/src/SocketClient.cpp
index 3d4984d..3c6b1bc 100644
--- a/system/core/libsysutils/src/SocketClient.cpp
+++ b/gb/12055-master/driveronly_mp_rom/system/core/libsysutils/src/SocketClient.cpp
@@ -57,6 +57,7 @@ int SocketClient::sendMsg(int code, const char *msg, bool addErrno) {
 int SocketClient::sendMsg(int code, const char *msg, bool addErrno, bool useCmdNum) {
     char *buf;
     int ret = 0;
+	SLOGD("SocketClient msg = %s", msg);
 
     if (addErrno) {
         if (useCmdNum) {
@@ -181,6 +182,7 @@ int SocketClient::sendDataLocked(const void *data, int len) {
         }
         return -1;
     }
+    SLOGD("SocketClient sendDatalocked done: %s", data);
     return 0;
 }
 
diff --git a/system/core/logcat/logcat.cpp b/gb/12055-master/driveronly_mp_rom/system/core/logcat/logcat.cpp
index d3b5ed0..507ed00 100644
--- a/system/core/logcat/logcat.cpp
+++ b/gb/12055-master/driveronly_mp_rom/system/core/logcat/logcat.cpp
@@ -32,6 +32,9 @@ static int g_tail_lines = 0;
 
 #define LOG_FILE_DIR    "/dev/log/"
 
+#define LOG_TS_PATH "/proc/log_ts"
+extern int g_log_ts;
+
 struct queued_entry_t {
     union {
         unsigned char buf[LOGGER_ENTRY_MAX_LEN + 1] __attribute__((aligned(4)));
@@ -85,6 +88,41 @@ struct log_device_t {
     }
 };
 
+// To fix the bug of multi-device blocking
+char trigger_tag[] = {"AEE"};
+char trigger_message[] = {"trigger log"};
+struct queued_entry_t trigger_entry;
+int entry_num = 0;
+bool entry_too_much = false;
+#define LOG_TRIGGER_WATERLEVEL 10000
+
+
+/*
+ * Trigger Log when there are too many entries in memory
+ */
+void constructEntry(queued_entry_t* entry){
+    struct timeval now;
+    gettimeofday(&now, NULL);
+    entry->entry.len = 1 + sizeof(trigger_tag) + sizeof(trigger_message);
+    entry->entry.pid = 0;
+    entry->entry.tid = 0;
+    entry->entry.msg[0] = 0x5;
+    memcpy(entry->buf + sizeof(logger_entry) + 1, trigger_tag, sizeof(trigger_tag));
+    memcpy(entry->buf + sizeof(logger_entry) + sizeof(trigger_tag) + 1, trigger_message, sizeof(trigger_message));
+    entry->entry.sec = now.tv_sec;
+    entry->entry.nsec = now.tv_usec * 1000;
+}
+
+void trigger_log(log_device_t *dev) {
+    queued_entry_t* entry = new queued_entry_t();
+    constructEntry(entry);
+    dev->enqueue(entry);
+    entry_num++;
+    if (entry_num >= LOG_TRIGGER_WATERLEVEL) {
+        entry_too_much = true;
+    }
+}
+
 namespace android {
 
 /* Global Variables */
@@ -235,6 +273,10 @@ static void skipNextEntry(log_device_t* dev) {
     queued_entry_t* entry = dev->queue;
     dev->queue = entry->next;
     delete entry;
+    entry_num--;
+    if(entry_num < LOG_TRIGGER_WATERLEVEL) {
+        entry_too_much = false;
+    }
 }
 
 static void printNextEntry(log_device_t* dev) {
@@ -305,6 +347,10 @@ static void readLogLines(log_device_t* devices)
                     entry->entry.msg[entry->entry.len] = '\0';
 
                     dev->enqueue(entry);
+                    entry_num++;
+                    if (entry_num >= LOG_TRIGGER_WATERLEVEL) {
+                        entry_too_much = true;
+                    }
                     ++queued_lines;
                 }
             }
@@ -336,7 +382,11 @@ static void readLogLines(log_device_t* devices)
                 while (g_tail_lines == 0 || queued_lines > g_tail_lines) {
                     chooseFirst(devices, &dev);
                     if (dev == NULL || dev->queue->next == NULL) {
-                        break;
+                        if (entry_too_much) {
+                            trigger_log(dev);
+                        } else {
+                            break;
+                        }
                     }
                     if (g_tail_lines == 0) {
                         printNextEntry(dev);
@@ -658,6 +708,28 @@ int main(int argc, char **argv)
         }
     }
 
+	// Read /proc/log_ts
+	char log_ts = '0';
+	int log_fd = open(LOG_TS_PATH, O_RDONLY);
+	if (log_fd >= 0) {
+		int ts_ret = read(log_fd, &log_ts, 1);
+		if(ts_ret >= 0) {
+			switch(log_ts) {
+			case '0':
+				g_log_ts = 0;
+				break;
+			case '1':
+				g_log_ts = 1;
+				break;
+			default:
+				g_log_ts = 0;
+				break;
+			}
+		}
+		
+		close(log_fd);
+	}
+	
     if (!devices) {
         devices = new log_device_t(strdup("/dev/"LOGGER_LOG_MAIN), false, 'm');
         android::g_devCount = 1;
diff --git a/system/core/rootdir/etc/init.goldfish.rc b/gb/12055-master/driveronly_mp_rom/system/core/rootdir/etc/init.goldfish.rc
index cde9dee..8fe84af 100644
--- a/system/core/rootdir/etc/init.goldfish.rc
+++ b/gb/12055-master/driveronly_mp_rom/system/core/rootdir/etc/init.goldfish.rc
@@ -1,8 +1,10 @@
 on early-init
-    export EXTERNAL_STORAGE /mnt/sdcard
-    mkdir /mnt/sdcard 0000 system system
+    export EXTERNAL_STORAGE /storage/sdcard0
+    mkdir /storage 0055 system sdcard_r
+    mkdir /storage/sdcard0 0000 system system
     # for backwards compatibility
-    symlink /mnt/sdcard /sdcard
+    symlink /storage/sdcard0 /sdcard
+    symlink /storage/sdcard0 /mnt/sdcard
 
 on boot
     setsebool in_qemu=1
diff --git a/system/core/rootdir/etc/vold.fstab b/gb/12055-master/driveronly_mp_rom/system/core/rootdir/etc/vold.fstab
index 4aad8dc..3434000 100644
--- a/system/core/rootdir/etc/vold.fstab
+++ b/gb/12055-master/driveronly_mp_rom/system/core/rootdir/etc/vold.fstab
@@ -14,7 +14,7 @@
 
 ## Example of a standard sdcard mount for the emulator / Dream
 # Mounts the first usable partition of the specified device
-dev_mount sdcard /mnt/sdcard auto /devices/platform/goldfish_mmc.0 /devices/platform/msm_sdcc.2/mmc_host/mmc1
+dev_mount sdcard /storage/sdcard0 auto /devices/platform/goldfish_mmc.0 /devices/platform/msm_sdcc.2/mmc_host/mmc1
 
 ## Example of a dual card setup
 # dev_mount left_sdcard  /sdcard1  auto /devices/platform/goldfish_mmc.0 /devices/platform/msm_sdcc.2/mmc_host/mmc1
diff --git a/system/core/rootdir/init.rc b/gb/12055-master/driveronly_mp_rom/system/core/rootdir/init.rc
index caef358..a49eb52 100644
--- a/system/core/rootdir/init.rc
+++ b/gb/12055-master/driveronly_mp_rom/system/core/rootdir/init.rc
@@ -513,3 +513,59 @@ service mdnsd /system/bin/mdnsd
     socket mdnsd stream 0660 mdnsr inet
     disabled
     oneshot
+
+#ifdef VENDOR_EDIT
+#@OppoHook.ROM 
+#ZhiYong.Lin@Plf.Framework, add for RUtils
+#service rutilsdaemon /system/bin/rutilsdaemon
+#	class main
+#	user root
+#endif /*VENDOR_EDIT*/
+
+#ifdef VENDOR_EDIT    
+#ZhiYong.Lin@Plf.Framework, add for RUtils
+service rutilsdaemon /system/bin/rutilsdaemon
+    class main
+    user root
+    disabled
+    
+on property:oppo.service.rutils.enable=1
+    start rutilsdaemon
+
+on property:oppo.service.rutils.enable=0
+    stop rutilsdaemon
+#endif /* VENDOR_EDIT */
+
+#ifdef VENDOR_EDIT
+#@OppoHook.ROM 
+#Tongxi.Li@Plf.framework, add for /frameworks/base/packages/Dumplog
+service dumplog /system/bin/dumpstate -t feedback
+    class main
+    socket dumpstate stream 0660 shell log
+    disabled
+    oneshot
+#endif /* VENDOR_EDIT */
+
+#ifdef VENDOR_EDIT
+
+#@OppoHook.ROM 
+#ZhiYong.Lin@Plf.Framework, add for backuprestore
+service backuprestore /system/bin/br_app_data_service
+	class main
+	socket backuprestore stream 0660 root sdcard_rw
+	user root
+	disabled
+	
+on property:oppo.service.br.enable=1
+    start backuprestore
+
+on property:oppo.service.br.enable=0
+    stop backuprestore
+#endif /*VENDOR_EDIT*/
+
+#ifdef VENDOR_EDIT
+#ZhenHai.Long@SystemSRV,2012/02/13, Add for
+#linzy modify and port
+service oppoutilsdaemon /system/bin/oppoutilsdaemon
+	user root
+#endif /*VENDOR_EDIT*/
\ No newline at end of file
diff --git a/system/core/rootdir/init.trace.rc b/gb/12055-master/driveronly_mp_rom/system/core/rootdir/init.trace.rc
index 8a05fd0..e3b2b2b 100644
--- a/system/core/rootdir/init.trace.rc
+++ b/gb/12055-master/driveronly_mp_rom/system/core/rootdir/init.trace.rc
@@ -15,7 +15,9 @@ on boot
     chown root shell /sys/kernel/debug/tracing/events/power/cpu_idle/enable
     chown root shell /sys/kernel/debug/tracing/events/power/clock_set_rate/enable
     chown root shell /sys/kernel/debug/tracing/events/cpufreq_interactive/enable
-    chown root shell /sys/kernel/debug/tracing/tracing_on
+    # change to system group for AMS to control
+    chown root system /sys/kernel/debug/tracing/tracing_on
+    chown root system /sys/kernel/debug/tracing/tracing_enabled
 
     chmod 0664 /sys/kernel/debug/tracing/trace_clock
     chmod 0664 /sys/kernel/debug/tracing/buffer_size_kb
@@ -27,6 +29,7 @@ on boot
     chmod 0664 /sys/kernel/debug/tracing/events/power/clock_set_rate/enable
     chmod 0664 /sys/kernel/debug/tracing/events/cpufreq_interactive/enable
     chmod 0664 /sys/kernel/debug/tracing/tracing_on
+    chmod 0664 /sys/kernel/debug/tracing/tracing_enabled
 
 # Allow only the shell group to read and truncate the kernel trace.
     chown root shell /sys/kernel/debug/tracing/trace
diff --git a/system/core/rootdir/ueventd.rc b/gb/12055-master/driveronly_mp_rom/system/core/rootdir/ueventd.rc
index 2cf0265..f73f48d 100644
--- a/system/core/rootdir/ueventd.rc
+++ b/gb/12055-master/driveronly_mp_rom/system/core/rootdir/ueventd.rc
@@ -8,9 +8,25 @@
 /dev/ashmem               0666   root       root
 /dev/binder               0666   root       root
 
+# for security check
+/dev/preloader            0640   root       system
+/dev/dsp_bl               0640   root       system
+/dev/block/mmcblk0p2      0640   root       system
+/dev/seccfg               0660   root       system
+/dev/bootimg              0640   root       system
+/dev/recovery             0640   root       system
+/dev/sec_ro               0640   root       system
+/dev/mtd/mtd0             0640   root       system
+/dev/mtd/mtd1             0640   root       system
+/dev/mtd/mtd3             0660   root       system
+/dev/mtd/mtd6             0640   root       system
+/dev/mtd/mtd7             0640   root       system
+
 # Anyone can read the logs, but if they're not in the "logs"
 # group, then they'll only see log entries for their UID.
+/dev/xLog                 0644   root       root
 /dev/log/*                0666   root       log
+/dev/log/ksystem          0660   root       log
 
 # the msm hw3d client device node is world writable/readable.
 /dev/msm_hw3dc            0666   root       root
@@ -77,6 +93,22 @@
 /dev/usb_accessory        0660   root       usb
 /dev/tun                  0660   system     vpn
 
+/dev/ccci*                0660   ccci       ccci
+/dev/ttyC*                0660   ccci       ccci
+
+/dev/pro_info                   0660	root		system
+/dev/otp 			0660	root		nvram
+/dev/nvram 			0660	root		system
+/mtd@nvram			0660	root		system
+/dev/misc			0660	root		system
+/mtd@misc			0660	root		system
+/dev/block/mmcblk0		0660	root		system
+/proc/driver/nand		0664	root		system
+
+# SGX device node
+/dev/pvrsrvkm             0666   root       root
+/dev/pvr_sync             0666   root       root
+
 # CDMA radio interface MUX
 /dev/ts0710mux*           0640   radio      radio
 /dev/ppp                  0660   radio      vpn
@@ -85,3 +117,16 @@
 /sys/devices/virtual/input/input*   enable      0660  root   input
 /sys/devices/virtual/input/input*   poll_delay  0660  root   input
 /sys/devices/virtual/usb_composite/*   enable      0664  root   system
+/sys/devices/platform/leds-mt65xx/leds/green   delay_on      0664  system   system
+/sys/devices/platform/leds-mt65xx/leds/green   delay_off      0664  system   system
+/sys/devices/platform/leds-mt65xx/leds/red   delay_on      0664  system   system
+/sys/devices/platform/leds-mt65xx/leds/red   delay_off      0664  system   system
+/sys/devices/platform/leds-mt65xx/leds/blue   delay_on      0664  system   system
+/sys/devices/platform/leds-mt65xx/leds/blue   delay_off      0664  system   system
+
+#NFC device
+/dev/msr3110              0666   root       root
+/dev/mt6605              0666   system     system
+
+#GPS
+/dev/gps	0660	gps	system
diff --git a/system/core/sdcard/Android.mk b/gb/12055-master/driveronly_mp_rom/system/core/sdcard/Android.mk
index fb04d6d..6bf753d 100644
--- a/system/core/sdcard/Android.mk
+++ b/gb/12055-master/driveronly_mp_rom/system/core/sdcard/Android.mk
@@ -6,6 +6,6 @@ LOCAL_SRC_FILES:= sdcard.c
 LOCAL_MODULE:= sdcard
 LOCAL_CFLAGS := -Wall -Wno-unused-parameter
 
-LOCAL_SHARED_LIBRARIES := libc
+LOCAL_SHARED_LIBRARIES := libc libcutils 
 
 include $(BUILD_EXECUTABLE)
diff --git a/system/core/sdcard/sdcard.c b/gb/12055-master/driveronly_mp_rom/system/core/sdcard/sdcard.c
index 8d87ee9..d5df449 100644
--- a/system/core/sdcard/sdcard.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/sdcard/sdcard.c
@@ -33,6 +33,12 @@
 
 #include "fuse.h"
 
+#include <cutils/xlog.h>
+#include <cutils/properties.h>
+
+
+#define LOG_TAG "sdcard"
+
 /* README
  *
  * What is this?
@@ -59,16 +65,19 @@
 
 #define FUSE_TRACE 0
 
+#define LOG(x...) xlog_printf(ANDROID_LOG_INFO, LOG_TAG,x)
 #if FUSE_TRACE
-#define TRACE(x...) fprintf(stderr,x)
+#define TRACE(x...) xlog_printf(ANDROID_LOG_INFO, LOG_TAG,x)
 #else
 #define TRACE(x...) do {} while (0)
 #endif
 
-#define ERROR(x...) fprintf(stderr,x)
+#define ERROR(x...)  xlog_printf(ANDROID_LOG_ERROR, LOG_TAG,x)
 
 #define FUSE_UNKNOWN_INO 0xffffffff
 
+#define MOUNT_POINT_2 "/storage/sdcard1"
+
 /* Maximum number of bytes to write in one request. */
 #define MAX_WRITE (256 * 1024)
 
@@ -234,7 +243,7 @@ static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize
  *
  * Populates 'buf' with the path and returns the actual name (within 'buf') on success,
  * or returns NULL if the path is too long for the provided buffer.
- */
+     */
 static char* find_file_within(const char* path, const char* name,
         char* buf, size_t bufsize, int search)
 {
@@ -345,7 +354,7 @@ static int rename_node_locked(struct node *node, const char *name,
         char* new_name = realloc(node->name, namelen + 1);
         if (!new_name) {
             return -ENOMEM;
-        }
+    }
         node->name = new_name;
         if (need_actual_name && node->actual_name) {
             char* new_actual_name = realloc(node->actual_name, namelen + 1);
@@ -363,7 +372,7 @@ static int rename_node_locked(struct node *node, const char *name,
             if (!node->actual_name) {
                 return -ENOMEM;
             }
-        }
+    }
         memcpy(node->actual_name, actual_name, namelen + 1);
     } else {
         free(node->actual_name);
@@ -371,7 +380,7 @@ static int rename_node_locked(struct node *node, const char *name,
     }
     memcpy(node->name, name, namelen + 1);
     node->namelen = namelen;
-    return 0;
+        return 0;
 }
 
 static struct node *lookup_node_by_id_locked(struct fuse *fuse, __u64 nid)
@@ -390,7 +399,7 @@ static struct node* lookup_node_and_path_by_id_locked(struct fuse* fuse, __u64 n
     if (node && get_node_path_locked(node, buf, bufsize) < 0) {
         node = NULL;
     }
-    return node;
+            return node;
 }
 
 static struct node *lookup_child_by_name_locked(struct node *node, const char *name)
@@ -414,9 +423,9 @@ static struct node* acquire_or_create_child_locked(
     struct node* child = lookup_child_by_name_locked(parent, name);
     if (child) {
         acquire_node_locked(child);
-    } else {
+            } else {
         child = create_node_locked(fuse, parent, name, actual_name);
-    }
+            }
     return child;
 }
 
@@ -471,7 +480,7 @@ static int fuse_reply_entry(struct fuse* fuse, __u64 unique,
     struct node* node;
     struct fuse_entry_out out;
     struct stat s;
-
+    
     if (lstat(path, &s) < 0) {
         return -errno;
     }
@@ -527,7 +536,7 @@ static int handle_lookup(struct fuse* fuse, struct fuse_handler* handler,
     if (!parent_node || !(actual_name = find_file_within(parent_path, name,
             child_path, sizeof(child_path), 1))) {
         return -ENOENT;
-    }
+        }
     return fuse_reply_entry(fuse, hdr->unique, parent_node, name, actual_name, child_path);
 }
 
@@ -544,7 +553,7 @@ static int handle_forget(struct fuse* fuse, struct fuse_handler* handler,
         __u64 n = req->nlookup;
         while (n--) {
             release_node_locked(node);
-        }
+    }
     }
     pthread_mutex_unlock(&fuse->lock);
     return NO_STATUS; /* no reply */
@@ -573,12 +582,14 @@ static int handle_setattr(struct fuse* fuse, struct fuse_handler* handler,
 {
     struct node* node;
     char path[PATH_MAX];
-    struct timespec times[2];
+        struct timespec times[2];
 
     pthread_mutex_lock(&fuse->lock);
     node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid, path, sizeof(path));
     TRACE("[%d] SETATTR fh=%llx valid=%x @ %llx (%s)\n", handler->token,
             req->fh, req->valid, hdr->nodeid, node ? node->name : "?");
+    LOG("[%d] SETATTR fh=%llx valid=%x @ %llx (%s)\n", handler->token,
+            req->fh, req->valid, hdr->nodeid, node ? node->name : "?");
     pthread_mutex_unlock(&fuse->lock);
 
     if (!node) {
@@ -592,31 +603,31 @@ static int handle_setattr(struct fuse* fuse, struct fuse_handler* handler,
         return -errno;
     }
 
-    /* Handle changing atime and mtime.  If FATTR_ATIME_and FATTR_ATIME_NOW
-     * are both set, then set it to the current time.  Else, set it to the
-     * time specified in the request.  Same goes for mtime.  Use utimensat(2)
-     * as it allows ATIME and MTIME to be changed independently, and has
-     * nanosecond resolution which fuse also has.
-     */
-    if (req->valid & (FATTR_ATIME | FATTR_MTIME)) {
-        times[0].tv_nsec = UTIME_OMIT;
-        times[1].tv_nsec = UTIME_OMIT;
-        if (req->valid & FATTR_ATIME) {
-            if (req->valid & FATTR_ATIME_NOW) {
-              times[0].tv_nsec = UTIME_NOW;
-            } else {
-              times[0].tv_sec = req->atime;
-              times[0].tv_nsec = req->atimensec;
+        /* Handle changing atime and mtime.  If FATTR_ATIME_and FATTR_ATIME_NOW
+         * are both set, then set it to the current time.  Else, set it to the
+         * time specified in the request.  Same goes for mtime.  Use utimensat(2)
+         * as it allows ATIME and MTIME to be changed independently, and has
+         * nanosecond resolution which fuse also has.
+         */
+        if (req->valid & (FATTR_ATIME | FATTR_MTIME)) {
+            times[0].tv_nsec = UTIME_OMIT;
+            times[1].tv_nsec = UTIME_OMIT;
+            if (req->valid & FATTR_ATIME) {
+                if (req->valid & FATTR_ATIME_NOW) {
+                  times[0].tv_nsec = UTIME_NOW;
+                } else {
+                  times[0].tv_sec = req->atime;
+                  times[0].tv_nsec = req->atimensec;
+                }
             }
-        }
-        if (req->valid & FATTR_MTIME) {
-            if (req->valid & FATTR_MTIME_NOW) {
-              times[1].tv_nsec = UTIME_NOW;
-            } else {
-              times[1].tv_sec = req->mtime;
-              times[1].tv_nsec = req->mtimensec;
+            if (req->valid & FATTR_MTIME) {
+                if (req->valid & FATTR_MTIME_NOW) {
+                  times[1].tv_nsec = UTIME_NOW;
+                } else {
+                  times[1].tv_sec = req->mtime;
+                  times[1].tv_nsec = req->mtimensec;
+                }
             }
-        }
         TRACE("[%d] Calling utimensat on %s with atime %ld, mtime=%ld\n",
                 handler->token, path, times[0].tv_sec, times[1].tv_sec);
         if (utimensat(-1, path, times, 0) < 0) {
@@ -670,7 +681,7 @@ static int handle_mkdir(struct fuse* fuse, struct fuse_handler* handler,
     if (!parent_node || !(actual_name = find_file_within(parent_path, name,
             child_path, sizeof(child_path), 1))) {
         return -ENOENT;
-    }
+        }
     __u32 mode = (req->mode & (~0777)) | 0775;
     if (mkdir(child_path, mode) < 0) {
         return -errno;
@@ -695,7 +706,7 @@ static int handle_unlink(struct fuse* fuse, struct fuse_handler* handler,
     if (!parent_node || !find_file_within(parent_path, name,
             child_path, sizeof(child_path), 1)) {
         return -ENOENT;
-    }
+        }
     if (unlink(child_path) < 0) {
         return -errno;
     }
@@ -738,7 +749,7 @@ static int handle_rename(struct fuse* fuse, struct fuse_handler* handler,
     char old_child_path[PATH_MAX];
     char new_child_path[PATH_MAX];
     const char* new_actual_name;
-    int res;
+        int res;
 
     pthread_mutex_lock(&fuse->lock);
     old_parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
@@ -752,7 +763,7 @@ static int handle_rename(struct fuse* fuse, struct fuse_handler* handler,
     if (!old_parent_node || !new_parent_node) {
         res = -ENOENT;
         goto lookup_error;
-    }
+        }
     child_node = lookup_child_by_name_locked(old_parent_node, old_name);
     if (!child_node || get_node_path_locked(child_node,
             old_child_path, sizeof(old_child_path)) < 0) {
@@ -765,28 +776,28 @@ static int handle_rename(struct fuse* fuse, struct fuse_handler* handler,
     /* Special case for renaming a file where destination is same path
      * differing only by case.  In this case we don't want to look for a case
      * insensitive match.  This allows commands like "mv foo FOO" to work as expected.
-     */
+             */
     int search = old_parent_node != new_parent_node
             || strcasecmp(old_name, new_name);
     if (!(new_actual_name = find_file_within(new_parent_path, new_name,
             new_child_path, sizeof(new_child_path), search))) {
         res = -ENOENT;
         goto io_error;
-    }
+        }
 
     TRACE("[%d] RENAME %s->%s\n", handler->token, old_child_path, new_child_path);
     res = rename(old_child_path, new_child_path);
     if (res < 0) {
         res = -errno;
         goto io_error;
-    }
+        }
 
     pthread_mutex_lock(&fuse->lock);
     res = rename_node_locked(child_node, new_name, new_actual_name);
     if (!res) {
         remove_node_from_parent_locked(child_node);
         add_node_to_parent_locked(child_node, new_parent_node);
-    }
+        }
     goto done;
 
 io_error:
@@ -803,8 +814,8 @@ static int handle_open(struct fuse* fuse, struct fuse_handler* handler,
 {
     struct node* node;
     char path[PATH_MAX];
-    struct fuse_open_out out;
-    struct handle *h;
+        struct fuse_open_out out;
+        struct handle *h;
 
     pthread_mutex_lock(&fuse->lock);
     node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid, path, sizeof(path));
@@ -815,31 +826,31 @@ static int handle_open(struct fuse* fuse, struct fuse_handler* handler,
     if (!node) {
         return -ENOENT;
     }
-    h = malloc(sizeof(*h));
-    if (!h) {
+        h = malloc(sizeof(*h));
+        if (!h) {
         return -ENOMEM;
-    }
+        }
     TRACE("[%d] OPEN %s\n", handler->token, path);
-    h->fd = open(path, req->flags);
-    if (h->fd < 0) {
-        free(h);
+        h->fd = open(path, req->flags);
+        if (h->fd < 0) {
+            free(h);
         return -errno;
-    }
-    out.fh = ptr_to_id(h);
-    out.open_flags = 0;
-    out.padding = 0;
-    fuse_reply(fuse, hdr->unique, &out, sizeof(out));
+        }
+        out.fh = ptr_to_id(h);
+        out.open_flags = 0;
+        out.padding = 0;
+        fuse_reply(fuse, hdr->unique, &out, sizeof(out));
     return NO_STATUS;
 }
 
 static int handle_read(struct fuse* fuse, struct fuse_handler* handler,
         const struct fuse_in_header* hdr, const struct fuse_read_in* req)
 {
-    struct handle *h = id_to_ptr(req->fh);
+        struct handle *h = id_to_ptr(req->fh);
     __u64 unique = hdr->unique;
     __u32 size = req->size;
     __u64 offset = req->offset;
-    int res;
+        int res;
 
     /* Don't access any other fields of hdr or req beyond this point, the read buffer
      * overlaps the request buffer and will clobber data in the request.  This
@@ -849,11 +860,11 @@ static int handle_read(struct fuse* fuse, struct fuse_handler* handler,
             h, h->fd, size, offset);
     if (size > sizeof(handler->read_buffer)) {
         return -EINVAL;
-    }
+        }
     res = pread64(h->fd, handler->read_buffer, size, offset);
-    if (res < 0) {
+        if (res < 0) {
         return -errno;
-    }
+        }
     fuse_reply(fuse, unique, handler->read_buffer, res);
     return NO_STATUS;
 }
@@ -862,18 +873,18 @@ static int handle_write(struct fuse* fuse, struct fuse_handler* handler,
         const struct fuse_in_header* hdr, const struct fuse_write_in* req,
         const void* buffer)
 {
-    struct fuse_write_out out;
-    struct handle *h = id_to_ptr(req->fh);
-    int res;
+        struct fuse_write_out out;
+        struct handle *h = id_to_ptr(req->fh);
+        int res;
 
     TRACE("[%d] WRITE %p(%d) %u@%llu\n", handler->token,
             h, h->fd, req->size, req->offset);
     res = pwrite64(h->fd, buffer, req->size, req->offset);
-    if (res < 0) {
+        if (res < 0) {
         return -errno;
-    }
-    out.size = res;
-    fuse_reply(fuse, hdr->unique, &out, sizeof(out));
+        }
+        out.size = res;
+        fuse_reply(fuse, hdr->unique, &out, sizeof(out));
     return NO_STATUS;
 }
 
@@ -881,9 +892,9 @@ static int handle_statfs(struct fuse* fuse, struct fuse_handler* handler,
         const struct fuse_in_header* hdr)
 {
     char path[PATH_MAX];
-    struct statfs stat;
-    struct fuse_statfs_out out;
-    int res;
+        struct statfs stat;
+        struct fuse_statfs_out out;
+        int res;
 
     pthread_mutex_lock(&fuse->lock);
     TRACE("[%d] STATFS\n", handler->token);
@@ -891,31 +902,31 @@ static int handle_statfs(struct fuse* fuse, struct fuse_handler* handler,
     pthread_mutex_unlock(&fuse->lock);
     if (res < 0) {
         return -ENOENT;
-    }
+        }
     if (statfs(fuse->root.name, &stat) < 0) {
         return -errno;
     }
-    memset(&out, 0, sizeof(out));
-    out.st.blocks = stat.f_blocks;
-    out.st.bfree = stat.f_bfree;
-    out.st.bavail = stat.f_bavail;
-    out.st.files = stat.f_files;
-    out.st.ffree = stat.f_ffree;
-    out.st.bsize = stat.f_bsize;
-    out.st.namelen = stat.f_namelen;
-    out.st.frsize = stat.f_frsize;
-    fuse_reply(fuse, hdr->unique, &out, sizeof(out));
+        memset(&out, 0, sizeof(out));
+        out.st.blocks = stat.f_blocks;
+        out.st.bfree = stat.f_bfree;
+        out.st.bavail = stat.f_bavail;
+        out.st.files = stat.f_files;
+        out.st.ffree = stat.f_ffree;
+        out.st.bsize = stat.f_bsize;
+        out.st.namelen = stat.f_namelen;
+        out.st.frsize = stat.f_frsize;
+        fuse_reply(fuse, hdr->unique, &out, sizeof(out));
     return NO_STATUS;
 }
 
 static int handle_release(struct fuse* fuse, struct fuse_handler* handler,
         const struct fuse_in_header* hdr, const struct fuse_release_in* req)
 {
-    struct handle *h = id_to_ptr(req->fh);
+        struct handle *h = id_to_ptr(req->fh);
 
     TRACE("[%d] RELEASE %p(%d)\n", handler->token, h, h->fd);
-    close(h->fd);
-    free(h);
+        close(h->fd);
+        free(h);
     return 0;
 }
 
@@ -947,8 +958,8 @@ static int handle_opendir(struct fuse* fuse, struct fuse_handler* handler,
 {
     struct node* node;
     char path[PATH_MAX];
-    struct fuse_open_out out;
-    struct dirhandle *h;
+        struct fuse_open_out out;
+        struct dirhandle *h;
 
     pthread_mutex_lock(&fuse->lock);
     node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid, path, sizeof(path));
@@ -959,74 +970,74 @@ static int handle_opendir(struct fuse* fuse, struct fuse_handler* handler,
     if (!node) {
         return -ENOENT;
     }
-    h = malloc(sizeof(*h));
-    if (!h) {
+        h = malloc(sizeof(*h));
+        if (!h) {
         return -ENOMEM;
-    }
+        }
     TRACE("[%d] OPENDIR %s\n", handler->token, path);
-    h->d = opendir(path);
+        h->d = opendir(path);
     if (!h->d) {
-        free(h);
+            free(h);
         return -errno;
-    }
-    out.fh = ptr_to_id(h);
-    fuse_reply(fuse, hdr->unique, &out, sizeof(out));
+        }
+        out.fh = ptr_to_id(h);
+        fuse_reply(fuse, hdr->unique, &out, sizeof(out));
     return NO_STATUS;
 }
 
 static int handle_readdir(struct fuse* fuse, struct fuse_handler* handler,
         const struct fuse_in_header* hdr, const struct fuse_read_in* req)
 {
-    char buffer[8192];
-    struct fuse_dirent *fde = (struct fuse_dirent*) buffer;
-    struct dirent *de;
-    struct dirhandle *h = id_to_ptr(req->fh);
+        char buffer[8192];
+        struct fuse_dirent *fde = (struct fuse_dirent*) buffer;
+        struct dirent *de;
+        struct dirhandle *h = id_to_ptr(req->fh);
 
     TRACE("[%d] READDIR %p\n", handler->token, h);
-    if (req->offset == 0) {
-        /* rewinddir() might have been called above us, so rewind here too */
+        if (req->offset == 0) {
+            /* rewinddir() might have been called above us, so rewind here too */
         TRACE("[%d] calling rewinddir()\n", handler->token);
-        rewinddir(h->d);
-    }
-    de = readdir(h->d);
-    if (!de) {
+            rewinddir(h->d);
+        }
+        de = readdir(h->d);
+        if (!de) {
         return 0;
-    }
-    fde->ino = FUSE_UNKNOWN_INO;
-    /* increment the offset so we can detect when rewinddir() seeks back to the beginning */
-    fde->off = req->offset + 1;
-    fde->type = de->d_type;
-    fde->namelen = strlen(de->d_name);
-    memcpy(fde->name, de->d_name, fde->namelen + 1);
-    fuse_reply(fuse, hdr->unique, fde,
-            FUSE_DIRENT_ALIGN(sizeof(struct fuse_dirent) + fde->namelen));
+        }
+        fde->ino = FUSE_UNKNOWN_INO;
+        /* increment the offset so we can detect when rewinddir() seeks back to the beginning */
+        fde->off = req->offset + 1;
+        fde->type = de->d_type;
+        fde->namelen = strlen(de->d_name);
+        memcpy(fde->name, de->d_name, fde->namelen + 1);
+        fuse_reply(fuse, hdr->unique, fde,
+                   FUSE_DIRENT_ALIGN(sizeof(struct fuse_dirent) + fde->namelen));
     return NO_STATUS;
 }
 
 static int handle_releasedir(struct fuse* fuse, struct fuse_handler* handler,
         const struct fuse_in_header* hdr, const struct fuse_release_in* req)
 {
-    struct dirhandle *h = id_to_ptr(req->fh);
+        struct dirhandle *h = id_to_ptr(req->fh);
 
     TRACE("[%d] RELEASEDIR %p\n", handler->token, h);
-    closedir(h->d);
-    free(h);
+        closedir(h->d);
+        free(h);
     return 0;
 }
 
 static int handle_init(struct fuse* fuse, struct fuse_handler* handler,
         const struct fuse_in_header* hdr, const struct fuse_init_in* req)
 {
-    struct fuse_init_out out;
-
+        struct fuse_init_out out;
+        
     TRACE("[%d] INIT ver=%d.%d maxread=%d flags=%x\n",
             handler->token, req->major, req->minor, req->max_readahead, req->flags);
-    out.major = FUSE_KERNEL_VERSION;
-    out.minor = FUSE_KERNEL_MINOR_VERSION;
-    out.max_readahead = req->max_readahead;
-    out.flags = FUSE_ATOMIC_O_TRUNC | FUSE_BIG_WRITES;
-    out.max_background = 32;
-    out.congestion_threshold = 32;
+        out.major = FUSE_KERNEL_VERSION;
+        out.minor = FUSE_KERNEL_MINOR_VERSION;
+        out.max_readahead = req->max_readahead;
+        out.flags = FUSE_ATOMIC_O_TRUNC | FUSE_BIG_WRITES;
+        out.max_background = 32;
+        out.congestion_threshold = 32;
     out.max_write = MAX_WRITE;
     fuse_reply(fuse, hdr->unique, &out, sizeof(out));
     return NO_STATUS;
@@ -1152,7 +1163,7 @@ static int handle_fuse_request(struct fuse *fuse, struct fuse_handler* handler,
                 handler->token, hdr->opcode, hdr->unique, hdr->nodeid);
         return -ENOSYS;
     }
-    }
+    }   
 }
 
 static void handle_fuse_requests(struct fuse_handler* handler)
@@ -1165,7 +1176,7 @@ static void handle_fuse_requests(struct fuse_handler* handler)
             if (errno != EINTR) {
                 ERROR("[%d] handle_fuse_requests: errno=%d\n", handler->token, errno);
             }
-            continue;
+                continue;
         }
 
         if ((size_t)len < sizeof(struct fuse_in_header)) {
@@ -1178,7 +1189,7 @@ static void handle_fuse_requests(struct fuse_handler* handler)
             ERROR("[%d] malformed header: len=%zu, hdr->len=%u\n",
                     handler->token, (size_t)len, hdr->len);
             continue;
-        }
+    }
 
         const void *data = handler->request_buffer + sizeof(struct fuse_in_header);
         size_t data_len = len - sizeof(struct fuse_in_header);
@@ -1258,19 +1269,32 @@ static int run(const char* source_path, const char* dest_path, uid_t uid, gid_t
     fd = open("/dev/fuse", O_RDWR);
     if (fd < 0){
         ERROR("cannot open fuse device (error %d)\n", errno);
-        return -1;
+    return -1;
     }
 
     snprintf(opts, sizeof(opts),
             "fd=%i,rootmode=40000,default_permissions,allow_other,user_id=%d,group_id=%d",
             fd, uid, gid);
 
-    res = mount("/dev/fuse", dest_path, "fuse", MS_NOSUID | MS_NODEV, opts);
+    res = mount("/dev/fuse", dest_path, "fuse", MS_NOSUID | MS_NODEV  , opts);
     if (res < 0) {
         ERROR("cannot mount fuse filesystem (error %d)\n", errno);
         goto error;
     }
 
+#if !defined(MTK_2SDCARD_SWAP) && defined(MTK_SHARED_SDCARD)
+    LOG("For ssd only version, let native process has access right to /storage/emulated/[uid] \n");
+    const char* emulatedStorageSource = getenv("EMULATED_STORAGE_SOURCE");
+    const char* emulatedStorageTarget = getenv("EMULATED_STORAGE_TARGET");
+
+    if (umount(emulatedStorageTarget)) {
+        LOG("Failed to umount: %s ,%s(%d)", emulatedStorageTarget, strerror(errno), errno);         
+    }   
+    if (mount(emulatedStorageSource,emulatedStorageTarget, "", MS_BIND, NULL)) {
+        LOG("Failed to bind mount: %s -> %s ,%s(%d)", emulatedStorageSource, emulatedStorageTarget, strerror(errno), errno);            
+    }
+#endif
+
     res = setgid(gid);
     if (res < 0) {
         ERROR("cannot setgid (error %d)\n", errno);
@@ -1296,6 +1320,58 @@ error:
     return res;
 }
 
+typedef enum {
+    NORMAL_BOOT = 0,
+    META_BOOT = 1,
+    RECOVERY_BOOT = 2,    
+    SW_REBOOT = 3,
+    FACTORY_BOOT = 4,
+    ADVMETA_BOOT = 5,
+    ATE_FACTORY_BOOT = 6,
+    ALARM_BOOT = 7,
+    UNKNOWN_BOOT
+} BOOT_MODE;
+static int get_boot_mode(void)
+{
+  int fd;
+  size_t s;
+  char boot_mode[2];
+  memset(boot_mode, 0x00, sizeof(boot_mode));
+
+  fd = open("/sys/class/BOOT/BOOT/boot/boot_mode", O_RDWR);
+  if (fd < 0)
+  {
+    printf("fail to open: %s\n", "/sys/class/BOOT/BOOT/boot/boot_mode");
+    return 0;
+  }
+
+  s = read(fd, (void *)boot_mode, sizeof(char));
+  close(fd);
+
+  if(s <= 0)
+  {
+    ERROR("could not read boot mode sys file\n");
+    return 0;
+  }
+
+  return atoi(boot_mode);
+}
+
+static char *replace(const char *src, char *token, char *target) {
+    static char buffer[1024];
+    char *pch;
+    if( !(pch = strstr(src, token)))
+    {
+        strcpy(buffer, src);
+        return buffer;
+    }
+    strncpy( buffer, src, pch-src);
+    buffer[pch-src]=0;
+    sprintf( buffer+(pch-src), "%s%s", target, pch+strlen(token));
+    return buffer;
+
+}
+
 int main(int argc, char **argv)
 {
     int res;
@@ -1306,6 +1382,7 @@ int main(int argc, char **argv)
     int num_threads = DEFAULT_NUM_THREADS;
     int i;
 
+    LOG("starting sdcard service\n");
     for (i = 1; i < argc; i++) {
         char* arg = argv[i];
         if (!strncmp(arg, "-t", 2))
@@ -1352,7 +1429,47 @@ int main(int argc, char **argv)
         ERROR("number of threads must be at least 1\n");
         return usage();
     }
+#ifdef MTK_2SDCARD_SWAP
+    int hasExternalSd = 0;
+    int fd_externalsd;
+    char internal_sd_path[PROPERTY_VALUE_MAX];
+	property_get("internal_sd_path", internal_sd_path, "");
+
+    if (get_boot_mode() != FACTORY_BOOT && get_boot_mode() != ATE_FACTORY_BOOT) { 
+        /*    
+                  The sdcard is mounted via VOLD except FACTORY mode.
+                  If via vold, we need to consider SWAP feature
+              */        
+        
+        fd_externalsd = open("/dev/block/mmcblk1", O_RDONLY);
+        if (fd_externalsd < 0){
+            TRACE("External sd doesn't exist (%d)\n", errno);
+            hasExternalSd = 0;
+        }
+        else {
+            TRACE("External sd exist.\n");
+            hasExternalSd = 1;
+            close(fd_externalsd);
+        }           
+    } 
+    else {
+        hasExternalSd = 0; 
+        LOG("This is FACTORY mode, we DON'T need consider MTK_2SDCARD_SWAP feature\n");
+    }
+
+    LOG("hasExternalSd=%d, internal_sd_path = '%s'\n", hasExternalSd, internal_sd_path);     
+
+    if (hasExternalSd) {
+        if (strlen(internal_sd_path) > 0) {
+           dest_path = internal_sd_path;
+        }
+        else {
+           dest_path = MOUNT_POINT_2;
+    }
+    }
+#endif  
 
+    LOG("source_path=%d,dest_path = '%s'\n", source_path, dest_path);     
     res = run(source_path, dest_path, uid, gid, num_threads);
     return res < 0 ? 1 : 0;
 }
diff --git a/system/core/toolbox/newfs_msdos.c b/gb/12055-master/driveronly_mp_rom/system/core/toolbox/newfs_msdos.c
index 6d78eb6..07eb02f 100644
--- a/system/core/toolbox/newfs_msdos.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/toolbox/newfs_msdos.c
@@ -31,6 +31,7 @@ static const char rcsid[] =
 #endif /* not lint */
 
 #include <sys/param.h>
+#include <linux/kdev_t.h>
 
 #ifndef ANDROID
   #include <sys/fdcio.h>
@@ -57,6 +58,7 @@ static const char rcsid[] =
 #include <string.h>
 #include <time.h>
 #include <unistd.h>
+#define MTK_SDCARDMOUNTPOINT_CHECK	1	/* it is added for checking if the sdcard is mounted when formatting */ 
 
 #define MAXU16	  0xffff	/* maximum unsigned 16-bit quantity */
 #define BPN	  4		/* bits per nibble */
@@ -728,7 +730,189 @@ newfs_msdos_main(int argc, char *argv[])
     }
     return 0;
 }
+#ifdef MTK_SDCARDMOUNTPOINT_CHECK
 
+static int get_symbolic_link( const char *dev, char **link)
+{
+	FILE* fp;
+	char rd_line[128];
+	char buf[255] = {0};
+	char * pch;
+
+	//*link[0] = '\0';
+	strcpy(rd_line, "ls -l ");
+	strcat(rd_line, dev);
+	if ((fp = popen(rd_line, "r")) == NULL)
+	{
+		warnx("could not find the symbolic link\n");
+		return -1;
+	}else
+	{
+		while   (fgets(buf,   255,   fp)   !=   NULL)
+		{
+			pch = strtok(buf," ");
+			while (pch != NULL)
+			{
+				*link = pch;
+				pch = strtok (NULL, " ");
+			}   
+		}
+	}
+	
+	pclose(fp);
+	if( *link[0] == 0 )
+		return -1;
+	else
+	{
+		*link = strtok(*link, " \n");
+		printf( "symbolic_link:%s\n", *link);
+		return 1;
+	}
+}
+
+static int get_dev_major_minor( const char *dev, int *major, int *minor)
+{
+	struct stat s;
+	char linkto[256] = {0};
+        int len;
+
+	if(lstat(dev, &s) < 0) {
+		printf("%s:lstat error\n", dev);
+        	return -1;
+    	}
+	while( linkto[0] == 0)
+	{
+		if( (s.st_mode & S_IFMT) == S_IFCHR || (s.st_mode & S_IFMT) == S_IFBLK)
+		{
+			printf("major:%d minor:%d\n",(int) MAJOR(s.st_rdev), (int) MINOR(s.st_rdev));
+			*major = (int) MAJOR(s.st_rdev);
+			*minor = (int) MINOR(s.st_rdev);
+			return 1;
+		}
+		else if( (s.st_mode & S_IFMT) == S_IFLNK )
+		{
+			len = readlink(dev, linkto, 256);
+		        if(len < 0)
+		        {
+		        	printf("readlink error");
+				return -1;
+		        }
+
+		        if(len > 255) {
+				linkto[252] = '.';
+				linkto[253] = '.';
+				linkto[254] = '.';
+				linkto[255] = 0;
+				return -1;
+		        } else {
+				linkto[len] = 0;
+			}
+			printf("linkto:%s\n",linkto);
+		}else
+		{
+			printf("no major minor\n");
+			return -1;
+		}
+		if(lstat(linkto, &s) < 0) {
+			printf("%s:lstat error\n", dev);
+        		return -1;
+    		}
+		linkto[0] = 0;
+	}
+	
+	return 1;
+        
+}
+static int get_mounts_dev_dir(const char *arg, char *dir)
+{
+	FILE *f;
+	char mount_dev[256];
+	char mount_dir[256];
+	char mount_type[256];
+	char mount_opts[256];
+	int mount_freq;
+	int mount_passno;
+	int match;
+	char rd_line[128];
+	char buf[255] = {0};
+	int major=0, minor=0, mount_major=-1, mount_minor=-1;
+
+	
+	get_dev_major_minor(arg, &major, &minor);
+
+	
+	/**
+	 **	parse the mounts to iterate all the mount points
+	 **
+	 **/
+	f = fopen("/proc/mounts", "r");
+	if (!f) {
+		warnx("could not open /proc/mounts\n");
+		return -1;
+	}
+	do {
+		match = fscanf(f, "%255s %255s %255s %255s %d %d\n",
+		mount_dev, mount_dir, mount_type,
+		mount_opts, &mount_freq, &mount_passno);
+		
+		printf("mount_dev:%s\n", mount_dev);
+		mount_dev[255] = 0;
+		mount_dir[255] = 0;
+		mount_type[255] = 0;
+		mount_opts[255] = 0;
+		if (match == 6 && strcmp(arg, mount_dev) == 0 ) 
+		{
+			//*dir = strdup(mount_dir);
+			strcpy(dir, mount_dir);
+			fclose(f);
+			return 1;
+		}
+		//check the major & minor number
+		if (match == 6 && get_dev_major_minor( mount_dev, &mount_major, &mount_minor) == 1 &&
+		major == mount_major && minor == mount_minor) 
+		{
+			//*dir = strdup(mount_dir);
+			strcpy(dir, mount_dir);
+			fclose(f);
+			return 1;
+		}
+	} while (match != EOF);
+
+	fclose(f);
+	return -1;
+}
+int checkfilestat(int argc,char *argv[])
+{
+	struct stat s;
+	int length;
+	char *path;
+
+	if( argc == 2 )
+		path = argv[1];
+	else
+	{
+		printf("error\n");
+		return 0;
+	}
+	if (lstat(path, &s) < 0)
+	{
+		printf("errror1\n");
+		return 0;
+	}
+	printf("%x\n", s.st_mode);
+	if ((s.st_mode & S_IFMT) != S_IFLNK)
+		return 0;
+
+// we have a symlink
+/*   length = readlink(path, link, max- 1);
+ if (length <= 0)
+ return 0;
+link[length] = 0;
+*/   
+	return 0;
+}
+
+#endif
 /*
  * Exit with error if file system is mounted.
  */
@@ -739,9 +923,18 @@ check_mounted(const char *fname, mode_t mode)
     const char *s1, *s2;
     size_t len;
     int n, r;
+    char dir[256];
 
 #ifdef ANDROID
-    warnx("Skipping mount checks");
+#ifdef MTK_SDCARDMOUNTPOINT_CHECK
+	printf("Mount checks %s\n", fname);
+	if( get_mounts_dev_dir(fname, dir) == 1)
+	{
+		errx(1, "%s is mounted on %s", fname, dir);
+	}
+#else
+	warnx("Skipping mount checks");
+#endif
 #else
     if (!(n = getmntinfo(&mp, MNT_NOWAIT)))
 	err(1, "getmntinfo");
diff --git a/system/core/toolbox/top.c b/gb/12055-master/driveronly_mp_rom/system/core/toolbox/top.c
index 7642522..163df9b 100644
--- a/system/core/toolbox/top.c
+++ b/gb/12055-master/driveronly_mp_rom/system/core/toolbox/top.c
@@ -436,6 +436,11 @@ static void print_procs(void) {
     qsort(new_procs, num_new_procs, sizeof(struct proc_info *), proc_cmp);
 
     printf("\n\n\n");
+    if(total_delta_time==0)
+    {
+    	printf("top die for total_delta_time 0.\n");
+    	return;
+    }	
     printf("User %ld%%, System %ld%%, IOW %ld%%, IRQ %ld%%\n",
             ((new_cpu.utime + new_cpu.ntime) - (old_cpu.utime + old_cpu.ntime)) * 100  / total_delta_time,
             ((new_cpu.stime ) - (old_cpu.stime)) * 100 / total_delta_time,
